From e499c7cb9a7abbaa911ac87bfbe5a8763df4ea59 Mon Sep 17 00:00:00 2001
From: olegsvs <oleg.texet@gmail.com>
Date: Wed, 20 Jul 2016 16:23:33 -0400
Subject: [PATCH] patch

Change-Id: Ia61557423b419e44276a1f18d8b3dd0eaef636fb
---
 .../android/internal/telephony/BaseCommands.java   | 1377 +++++
 .../internal/telephony/CallForwardInfoEx.java      |   65 +
 .../internal/telephony/CommandException.java       |   51 +
 .../internal/telephony/CommandsInterface.java      | 1512 +++++-
 .../com/android/internal/telephony/DriverCall.java |   19 +-
 .../com/android/internal/telephony/IccCard.java    |   99 +
 .../android/internal/telephony/MediaTekRIL.java    | 5328 ++++++++++++++++++++
 .../com/android/internal/telephony/PhbEntry.java   |   71 +
 .../android/internal/telephony/PhoneFactory.java   |  261 +
 src/java/com/android/internal/telephony/RIL.java   |  544 +-
 .../internal/telephony/ServiceStateTracker.java    |    7 +
 .../internal/telephony/SubscriptionController.java |   52 +
 .../android/internal/telephony/SuppSrvRequest.java |  101 +
 .../internal/telephony/cat/AppInterface.java       |    7 +-
 .../internal/telephony/cat/CatCmdMessage.java      |   10 +
 .../android/internal/telephony/cat/CatService.java |   43 +-
 .../internal/telephony/cat/CommandParams.java      |   19 +
 .../telephony/dataconnection/DcTracker.java        |  131 +-
 .../telephony/dataconnection/DcTrackerBase.java    |  110 +-
 .../telephony/dataconnection/DctController.java    |   12 -
 .../internal/telephony/gsm/CallFailCause.java      |   29 +
 .../android/internal/telephony/gsm/GSMPhone.java   |    7 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |   54 +-
 .../imsphone/ImsPhoneCommandInterface.java         |  109 +
 .../telephony/sip/SipCommandInterface.java         |  109 +
 .../internal/telephony/test/SimulatedCommands.java |  135 +
 .../internal/telephony/uicc/IccCardProxy.java      |  373 +-
 .../internal/telephony/uicc/IccRecords.java        |    7 +
 .../telephony/uicc/IccRefreshResponse.java         |    9 +-
 .../internal/telephony/uicc/SpnOverride.java       |  466 ++
 .../android/internal/telephony/uicc/UiccCard.java  |  464 +-
 .../telephony/uicc/UiccCardApplication.java        |  224 +-
 .../internal/telephony/uicc/UiccController.java    |  158 +
 .../internal/telephony/AirplaneRequestHandler.java |  311 ++
 .../telephony/ConferenceCallMessageHandler.java    |  347 ++
 .../mediatek/internal/telephony/FemtoCellInfo.aidl |   19 +
 .../mediatek/internal/telephony/FemtoCellInfo.java |  154 +
 .../mediatek/internal/telephony/IRadioPower.java   |   42 +
 .../internal/telephony/ModemSwitchHandler.java     |  311 ++
 .../internal/telephony/NetworkInfoWithAcT.aidl     |   57 +
 .../internal/telephony/NetworkInfoWithAcT.java     |  201 +
 .../internal/telephony/NetworkManager.java         |  101 +
 .../telephony/RadioCapabilitySwitchUtil.java       |  619 +++
 .../mediatek/internal/telephony/RadioManager.java  | 1195 +++++
 .../internal/telephony/SrvccCallContext.java       |  330 ++
 .../telephony/cdma/CdmaFeatureOptionUtils.java     |  181 +
 .../telephony/dataconnection/IaExtendParam.java    |   78 +
 .../internal/telephony/ltedc/LteDcConstants.java   |   17 +
 .../internal/telephony/ltedc/svlte/SvlteUtils.java |  233 +
 .../internal/telephony/worldphone/IWorldPhone.java |  122 +
 .../internal/telephony/worldphone/WorldMode.java   |  325 ++
 .../telephony/worldphone/WorldPhoneOm.java         | 1665 ++++++
 .../telephony/worldphone/WorldPhoneUtil.java       |  431 ++
 .../telephony/worldphone/WorldPhoneWrapper.java    |   87 +
 .../mediatek/telephony/ExternalSimConstants.java   |  100 +
 .../com/mediatek/telephony/ExternalSimManager.java | 1272 +++++
 .../telephony/PhoneNumberFormatUtilEx.java         | 2431 +++++++++
 .../PhoneNumberFormattingTextWatcherEx.java        |  135 +
 .../com/mediatek/telephony/TelephonyManagerEx.java | 1368 +++++
 59 files changed, 24000 insertions(+), 95 deletions(-)
 create mode 100644 src/java/com/android/internal/telephony/CallForwardInfoEx.java
 create mode 100644 src/java/com/android/internal/telephony/MediaTekRIL.java
 create mode 100755 src/java/com/android/internal/telephony/PhbEntry.java
 create mode 100755 src/java/com/android/internal/telephony/SuppSrvRequest.java
 create mode 100644 src/java/com/mediatek/internal/telephony/AirplaneRequestHandler.java
 create mode 100755 src/java/com/mediatek/internal/telephony/ConferenceCallMessageHandler.java
 create mode 100755 src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
 create mode 100755 src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
 create mode 100644 src/java/com/mediatek/internal/telephony/IRadioPower.java
 create mode 100755 src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkManager.java
 create mode 100644 src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
 create mode 100644 src/java/com/mediatek/internal/telephony/RadioManager.java
 create mode 100755 src/java/com/mediatek/internal/telephony/SrvccCallContext.java
 create mode 100644 src/java/com/mediatek/internal/telephony/cdma/CdmaFeatureOptionUtils.java
 create mode 100644 src/java/com/mediatek/internal/telephony/dataconnection/IaExtendParam.java
 create mode 100644 src/java/com/mediatek/internal/telephony/ltedc/LteDcConstants.java
 create mode 100644 src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
 create mode 100644 src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java
 create mode 100644 src/java/com/mediatek/telephony/ExternalSimConstants.java
 create mode 100644 src/java/com/mediatek/telephony/ExternalSimManager.java
 create mode 100755 src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
 create mode 100755 src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
 create mode 100644 src/java/com/mediatek/telephony/TelephonyManagerEx.java

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index c586087..ee2badd 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -18,14 +18,19 @@
 package com.android.internal.telephony;
 
 import android.content.Context;
+import android.os.AsyncResult;
 import android.os.Message;
 import android.os.RegistrantList;
 import android.os.Registrant;
 import android.os.Handler;
 import android.os.AsyncResult;
 import android.telephony.RadioAccessFamily;
+import android.telephony.Rlog;
 import android.telephony.TelephonyManager;
 
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.SrvccCallContext;
+
 import com.android.internal.telephony.RadioCapability;
 
 /**
@@ -462,6 +467,15 @@ public abstract class BaseCommands implements CommandsInterface {
     @Override
     public void setOnIccSmsFull(Handler h, int what, Object obj) {
         mIccSmsFullRegistrant = new Registrant (h, what, obj);
+
+        // MTK-START, SMS part
+        if (mIsSmsSimFull == true) {
+            mIccSmsFullRegistrant.notifyRegistrant();
+            // Already notify, set as false. Because there is no URC to notify avaliable and
+            // only one module will register. Looks like a workaround solution and make it easy
+            mIsSmsSimFull = false;
+        }
+        // MTK-END, SMS part
     }
 
     @Override
@@ -945,4 +959,1367 @@ public abstract class BaseCommands implements CommandsInterface {
         return TelephonyManager.getLteOnGsmModeStatic();
     }
 
+    // MTK
+
+    //MTK-START Support Multi-Application
+    protected RegistrantList mSessionChangedRegistrants = new RegistrantList();
+    //MTK-END Support Multi-Application
+
+    protected Registrant mStkEvdlCallRegistrant;
+    protected Registrant mStkSetupMenuResetRegistrant;
+    protected Registrant mStkCallCtrlRegistrant;
+
+    /// M: CC010: Add RIL interface @{
+    protected RegistrantList mCallForwardingInfoRegistrants = new RegistrantList();
+    protected Registrant mCallRelatedSuppSvcRegistrant;
+    protected Registrant mIncomingCallIndicationRegistrant;
+    //protected Registrant mCnapNotifyRegistrant; //obsolete
+    protected RegistrantList mCipherIndicationRegistrant = new RegistrantList();
+    /// @}
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    protected Registrant mSpeechCodecInfoRegistrant;
+    /// @}
+
+    //Remote SIM ME lock related APIs [Start]
+    protected RegistrantList mMelockRegistrants = new RegistrantList();
+    //Remote SIM ME lock related APIs [End]
+
+    protected RegistrantList mPhbReadyRegistrants = new RegistrantList();
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    protected RegistrantList mEconfSrvccRegistrants = new RegistrantList();
+    /* Register for updating conference call merged/added result. */
+    protected RegistrantList mEconfResultRegistrants = new RegistrantList();
+    /* Register for updating call mode and pau. */
+    protected RegistrantList mCallInfoRegistrants = new RegistrantList();
+    /// @}
+
+    // M: fast dormancy.
+    protected Registrant mScriResultRegistrant;
+    // M: CC33 LTE.
+    protected RegistrantList mRacUpdateRegistrants = new RegistrantList();
+    protected RegistrantList mRemoveRestrictEutranRegistrants = new RegistrantList();
+
+    protected RegistrantList mResetAttachApnRegistrants = new RegistrantList();
+
+    /// M: [C2K] for eng mode
+    protected RegistrantList mEngModeNetworkInfoRegistrant = new RegistrantList();
+
+    /// M: [C2K] for call fade
+    protected Registrant mCdmaSignalFadeRegistrant;
+    /// M: [C2K] for tone signal
+    protected Registrant mCdmaToneSignalsRegistrant;
+    /// M: BIP {
+    protected Registrant mBipProCmdRegistrant;
+    /// M: BIP }
+
+    // Mode of Xtk, Stk or Utk. Set by SvlteRatController
+    protected int mStkSwitchMode;
+    // xTK BIP PS Type. Set by SvltePhoneProxy
+    protected int mBipPsType;
+    // for capability switch to early get modem capability
+    RadioCapability mRadioCapability;
+
+    /* M: network part start */
+    protected RegistrantList mFemtoCellInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNeighboringInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNetworkInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNetworkExistRegistrants = new RegistrantList();
+
+    protected RegistrantList mPlmnChangeNotificationRegistrant = new RegistrantList();
+    protected Registrant mRegistrationSuspendedRegistrant;
+    protected Object mEmsrReturnValue = null;
+    protected Object mEcopsReturnValue = null;
+    protected Object mWPMonitor = new Object();
+
+    //VoLTE
+    protected RegistrantList mImsEnableRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableRegistrants = new RegistrantList();
+    protected RegistrantList mImsRegistrationInfoRegistrants = new RegistrantList();
+    protected RegistrantList mDedicateBearerActivatedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerModifiedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerDeactivatedRegistrant = new RegistrantList();
+
+    protected RegistrantList mPsNetworkStateRegistrants = new RegistrantList();
+    protected RegistrantList mImeiLockRegistrant = new RegistrantList();
+    protected RegistrantList mInvalidSimInfoRegistrant = new RegistrantList();
+    protected RegistrantList mGetAvailableNetworkDoneRegistrant = new RegistrantList();
+    /* M: network part end */
+
+    /// M: CC010: Add RIL interface @{
+    protected Object mCfuReturnValue = null; ///* M: SS part */
+    /// @}
+
+    // MTK-START, SMS part
+    // In order to cache the event from modem at boot-up sequence
+    protected boolean mIsSmsSimFull = false;
+    protected boolean mIsSmsReady = false;
+    protected RegistrantList mSmsReadyRegistrants = new RegistrantList();
+    protected Registrant mMeSmsFullRegistrant;
+    protected Registrant mEtwsNotificationRegistrant;
+    // MTK-END
+
+    // IMS VoLTE
+    protected RegistrantList mEpsNetworkFeatureSupportRegistrants = new RegistrantList();
+    protected RegistrantList mEpsNetworkFeatureInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSrvccHandoverInfoIndicationRegistrants = new RegistrantList();
+    protected RegistrantList mMoDataBarringInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSsacBarringInfoRegistrants = new RegistrantList();
+    /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+    protected RegistrantList mEmergencyBearerSupportInfoRegistrants = new RegistrantList();
+    /// @}
+
+    /* C2K part start */
+    protected RegistrantList mViaGpsEvent = new RegistrantList();
+    protected RegistrantList mAcceptedRegistrant = new RegistrantList();
+    protected RegistrantList mNetworkTypeChangedRegistrant = new RegistrantList();
+    protected Registrant mUtkSessionEndRegistrant;
+    protected Registrant mUtkProCmdRegistrant;
+    protected Registrant mUtkEventRegistrant;
+    protected RegistrantList mInvalidSimDetectedRegistrant = new RegistrantList();
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    protected RegistrantList mMccMncChangeRegistrants = new RegistrantList();
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    protected RegistrantList mGmssRatChangedRegistrant = new RegistrantList();
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed.
+    protected RegistrantList mDataNetworkTypeChangedRegistrant = new RegistrantList();
+
+    /// M: [C2K][MD IRAT] add IRat state change registrant.
+    protected RegistrantList mIratStateChangeRegistrant = new RegistrantList();
+
+    /* C2K part end */
+
+    protected RegistrantList mAbnormalEventRegistrant = new RegistrantList();
+
+    /// M: For 3G VT only @{
+    protected RegistrantList mVtStatusInfoRegistrants = new RegistrantList();
+    protected RegistrantList mVtRingRegistrants = new RegistrantList();
+    /// @}
+
+    protected RegistrantList mCdmaImsiReadyRegistrant = new RegistrantList();
+    protected RegistrantList mImsiRefreshDoneRegistrant = new RegistrantList();
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    protected RegistrantList mLteAccessStratumStateRegistrants = new RegistrantList();
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /// M: BIP {
+    @Override
+    public void setOnBipProactiveCmd(Handler h, int what, Object obj) {
+        mBipProCmdRegistrant = new Registrant (h, what, obj);
+    }
+
+    @Override
+    public void unSetOnBipProactiveCmd(Handler h) {
+        if (mBipProCmdRegistrant != null && mBipProCmdRegistrant.getHandler() == h) {
+            mBipProCmdRegistrant.clear();
+            mBipProCmdRegistrant = null;
+        }
+    }
+    /// M: BIP }
+
+    @Override
+    public void setStkEvdlCallByAP(int enabled, Message response) {
+    }
+
+
+    @Override
+    public void setOnStkEvdlCall(Handler h, int what, Object obj) {
+        mStkEvdlCallRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkEvdlCall(Handler h) {
+        mStkEvdlCallRegistrant.clear();
+    }
+
+    @Override
+    public void setOnStkSetupMenuReset(Handler h, int what, Object obj) {
+        mStkSetupMenuResetRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkSetupMenuReset(Handler h) {
+        mStkSetupMenuResetRegistrant.clear();
+    }
+
+    @Override
+    public void setOnStkCallCtrl(Handler h, int what, Object obj) {
+        mStkCallCtrlRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkCallCtrl(Handler h) {
+        mStkCallCtrlRegistrant.clear();
+    }
+
+    //MTK-START [mtk06800] modem power on/off
+    @Override
+    public void setModemPower(boolean power, Message response) {
+    }
+    //MTK-END [mtk06800] modem power on/off
+
+    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
+            Message response) {
+    }
+
+    /// M: CC010: Add RIL interface @{
+    public void registerForCipherIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCipherIndicationRegistrant.add(r);
+    }
+
+    public void unregisterForCipherIndication(Handler h) {
+        mCipherIndicationRegistrant.remove(h);
+    }
+
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallForwardingInfoRegistrants.add(r);
+        /* M: SS part */
+        if (mCfuReturnValue != null) {
+           r.notifyRegistrant(new AsyncResult(null, mCfuReturnValue, null));
+        }
+        /* M: SS part end */
+    }
+
+    public void unregisterForCallForwardingInfo(Handler h) {
+        mCallForwardingInfoRegistrants.remove(h);
+    }
+
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj) {
+        mCallRelatedSuppSvcRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRelatedSuppSvc(Handler h) {
+        mCallRelatedSuppSvcRegistrant.clear();
+    }
+
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj) {
+        mIncomingCallIndicationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unsetOnIncomingCallIndication(Handler h) {
+        mIncomingCallIndicationRegistrant.clear();
+    }
+
+    //obsolete
+    /*
+    public void setCnapNotify(Handler h, int what, Object obj) {
+        mCnapNotifyRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetCnapNotify(Handler h) {
+        mCnapNotifyRegistrant.clear();
+    }
+    */
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    @Override
+    public void setOnSpeechCodecInfo(Handler h, int what, Object obj) {
+        mSpeechCodecInfoRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnSpeechCodecInfo(Handler h) {
+        if (mSpeechCodecInfoRegistrant != null && mSpeechCodecInfoRegistrant.getHandler() == h) {
+            mSpeechCodecInfoRegistrant.clear();
+            mSpeechCodecInfoRegistrant = null;
+        }
+    }
+    /// @}
+
+    public void hangupAll(Message result) {}
+    public void forceReleaseCall(int index, Message response) {}
+    public void setCallIndication(int mode, int callId, int seqNumber, Message response) {}
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {}
+    public void setEccServiceCategory(int serviceCategory) {}
+    /// @}
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response) {}
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void registerForVtStatusInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVtStatusInfoRegistrants.add(r);
+    }
+
+    public void unregisterForVtStatusInfo(Handler h) {
+        mVtStatusInfoRegistrants.remove(h);
+    }
+
+    public void registerForVtRingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVtRingRegistrants.add(r);
+    }
+
+    public void unregisterForVtRingInfo(Handler h) {
+        mVtRingRegistrants.remove(h);
+    }
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {}
+    public void acceptVtCallWithVoiceOnly(int callId, Message result) {}
+    public void replaceVtCall(int index, Message result) {}
+    /// @}
+    /* M: SS part  */
+    ///M: For query CNAP
+    public void sendCNAPSS(String cnapssString, Message response){}
+    public void setCLIP(boolean enable, Message response) {}
+    /* M: SS part end */
+
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response){}
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result){}
+
+    @Override
+    public void registerForSessionChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSessionChangedRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForSessionChanged(Handler h) {
+        mSessionChangedRegistrants.remove(h);
+    }
+    //MTK-END Support Multi-Application
+
+    //MTK-START Support SIM ME lock
+    @Override
+    public void queryNetworkLock(int categrory, Message response){};
+
+    @Override
+    public void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response){};
+    //MTK-END Support SIM ME lock
+
+    @Override
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                          String param2, Message response) {
+    }
+    // Added by M begin
+
+    protected RegistrantList mSimMissing = new RegistrantList();
+    protected RegistrantList mSimRecovery = new RegistrantList();
+    protected RegistrantList mVirtualSimOn = new RegistrantList();
+    protected RegistrantList mVirtualSimOff = new RegistrantList();
+    protected RegistrantList mSimPlugOutRegistrants = new RegistrantList();
+    protected RegistrantList mSimPlugInRegistrants = new RegistrantList();
+    protected RegistrantList mTrayPlugInRegistrants = new RegistrantList();
+    protected RegistrantList mCdmaCardTypeRegistrants = new RegistrantList();
+    protected RegistrantList mCommonSlotNoChangedRegistrants = new RegistrantList();
+    protected RegistrantList mDataAllowedRegistrants = new RegistrantList();
+    protected RegistrantList mEusimReady = new RegistrantList();
+    protected boolean mIsEusimReady = false;
+    protected Object mCdmaCardTypeValue = null;
+
+    public void registerForSimMissing(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimMissing.add(r);
+    }
+    public void unregisterForSimMissing(Handler h) {
+        mSimMissing.remove(h);
+    }
+
+    public void registerForSimRecovery(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimRecovery.add(r);
+    }
+
+    public void unregisterForSimRecovery(Handler h) {
+        mSimRecovery.remove(h);
+    }
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOn.add(r);
+    }
+
+    public void unregisterForVirtualSimOn(Handler h) {
+        mVirtualSimOn.remove(h);
+    }
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOff.add(r);
+    }
+
+    public void unregisterForVirtualSimOff(Handler h) {
+        mVirtualSimOff.remove(h);
+    }
+
+    public void registerForSimPlugOut(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugOutRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugOut(Handler h) {
+        mSimPlugOutRegistrants.remove(h);
+    }
+
+    public void registerForSimPlugIn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugInRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugIn(Handler h) {
+        mSimPlugInRegistrants.remove(h);
+    }
+
+    public void registerForTrayPlugIn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mTrayPlugInRegistrants.add(r);
+    }
+
+    public void unregisterForTrayPlugIn(Handler h) {
+        mTrayPlugInRegistrants.remove(h);
+    }
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    public void registerForCdmaCardType(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCdmaCardTypeRegistrants.add(r);
+
+        if (mCdmaCardTypeValue != null) {
+            r.notifyRegistrant(new AsyncResult(null, mCdmaCardTypeValue, null));
+        }
+    }
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      */
+    public void unregisterForCdmaCardType(Handler h) {
+        mCdmaCardTypeRegistrants.remove(h);
+    }
+
+    public void registerForCommonSlotNoChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCommonSlotNoChangedRegistrants.add(r);
+    }
+
+    public void unregisterForCommonSlotNoChanged(Handler h) {
+        mCommonSlotNoChangedRegistrants.remove(h);
+    }
+
+    public void registerForEusimReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEusimReady.add(r);
+    }
+
+    public void unregisterForEusimReady(Handler h) {
+        mEusimReady.remove(h);
+    }
+
+    /* M: CC33 LTE. */
+    public void setDataOnToMD(boolean enable, Message result){}
+    public void setRemoveRestrictEutranMode(boolean enable, Message result){}
+    public void registerForRemoveRestrictEutran(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mRemoveRestrictEutranRegistrants.add(r);
+    }
+    public void unregisterForRemoveRestrictEutran(Handler h) {
+        mRemoveRestrictEutranRegistrants.remove(h);
+    }
+    public void registerForRacUpdate(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mRacUpdateRegistrants.add(r);
+    }
+    public void unregisterForRacUpdate(Handler h) {
+        mRacUpdateRegistrants.remove(h);
+    }
+
+    public void registerForResetAttachApn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mResetAttachApnRegistrants.add(r);
+    }
+
+    public void unregisterForResetAttachApn(Handler h) {
+        mResetAttachApnRegistrants.remove(h);
+    }
+
+    public void registerSetDataAllowed(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataAllowedRegistrants.add(r);
+    }
+
+    public void unregisterSetDataAllowed(Handler h) {
+        mDataAllowedRegistrants.remove(h);
+    }
+
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response){
+    }
+
+    protected Registrant mEfCspPlmnModeBitRegistrant;
+
+    public void registerForEfCspPlmnModeBitChanged(Handler h, int what, Object obj) {
+        mEfCspPlmnModeBitRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unregisterForEfCspPlmnModeBitChanged(Handler h) {
+        mEfCspPlmnModeBitRegistrant.clear();
+    }
+
+    public void queryPhbStorageInfo(int type, Message response) {
+    }
+
+    public void writePhbEntry(PhbEntry entry, Message result) {
+    }
+
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response) {
+    }
+
+    public void registerForPhbReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPhbReadyRegistrants.add(r);
+    }
+
+    public void unregisterForPhbReady(Handler h) {
+        mPhbReadyRegistrants.remove(h);
+    }
+
+    public void queryUPBCapability(Message response){
+    }
+
+    public void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal, String tonForNum, Message response) {
+    }
+
+    public void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response) {
+    }
+
+    public void readUPBGasList(int startIndex, int endIndex, Message response) {
+    }
+
+    public void readUPBGrpEntry(int adnIndex, Message response) {
+    }
+
+    public void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response) {
+    }
+
+    public void getPhoneBookStringsLength(Message result) {
+
+    }
+    public void getPhoneBookMemStorage(Message result) {
+
+    }
+    public void setPhoneBookMemStorage(String storage, String password, Message result) {
+    }
+
+    // xen0n: MTK TODO
+    /*
+    public void readPhoneBookEntryExt(int index1, int index2, Message result) {
+    }
+
+    public void writePhoneBookEntryExt(PBEntry entry, Message result) {
+    }
+    */
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public void setLteAccessStratumReport(boolean enable, Message result) {
+    }
+
+    public void setLteUplinkDataTransfer(int state, int interfaceId, Message result) {
+    }
+
+    public void registerForLteAccessStratumState(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mLteAccessStratumStateRegistrants.add(r);
+    }
+
+    public void unregisterForLteAccessStratumState(Handler h) {
+        mLteAccessStratumStateRegistrants.remove(h);
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // Added by M end
+
+    // MTK-START, SMS part
+    public void registerForSmsReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSmsReadyRegistrants.add(r);
+
+        if (mIsSmsReady == true) {
+            // Only notify the new registrant
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForSmsReady(Handler h) {
+        mSmsReadyRegistrants.remove(h);
+    }
+
+    public void setOnMeSmsFull(Handler h, int what, Object obj) {
+        mMeSmsFullRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnMeSmsFull(Handler h) {
+        mMeSmsFullRegistrant.clear();
+    }
+
+    // xen0n: MTK TODO
+    /*
+    public void getSmsParameters(Message response) {
+    }
+
+    public void setSmsParameters(SmsParameters params, Message response) {
+    }
+    */
+
+    public void setEtws(int mode, Message result) {
+    }
+
+    public void setOnEtwsNotification(Handler h, int what, Object obj) {
+        mEtwsNotificationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnEtwsNotification(Handler h) {
+        mEtwsNotificationRegistrant.clear();
+    }
+
+    public void setCellBroadcastChannelConfigInfo(String config, int cb_set_type,
+            Message response) {
+    }
+
+    public void setCellBroadcastLanguageConfigInfo(String config, Message response) {
+    }
+
+    public void queryCellBroadcastConfigInfo(Message response) {
+    }
+
+    public void removeCellBroadcastMsg(int channelId, int serialId, Message response) {
+    }
+
+    public void getSmsSimMemoryStatus(Message result) {
+    }
+    // MTK-END, SMS part
+
+    public void registerForNeighboringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNeighboringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNeighboringInfo(Handler h) {
+        mNeighboringInfoRegistrants.remove(h);
+    }
+
+    public void registerForNetworkInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNetworkInfo(Handler h) {
+        mNetworkInfoRegistrants.remove(h);
+    }
+
+    public void setInvalidSimInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mInvalidSimInfoRegistrant.add(r);
+    }
+
+    public void unSetInvalidSimInfo(Handler h) {
+        mInvalidSimInfoRegistrant.remove(h);
+    }
+
+    public void registerForIMEILock(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImeiLockRegistrant.add(r);
+    }
+
+    public void unregisterForIMEILock(Handler h) {
+        mImeiLockRegistrant.remove(h);
+    }
+
+    public void setNetworkSelectionModeManualWithAct(String operatorNumeric,
+                                                                  String act, Message result) {
+    }
+
+    public void setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response) {
+
+    }
+
+    public void cancelAvailableNetworks(Message response) {}
+
+    public void registerForGetAvailableNetworksDone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mGetAvailableNetworkDoneRegistrant.add(r);
+    }
+
+    public void unregisterForGetAvailableNetworksDone(Handler h) {
+        mGetAvailableNetworkDoneRegistrant.remove(h);
+    }
+
+    public void getPOLCapabilty(Message response) {
+    }
+    public void getCurrentPOLList(Message response) {
+    }
+    public void setPOLEntry(int index, String numeric, int nAct, Message response) {
+    }
+
+    // Femtocell (CSG) feature START
+    public void getFemtoCellList(String operatorNumeric, int rat, Message response){}
+    public void abortFemtoCellList(Message response){}
+    public void selectFemtoCell(FemtoCellInfo femtocell, Message response){}
+    public void registerForFemtoCellInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mFemtoCellInfoRegistrants.add(r);
+    }
+
+    public void registerForPsNetworkStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mPsNetworkStateRegistrants.add(r);
+    }
+
+    public void unregisterForPsNetworkStateChanged(Handler h) {
+        mPsNetworkStateRegistrants.remove(h);
+    }
+
+    public boolean isGettingAvailableNetworks() { return false; }
+
+    public void unregisterForFemtoCellInfo(Handler h) {
+        mFemtoCellInfoRegistrants.remove(h);
+    }
+
+    // IMS
+    public void registerForImsEnable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnable(Handler h) {
+        mImsEnableRegistrants.remove(h);
+    }
+
+    public void registerForImsDisable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisable(Handler h) {
+        mImsDisableRegistrants.remove(h);
+    }
+
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsRegistrationInfoRegistrants.add(r);
+    }
+
+    public void unregisterForImsRegistrationInfo(Handler h) {
+        mImsRegistrationInfoRegistrants.remove(h);
+    }
+
+    public void setIMSEnabled(boolean enable, Message response){}
+    public void registerForImsDisableDone(Handler h, int what, Object obj){}
+    public void unregisterForImsDisableDone(Handler h){}
+
+    public void setTrm(int mode, Message result) {}
+
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+         synchronized (mWPMonitor) {
+            mPlmnChangeNotificationRegistrant.add(r);
+
+            if (mEcopsReturnValue != null) {
+               // Only notify the new registrant
+               r.notifyRegistrant(new AsyncResult(null, mEcopsReturnValue, null));
+               mEcopsReturnValue = null;
+            }
+        }
+    }
+
+    public void unSetOnPlmnChangeNotification(Handler h) {
+        synchronized (mWPMonitor) {
+            mPlmnChangeNotificationRegistrant.remove(h);
+        }
+    }
+
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+        synchronized (mWPMonitor) {
+            mRegistrationSuspendedRegistrant = new Registrant(h, what, obj);
+
+            if (mEmsrReturnValue != null) {
+                // Only notify the new registrant
+                mRegistrationSuspendedRegistrant.notifyRegistrant(
+                    new AsyncResult(null, mEmsrReturnValue, null));
+                mEmsrReturnValue = null;
+            }
+        }
+    }
+
+    public void unSetOnRegistrationSuspended(Handler h) {
+        synchronized (mWPMonitor) {
+            mRegistrationSuspendedRegistrant.clear();
+        }
+    }
+
+    //Remote SIM ME lock related APIs [Start]
+    public void registerForMelockChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mMelockRegistrants.add(r);
+    }
+
+    public void unregisterForMelockChanged(Handler h) {
+        mMelockRegistrants.remove(h);
+    }
+    //Remote SIM ME lock related APIs [End]
+
+    /** M: start */
+    public void setupDataCall(String radioTechnology, String profile,
+            String apn, String user, String password, String authType,
+            String protocol, Message result) {
+    }
+
+    public void setupDataCall(String radioTechnology, String profile,
+            String apn, String user, String password, String authType,
+            String protocol, String interfaceId, Message result) {
+    }
+
+    // M: fast dormancy
+    public void setScriResult(Handler h, int what, Object obj) {
+        mScriResultRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetScriResult(Handler h) {
+        mScriResultRegistrant.clear();
+    }
+
+    public void setScri(boolean forceRelease, Message response){
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response){
+    }
+
+
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result) {
+    }
+    /** M: end */
+
+    // For IMS VoLTE, EPS network feature support
+    public void registerForEpsNetworkFeatureSupport(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureSupportRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureSupport(Handler h) {
+        mEpsNetworkFeatureSupportRegistrants.remove(h);
+    }
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    public void registerForEconfSrvcc(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfSrvccRegistrants.add(r);
+    }
+
+    public void unregisterForEconfSrvcc(Handler h) {
+        mEconfSrvccRegistrants.remove(h);
+    }
+
+    /* Register for updating conference call merged/added result. */
+    public void registerForEconfResult(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfResultRegistrants.add(r);
+    }
+
+    public void unregisterForEconfResult(Handler h) {
+        mEconfResultRegistrants.remove(h);
+    }
+
+    public void registerForCallInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallInfo(Handler h) {
+        mCallInfoRegistrants.remove(h);
+    }
+
+
+    /* Add/Remove VoLTE(IMS) conference call member. */
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response) {}
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove, Message response) {}
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response) {}
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response) {}
+    /// @}
+
+    public void registerForEpsNetworkFeatureInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureInfo(Handler h) {
+        mEpsNetworkFeatureInfoRegistrants.remove(h);
+    }
+
+    public void registerForMoDataBarringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mMoDataBarringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForMoDataBarringInfo(Handler h) {
+        mMoDataBarringInfoRegistrants.remove(h);
+    }
+
+    public void registerForSsacBarringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSsacBarringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForSsacBarringInfo(Handler h) {
+        mSsacBarringInfoRegistrants.remove(h);
+    }
+
+    public void registerForSrvccHandoverInfoIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSrvccHandoverInfoIndicationRegistrants.add(r);
+    }
+    public void unregisterForSrvccHandoverInfoIndication(Handler h) {
+        mSrvccHandoverInfoIndicationRegistrants.remove(h);
+    }
+
+    /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+    public void registerForEmergencyBearerSupportInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEmergencyBearerSupportInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEmergencyBearerSupportInfo(Handler h) {
+        mEmergencyBearerSupportInfoRegistrants.remove(h);
+    }
+    /// @}
+
+    public void sendScreenState(boolean on){}
+
+    @Override
+    public void setDataCentric(boolean enable, Message response) {}
+
+    /// M: CC010: Add RIL interface @{
+    @Override
+    public void setImsCallStatus(boolean existed, Message response) {}
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList) {}
+
+    /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason) {}
+     /// @}
+
+    /* C2K part start */
+    @Override
+    public void setViaTRM(int mode, Message result) {}
+
+    @Override
+    public void getNitzTime(Message result) {}
+
+    @Override
+    public void requestSwitchHPF(boolean enableHPF, Message response) {}
+
+    @Override
+    public void setAvoidSYS(boolean avoidSYS, Message response) {}
+
+    @Override
+    public void getAvoidSYSList(Message response) {}
+
+    @Override
+    public void queryCDMANetworkInfo(Message response) {}
+
+    @Override
+    public void setOplmn(String oplmnInfo, Message response) {
+    }
+
+    @Override
+    public void getOplmnVersion(Message response) {
+    }
+
+    @Override
+    public void registerForCallAccepted(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mAcceptedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForCallAccepted(Handler h) {
+        mAcceptedRegistrant.remove(h);
+    }
+
+    @Override
+    public void registerForViaGpsEvent(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mViaGpsEvent.add(r);
+    }
+
+    @Override
+    public void unregisterForViaGpsEvent(Handler h) {
+        mViaGpsEvent.remove(h);
+    }
+
+    @Override
+    public void setMeid(String meid, Message response) {}
+
+    @Override
+    public void setArsiReportThreshold(int threshold, Message response) {}
+
+    @Override
+    public void registerForNetworkTypeChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkTypeChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForNetworkTypeChanged(Handler h) {
+        mNetworkTypeChangedRegistrant.remove(h);
+    }
+
+    @Override
+    public void queryCDMASmsAndPBStatus(Message response) {}
+
+    @Override
+    public void queryCDMANetWorkRegistrationState(Message response) {}
+
+    @Override
+    public void requestSetEtsDev(int dev, Message result) {}
+
+    @Override
+    public void requestAGPSGetMpcIpPort(Message result) {}
+
+    @Override
+    public void requestAGPSSetMpcIpPort(String ip, String port, Message result) {}
+
+    @Override
+    public void requestAGPSTcpConnected(int connected, Message result) {}
+
+    @Override
+    public void setMdnNumber(String mdn, Message response) {}
+
+    // UTK start
+    @Override
+    public void setOnUtkSessionEnd(Handler h, int what, Object obj) {
+        mUtkSessionEndRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkSessionEnd(Handler h) {
+        mUtkSessionEndRegistrant.clear();
+    }
+
+    @Override
+    public void setOnUtkProactiveCmd(Handler h, int what, Object obj) {
+        mUtkProCmdRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkProactiveCmd(Handler h) {
+        mUtkProCmdRegistrant.clear();
+    }
+
+    @Override
+    public void setOnUtkEvent(Handler h, int what, Object obj) {
+        mUtkEventRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkEvent(Handler h) {
+        mUtkEventRegistrant.clear();
+    }
+    //UTK end
+
+    //C2K SVLTE remote SIM access
+    @Override
+    public void configModemStatus(int modemStatus, int remoteSimProtocol, Message result) {}
+
+    @Override
+    public void disconnectRilSocket() {}
+
+    @Override
+    public void connectRilSocket() {}
+
+    @Override
+    public void configEvdoMode(int evdoMode, Message result) {}
+    /* C2k part end */
+
+    public void registerForAbnormalEvent(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mAbnormalEventRegistrant.add(r);
+    }
+
+    public void unregisterForAbnormalEvent(Handler h) {
+        mAbnormalEventRegistrant.remove(h);
+    }
+
+    /// M: [C2K] for eng mode start
+    @Override
+    public void registerForEngModeNetworkInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEngModeNetworkInfoRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForEngModeNetworkInfo(Handler h) {
+        mEngModeNetworkInfoRegistrant.remove(h);
+    }
+    /// M: [C2K] for eng mode end
+
+    public int getDisplayState() {
+        //return Display type: Unknown display type.
+        return 0;
+    }
+
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName) {
+        // return operator name from network: null string
+        return null;
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate this call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void conferenceDial(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {}
+    /* IMS VoLTE conference dial feature end*/
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    @Override
+    public void registerForGmssRatChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mGmssRatChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForGmssRatChanged(Handler h) {
+        mGmssRatChangedRegistrant.remove(h);
+    }
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed. @{
+    @Override
+    public void registerForDataNetworkTypeChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataNetworkTypeChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForDataNetworkTypeChanged(Handler h) {
+        mDataNetworkTypeChangedRegistrant.remove(h);
+    }
+    /// @}
+
+    /// [C2K][IRAT] @{
+    @Override
+    public void registerForIratStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mIratStateChangeRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForIratStateChanged(Handler h) {
+        mIratStateChangeRegistrant.remove(h);
+    }
+
+    @Override
+    public void confirmIratChange(int apDecision, Message result) {
+
+    }
+
+    @Override
+    public void requestSetPsActiveSlot(int psSlot, Message response) {
+    }
+
+    @Override
+    public void syncNotifyDataCallList(AsyncResult dcList) {
+
+    }
+
+    @Override
+    public void requestDeactivateLinkDownPdn(Message response) {
+
+    }
+    /// @}
+
+    @Override
+    public void registerForImsiRefreshDone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsiRefreshDoneRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForImsiRefreshDone(Handler h) {
+        mImsiRefreshDoneRegistrant.remove(h);
+    }
+
+    @Override
+    public RadioCapability getBootupRadioCapability() {
+        Rlog.d("RILJ", "getBootupRadioCapability: " + mRadioCapability);
+        return mRadioCapability;
+    }
+
+    @Override
+    public void registerForCdmaImsiReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCdmaImsiReadyRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForCdmaImsiReady(Handler h) {
+        mCdmaImsiReadyRegistrant.remove(h);
+    }
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    @Override
+    public void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response) {
+    }
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    public void setStkUtkMode(int stkUtkMode, Message response) {
+    }
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    @Override
+    public void setInstanceId(int instanceId) {
+    }
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    @Override
+    public void setRegistrationSuspendEnabled(int enabled, Message response) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response) {
+    }
+
+    @Override
+    public void setResumeCdmaRegistration(Message response) {
+    }
+
+    @Override
+    public void registerForMccMncChange(Handler h, int what, Object obj) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForMccMncChange h=" + h + " w=" + what);
+        Registrant r = new Registrant(h, what, obj);
+        mMccMncChangeRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForMccMncChange(Handler h) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "unregisterForMccMncChange");
+        mMccMncChangeRegistrants.remove(h);
+    }
+
+    @Override
+    public void queryStkSetUpMenuFromMD(String contents, Message response) {}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /// M: [C2K] Support Signal Fade. @{
+    @Override
+    public void setOnCdmaSignalFade(Handler h, int what, Object obj) {
+        mCdmaSignalFadeRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnCdmaSignalFade(Handler h) {
+        if (mCdmaSignalFadeRegistrant != null && mCdmaSignalFadeRegistrant.getHandler() == h) {
+            mCdmaSignalFadeRegistrant.clear();
+            mCdmaSignalFadeRegistrant = null;
+        }
+    }
+    /// @}
+
+    /// M: [C2K] Support Tone Signal. @{
+    @Override
+    public void setOnCdmaToneSignal(Handler h, int what, Object obj) {
+        mCdmaToneSignalsRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnCdmaToneSignal(Handler h) {
+        if (mCdmaToneSignalsRegistrant != null && mCdmaToneSignalsRegistrant.getHandler() == h) {
+            mCdmaToneSignalsRegistrant.clear();
+            mCdmaToneSignalsRegistrant = null;
+        }
+    }
+    /// @}
+
+    @Override
+    public void switchAntenna(int callState, int ratMode) {}
+    @Override
+    public void switchCardType(int cardtype) {}
+
+    @Override
+    public void enableMd3Sleep(int enable) {
+    }
+
+    @Override
+    public void registerForNetworkExsit(Handler h, int what, Object obj) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForNetworkExsit h=" + h + " w=" + what);
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkExistRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForNetworkExsit(Handler h) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForNetworkExsit");
+        mNetworkExistRegistrants.remove(h);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/CallForwardInfoEx.java b/src/java/com/android/internal/telephony/CallForwardInfoEx.java
new file mode 100644
index 0000000..b39f34f
--- /dev/null
+++ b/src/java/com/android/internal/telephony/CallForwardInfoEx.java
@@ -0,0 +1,65 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.internal.telephony;
+
+import android.telephony.PhoneNumberUtils;
+
+import java.util.Arrays;
+
+/**
+ * {@hide}
+ */
+public class CallForwardInfoEx {
+    public int             status;      /*1 = active, 0 = not active */
+    public int             reason;      /* from TS 27.007 7.11 "reason" */
+    public int             serviceClass; /* Sum of CommandsInterface.SERVICE_CLASS */
+    public int             toa;         /* "type" from TS 27.007 7.11 */
+    public String          number;      /* "number" from TS 27.007 7.11 */
+    public int             timeSeconds; /* for CF no reply only */
+    public long[]          timeSlot;    /* Time slot of CF */
+
+    @Override
+    public String toString() {
+        return super.toString() + (status == 0 ? " not active " : " active ")
+            + " reason: " + reason
+            + " serviceClass: " + serviceClass
+            + " \"" + PhoneNumberUtils.stringFromStringAndTOA(number, toa) + "\" "
+            + timeSeconds + " seconds"
+            + " timeSlot: " + Arrays.toString(timeSlot);
+    }
+}
diff --git a/src/java/com/android/internal/telephony/CommandException.java b/src/java/com/android/internal/telephony/CommandException.java
index f8f7c33..c4b8c0a 100644
--- a/src/java/com/android/internal/telephony/CommandException.java
+++ b/src/java/com/android/internal/telephony/CommandException.java
@@ -55,6 +55,31 @@ public class CommandException extends RuntimeException {
         SS_MODIFIED_TO_DIAL,
         SS_MODIFIED_TO_USSD,
         SS_MODIFIED_TO_SS,
+        // MTK
+        DIAL_STRING_TOO_LONG,
+        TEXT_STRING_TOO_LONG,
+        SIM_MEM_FULL,
+        /* M: SS part */
+        CALL_BARRED,
+        UT_XCAP_403_FORBIDDEN,
+        UT_UNKNOWN_HOST,
+        /* M: SS part end */
+
+        BT_SAP_UNDEFINED,
+        BT_SAP_NOT_ACCESSIBLE,
+        BT_SAP_CARD_REMOVED,
+
+        ADDITIONAL_NUMBER_STRING_TOO_LONG,
+        ADDITIONAL_NUMBER_SAVE_FAILURE,
+        ADN_LIST_NOT_EXIST,
+        EMAIL_SIZE_LIMIT,
+        EMAIL_NAME_TOOLONG,
+        NOT_READY,
+        /// M: SS Ut part
+        SPECAIL_UT_COMMAND_NOT_SUPPORTED,
+
+        /// M: ALPS02147333 call control part
+        CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED,
     }
 
     public CommandException(Error e) {
@@ -127,6 +152,32 @@ public class CommandException extends RuntimeException {
                 return new CommandException(Error.SS_MODIFIED_TO_USSD);
             case RILConstants.SS_MODIFIED_TO_SS:
                 return new CommandException(Error.SS_MODIFIED_TO_SS);
+            // MTK
+            case RILConstants.DIAL_STRING_TOO_LONG:
+                return new CommandException(Error.DIAL_STRING_TOO_LONG);
+            case RILConstants.TEXT_STRING_TOO_LONG:
+                return new CommandException(Error.TEXT_STRING_TOO_LONG);
+            case RILConstants.SIM_MEM_FULL:
+                return new CommandException(Error.SIM_MEM_FULL);
+            case RILConstants.ADDITIONAL_NUMBER_STRING_TOO_LONG:
+                return new CommandException(Error.ADDITIONAL_NUMBER_STRING_TOO_LONG);
+            case RILConstants.ADDITIONAL_NUMBER_SAVE_FAILURE:
+                return new CommandException(Error.ADDITIONAL_NUMBER_SAVE_FAILURE);
+            case RILConstants.ADN_LIST_NOT_EXIST:
+                return new CommandException(Error.ADN_LIST_NOT_EXIST);
+            case RILConstants.EMAIL_SIZE_LIMIT:
+                return new CommandException(Error.EMAIL_SIZE_LIMIT);
+            case RILConstants.EMAIL_NAME_TOOLONG:
+                return new CommandException(Error.EMAIL_NAME_TOOLONG);
+            case RILConstants.BT_SAP_UNDEFINED:
+                return new CommandException(Error.BT_SAP_UNDEFINED);
+            case RILConstants.BT_SAP_NOT_ACCESSIBLE:
+                return new CommandException(Error.BT_SAP_NOT_ACCESSIBLE);
+            case RILConstants.BT_SAP_CARD_REMOVED:
+                return new CommandException(Error.BT_SAP_CARD_REMOVED);
+            /// M: ALPS02147333 Hold call failed caused by call terminated
+            case RILConstants.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED:
+                return new CommandException(Error.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED);
             default:
                 Rlog.e("GSM", "Unrecognized RIL errno " + ril_errno);
                 return new CommandException(Error.INVALID_RESPONSE);
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 814121f..debbf94 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -22,6 +22,10 @@ import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
 import com.android.internal.telephony.RadioCapability;
 import com.android.internal.telephony.uicc.IccCardStatus;
 
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.SrvccCallContext;
+
+import android.os.AsyncResult;
 import android.os.Message;
 import android.os.Handler;
 
@@ -65,6 +69,9 @@ public interface CommandsInterface {
     static final int CF_REASON_NOT_REACHABLE    = 3;
     static final int CF_REASON_ALL              = 4;
     static final int CF_REASON_ALL_CONDITIONAL  = 5;
+    //MTK-START [MMTelSS]
+    static final int CF_REASON_NOT_REGISTERED   = 6;
+    //MTK-END [MMTelSS]
 
     // Used for call barring methods below
     static final String CB_FACILITY_BAOC         = "AO";
@@ -90,7 +97,17 @@ public interface CommandsInterface {
     static final int SERVICE_CLASS_DATA_ASYNC = (1 << 5);
     static final int SERVICE_CLASS_PACKET   = (1 << 6);
     static final int SERVICE_CLASS_PAD      = (1 << 7);
-    static final int SERVICE_CLASS_MAX      = (1 << 7); // Max SERVICE_CLASS value
+    // MTK
+    static final int SERVICE_CLASS_MAX      = (1 << 9); // Max SERVICE_CLASS value
+    /* M: SS part */
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    static final int SERVICE_CLASS_LINE2    = (1 << 8); // Add for Line2
+    /**
+     * SERVICE_CLASS_VIDEO Service Supplementary Information codes for Video Telephony support.
+     */
+    static final int SERVICE_CLASS_VIDEO    = (1 << 9);
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+    /* M: SS part end */
 
     // Numeric representation of string values returned
     // by messages sent to setOnUSSD handler
@@ -100,6 +117,14 @@ public interface CommandsInterface {
     static final int USSD_MODE_LOCAL_CLIENT  = 3;
     static final int USSD_MODE_NOT_SUPPORTED = 4;
     static final int USSD_MODE_NW_TIMEOUT    = 5;
+    /* M: SS part */
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    static final int USSD_SESSION_END               = 2;
+    static final int USSD_HANDLED_BY_STK            = 3;
+    static final int USSD_OPERATION_NOT_SUPPORTED   = 4;
+    static final int USSD_NETWORK_TIMEOUT           = 5;
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+    /* M: SS part end */
 
     // GSM SMS fail cause for acknowledgeLastIncomingSMS. From TS 23.040, 9.2.3.22.
     static final int GSM_SMS_FAIL_CAUSE_MEMORY_CAPACITY_EXCEEDED    = 0xD3;
@@ -113,6 +138,36 @@ public interface CommandsInterface {
     static final int CDMA_SMS_FAIL_CAUSE_OTHER_TERMINAL_PROBLEM     = 39;
     static final int CDMA_SMS_FAIL_CAUSE_ENCODING_PROBLEM           = 96;
 
+    // MTK
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    //MTK AT CMD +ESMLCK
+    static final int CAT_NETWOEK                = 0;
+    static final int CAT_NETOWRK_SUBSET         = 1;
+    static final int CAT_SERVICE_PROVIDER       = 2;
+    static final int CAT_CORPORATE              = 3;
+    static final int CAT_SIM                    = 4;
+
+    static final int OP_UNLOCK                  = 0;
+    static final int OP_LOCK                    = 1;
+    static final int OP_ADD                     = 2;
+    static final int OP_REMOVE                  = 3;
+    static final int OP_PERMANENT_UNLOCK        = 4;
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+
+    // UTK start
+    // Command Qualifier values for refresh command
+    static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
+    static final int REFRESH_NAA_FILE_CHANGE                = 0x01;
+    static final int REFRESH_NAA_INIT_AND_FILE_CHANGE       = 0x02;
+    static final int REFRESH_NAA_INIT                       = 0x03;
+    static final int REFRESH_UICC_RESET                     = 0x04;
+
+    // Qualifier values for UTK Refresh command
+    static final int UTK_REFRESH_SMS = 0;
+    static final int UTK_REFRESH_PHB = 1;
+    static final int UTK_REFRESH_SYS = 2;
+    //UTKE end
+
     //***** Methods
     RadioState getRadioState();
 
@@ -774,6 +829,8 @@ public interface CommandsInterface {
     void changeBarringPassword(String facility, String oldPwd, String newPwd, Message result);
 
     void supplyNetworkDepersonalization(String netpin, String type, Message result);
+    // MTK
+    void supplyNetworkDepersonalization(String netpin, Message result);
 
     /**
      *  returned message
@@ -2068,4 +2125,1457 @@ public interface CommandsInterface {
      * @hide
      */
     void unSetOnCatSendSmsResult(Handler h);
+
+    // MTK
+    // wow so content very media amuse
+
+    void registerForEusimReady(Handler h, int what, Object obj);
+    void unregisterForEusimReady(Handler h);
+
+    /**
+     * Sets the handler for event download of call notifications.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkEvdlCall(Handler h, int what, Object obj);
+    void unSetOnStkEvdlCall(Handler h);
+
+    /**
+     * Sets the handler for event download of call notifications.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkSetupMenuReset(Handler h, int what, Object obj);
+    void unSetOnStkSetupMenuReset(Handler h);
+
+    /**
+     * Sets the handler for call ccontrol response message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkCallCtrl(Handler h, int what, Object obj);
+    /**
+     * Unsets the handler for call ccontrol response message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     */
+    void unSetOnStkCallCtrl(Handler h);
+
+    /// M: BIP {
+    /**
+     * Sets the handler for Proactive Commands for CAT.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnBipProactiveCmd(Handler h, int what, Object obj);
+    void unSetOnBipProactiveCmd(Handler h);
+    /// M: BIP }
+
+    //MTK-START [mtk06800] modem power on/off
+    void setModemPower(boolean power, Message response);
+    //MTK-END [mtk06800] modem power on/off
+
+    void setNetworkSelectionModeManualWithAct(String operatorNumeric, String act, Message response);
+
+    void setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response);
+
+    /**
+     * Cancel querie the currently available networks
+     *
+     * ((AsyncResult)response.obj).result  is a List of NetworkInfo objects
+     */
+    void cancelAvailableNetworks(Message response);
+
+    /* M: SS part */
+    ///M: For query CNAP
+    void sendCNAPSS(String cnapssString, Message response);
+    /* M: SS part end */
+
+    /**
+     * Indicates to the vendor ril that call connected and disconnected
+     * event download will be handled by AP.
+     * @param enabled '0' handles event download by AP; '1' handles event download by MODEM
+     * @param response callback message
+     */
+    void setStkEvdlCallByAP(int enabled, Message response);
+
+    /**
+     * Query UTK menu from modem
+     *
+     *
+     * @param contents  String containing SAT/USAT response in hexadecimal
+     *                  format starting with command tag. See TS 102 223 for
+     *                  details.
+     * @param response  Callback message
+     */
+    public void queryUtkSetupMenuFromMD(String contents, Message response);
+
+    /**
+     * Query STK menu from modem.
+     *
+     *
+     * @param contents  String containing SAT/USAT response in hexadecimal
+     *                  format starting with command tag. See TS 102 223 for
+     *                  details.
+     * @param response  Callback message
+     */
+    public void queryStkSetUpMenuFromMD(String contents, Message response);
+
+    /**
+     * Accept or reject the call setup request from SIM.
+     *
+     * @param accept   true if the call is to be accepted, false otherwise.
+     * @param response Callback message
+     */
+    public void handleCallSetupRequestFromSim(boolean accept, int resCode, Message response);
+
+    /**
+     * Sets user selected subscription at Modem.
+     *
+     * @param slotId
+     *          Slot.
+     * @param appIndex
+     *          Application index in the card.
+     * @param subId
+     *          Indicates subscription 0 or subscription 1.
+     * @param subStatus
+     *          Activation status, 1 = activate and 0 = deactivate.
+     * @param result
+     *          Callback message contains the information of SUCCESS/FAILURE.
+     */
+    // FIXME Update the doc and consider modifying the request to make more generic.
+    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
+            Message result);
+
+    /// M: CC010: Add RIL interface @{
+    public void registerForCipherIndication(Handler h, int what, Object obj);
+    public void unregisterForCipherIndication(Handler h);
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj);
+    public void unregisterForCallForwardingInfo(Handler h);
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj);
+    public void unSetOnCallRelatedSuppSvc(Handler h);
+
+    /**
+     * used to register to +EAIC URC for call state change.
+     *
+     * msg.obj is an AsyncResult
+     * ar.result is a String[]
+     */
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj);
+    public void unsetOnIncomingCallIndication(Handler h);
+
+    //obsolete
+    /*
+    public void setCnapNotify(Handler h, int what, Object obj);
+    public void unSetCnapNotify(Handler h);
+    */
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    void setOnSpeechCodecInfo(Handler h, int what, Object obj);
+    void unSetOnSpeechCodecInfo(Handler h);
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void hangupAll(Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void forceReleaseCall(int index, Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void setCallIndication(int mode, int callId, int seqNumber, Message result);
+
+    /**
+     *  returned message
+     *  retMsg.obj = AsyncResult ar
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     *
+     * CLIR_DEFAULT     == on "use subscription default value"
+     * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
+     * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
+     */
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result);
+
+    public void setEccServiceCategory(int serviceCategory);
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response);
+    /// @}
+
+    /// M: For 3G VT only @{
+    /**
+     * used to register to +EVTSTATUS URC for VT status.
+     *
+     * msg.obj is an AsyncResult
+     * ar.result is a int[]
+     * String[0] is on_off
+     */
+    void registerForVtStatusInfo(Handler h, int what, Object obj);
+    void unregisterForVtStatusInfo(Handler h);
+
+    /**
+     * used to register to +CRING: VIDEO URC for MT VT call.
+     *
+     * msg.obj is an AsyncResult
+     */
+    void registerForVtRingInfo(Handler h, int what, Object obj);
+    void unregisterForVtRingInfo(Handler h);
+    /// @}
+
+    /// M: For 3G VT only @{
+    /**
+     *  returned message
+     *  retMsg.obj = AsyncResult ar
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     *
+     * CLIR_DEFAULT     == on "use subscription default value"
+     * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
+     * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
+     */
+    public void vtDial(String address, int clirMode, UUSInfo uusInfo, Message result);
+
+    /**
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void acceptVtCallWithVoiceOnly(int callId, Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void replaceVtCall(int index, Message result);
+    /// @}
+
+    /* M: SS part */
+    void changeBarringPassword(String facility, String oldPwd, String newPwd, String newCfm,
+         Message result);
+
+    /**
+     * response.obj will be a an int[2]
+     *
+     * response.obj[0] will be TS 27.007 +COLP parameter 'n'
+     *  0 COLP disabled
+     *  1 COLP enabled
+     *
+     * response.obj[1] will be TS 27.007 +COLP parameter 'm'
+     *  0 COLP not provisioned
+     *  1 COLP provisioned
+     *  2 unknown (e.g. no network, etc.)
+     */
+    void getCOLP(Message response);
+
+    /**
+     * enable is true for enable / false for disable COLP (ONLY affect TE not NW)
+     *
+     * response.obj is null
+     */
+    void setCOLP(boolean enable, Message response);
+
+    /**
+     * response.obj will be a an int[1]
+     *
+     * response.obj[0] will be proprietary +COLR parameter 'n'
+     *  0 COLR not provisioned
+     *  1 COLR provisioned
+     *  2 unknown (e.g. no network, etc.)
+     */
+    void getCOLR(Message response);
+
+    /**
+     * enable is true for enable / false for disable CLIP (ONLY affect TE not NW)
+     *
+     * response.obj is null
+     */
+    void setCLIP(boolean enable, Message response);
+    /* M: SS part end */
+
+    //MTK-START multiple application support
+    /**
+     * M: Open application in the UICC
+     *
+     * @param application: application ID
+     * @param response The message to send.
+     */
+    public void openIccApplication(int application, Message response);
+
+    /**
+     * Query application status
+     *
+     * @param sessionId: The channel ID
+     * @param response The message to send.
+     */
+    public void getIccApplicationStatus(int sessionId, Message result);
+
+
+    /**
+     * Register the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSessionChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSessionChanged(Handler h);
+    //MTK-END multiple application support
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  0 for Network personalisation category
+     *                  1 for Network subset personalisation category
+     *                  2 for Service provider personalisation category
+     *                  3 for Corporate(GID) personalisation category
+     *                  4 for SIM/USIM(IMSI) personalisation category
+     * @param response Callback message containing response structure.
+     */
+    void queryNetworkLock(int categrory, Message response);
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  "0" for Network personalisation category
+     *                  "1" for Network subset personalisation category
+     *                  "2" for Service provider personalisation category
+     *                  "3" for Corporate(GID) personalisation category
+     *                  "4" for SIM/USIM(IMSI) personalisation category
+     * @param lockop lock operation
+     *               "0" for unlock opreation
+     *               "1" for lock opreation
+     *               "2" for add lock opreation
+     *               "3" for remove lock opreation
+     *               "4" for disable lock category opreation
+     * @param password password of indicated network lock
+     * @param data_imsi IMSI value used to setup lock
+     * @param gid1 GID1 value used to setup lock
+     * @param gid2 GID2 value used to setup lock
+     * @param response Callback message containing response structure.
+     */
+    void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response);
+
+
+    /**
+     * Request security context authentication for SIM/USIM/ISIM
+     */
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                                    String param2, Message response);
+
+    // Added by M begin
+    void iccGetATR(Message result);
+    void iccOpenChannelWithSw(String AID, Message result);
+
+    void registerForSimMissing(Handler h, int what, Object obj);
+    void unregisterForSimMissing(Handler h);
+
+    void registerForSimRecovery(Handler h, int what, Object obj);
+    void unregisterForSimRecovery(Handler h);
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOn(Handler h);
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOff(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugOut(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugOut(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugIn(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugIn(Handler h);
+
+    /**
+     * Sets the handler for event notifications for Tray plug-in event in common slot project.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForTrayPlugIn(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for Tray plug-in event in common slot project.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForTrayPlugIn(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void registerForCommonSlotNoChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void unregisterForCommonSlotNoChanged(Handler h);
+
+    void registerSetDataAllowed(Handler h, int what, Object obj);
+    void unregisterSetDataAllowed(Handler h);
+
+
+    /**
+     * Send BT SIM profile
+     * @param nAction
+     *          the type of the action
+     *          0: Connect
+     *          1: Disconnect
+     *          2: Power On
+     *          3: Power Off
+     *          4: Reset
+     *          5: APDU
+     * @param nType
+     *          Indicate which transport protocol is the preferred one
+     *          0x00 : T=0
+     *          0x01 : T=1
+     * @param strData
+     *          Only be used when action is APDU transfer
+     * @param response
+     *          Callback message containing response structure.
+     */
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response);
+
+    void registerForEfCspPlmnModeBitChanged(Handler h, int what, Object obj);
+    void unregisterForEfCspPlmnModeBitChanged(Handler h);
+
+    /**
+     * Request the information of the given storage type
+     *
+     * @param type
+     *          the type of the storage, refer to PHB_XDN defined in the RilConstants
+     * @param response
+     *          Callback message
+     *          response.obj.result is an int[4]
+     *          response.obj.result[0] is number of current used entries
+     *          response.obj.result[1] is number of total entries in the storage
+     *          response.obj.result[2] is maximum supported length of the number
+     *          response.obj.result[3] is maximum supported length of the alphaId
+     */
+    public void queryPhbStorageInfo(int type, Message response);
+
+    /**
+     * Request update a PHB entry using the given {@link PhbEntry}
+     *
+     * @param entry a PHB entry strucutre {@link PhbEntry}
+     *          when one of the following occurs, it means delete the entry.
+     *          1. entry.number is NULL
+     *          2. entry.number is empty and entry.ton = 0x91
+     *          3. entry.alphaId is NULL
+     *          4. both entry.number and entry.alphaId are empty.
+     * @param result
+     *          Callback message containing if the action is success or not.
+     */
+    public void writePhbEntry(PhbEntry entry, Message result);
+
+    /**
+     * Request read PHB entries from the given storage
+     * @param type
+     *          the type of the storage, refer to PHB_* defined in the RilConstants
+     * @param bIndex
+     *          the begin index of the entries to be read
+     * @param eIndex
+     *          the end index of the entries to be read, note that the (eIndex - bIndex +1)
+     *          should not exceed the value RilConstants.PHB_MAX_ENTRY
+     *
+     * @param response
+     *          Callback message containing an array of {@link PhbEntry} structure.
+     */
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response);
+
+    /**
+     * Sets the handler for PHB ready notification
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForPhbReady(Handler h, int what, Object obj);
+    void unregisterForPhbReady(Handler h);
+
+    void queryUPBCapability(Message response);
+    void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal,
+         String tonForNum, Message response);
+    void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response);
+    void readUPBGasList(int startIndex, int endIndex, Message response);
+    void readUPBGrpEntry(int adnIndex, Message response);
+    void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response);
+
+    void getPhoneBookStringsLength(Message result);
+    void getPhoneBookMemStorage(Message result);
+    void setPhoneBookMemStorage(String storage, String password, Message result);
+    // xen0n: MTK TODO
+    // void readPhoneBookEntryExt(int index1, int index2, Message result);
+    // void writePhoneBookEntryExt(PBEntry entry, Message result);
+
+    // Added by M end
+
+    // xen0n: MTK TODO
+    // MTK-START, SMS part
+    /*
+     * Get sms parameters from EFsmsp
+     */
+    // void getSmsParameters(Message response);
+
+    /*
+     * Set sms parameters into EFsmsp
+     */
+    // void setSmsParameters(SmsParameters params, Message response);
+
+    /**
+     * Get SMS SIM Card memory's total and used number
+     *
+     * @param result callback message
+     */
+    void getSmsSimMemoryStatus(Message result);
+
+    void setEtws(int mode, Message result);
+    void setOnEtwsNotification(Handler h, int what, Object obj);
+    void unSetOnEtwsNotification(Handler h);
+
+    /**
+     * Sets the handler for ME SMS storage full unsolicited message.
+     * Unlike the register methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnMeSmsFull(Handler h, int what, Object obj);
+    void unSetOnMeSmsFull(Handler h);
+
+    /**
+     * Register the handler for SMS ready notification.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSmsReady(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for SMS ready notification.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSmsReady(Handler h);
+
+    void setCellBroadcastChannelConfigInfo(String config, int cb_set_type, Message response);
+    void setCellBroadcastLanguageConfigInfo(String config, Message response);
+    void queryCellBroadcastConfigInfo(Message response);
+    void removeCellBroadcastMsg(int channelId, int serialId, Message response);
+    // MTK-END, SMS part
+
+    void getPOLCapabilty(Message response);
+    void getCurrentPOLList(Message response);
+    void setPOLEntry(int index, String numeric, int nAct, Message response);
+
+    void registerForPsNetworkStateChanged(Handler h, int what, Object obj);
+    void unregisterForPsNetworkStateChanged(Handler h);
+
+    void registerForIMEILock(Handler h, int what, Object obj);
+    void unregisterForIMEILock(Handler h);
+
+   /**
+     * Sets the handler for Invalid SIM unsolicited message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setInvalidSimInfo(Handler h, int what, Object obj);
+    void unSetInvalidSimInfo(Handler h);
+
+    // get Available network informaitons API
+    void registerForGetAvailableNetworksDone(Handler h, int what, Object obj);
+    void unregisterForGetAvailableNetworksDone(Handler h);
+    boolean isGettingAvailableNetworks();
+
+  // Femtocell (CSG) feature START
+  /**
+     * Queries the currently available femtocells
+     *
+     * ((AsyncResult)response.obj).result  is a List of FemtoCellInfo objects
+     */
+    void getFemtoCellList(String operatorNumeric, int rat, Message response);
+
+  /**
+     * Abort quering available femtocells
+     *
+     * ((AsyncResult)response.obj).result  is a List of FemtoCellInfo objects
+     */
+    void abortFemtoCellList(Message response);
+
+  /**
+     * select femtocell
+     *
+     * @param femtocell info
+     */
+    void selectFemtoCell(FemtoCellInfo femtocell, Message response);
+
+    public void registerForFemtoCellInfo(Handler h, int what, Object obj);
+    public void unregisterForFemtoCellInfo(Handler h);
+    // Femtocell (CSG) feature END
+
+    /**
+     * unlike the register* methods, there's only one Neighboring cell info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the RAT
+     * ((Object[])AsyncResult.result)[1] is a String containing the neighboring cell info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNeighboringInfo(Handler h, int what, Object obj);
+    void unregisterForNeighboringInfo(Handler h);
+
+    /**
+     * unlike the register* methods, there's only one Network info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the type
+     * ((Object[])AsyncResult.result)[1] is a String contain the network info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNetworkInfo(Handler h, int what, Object obj);
+    void unregisterForNetworkInfo(Handler h);
+
+    // IMS
+    public void registerForImsEnable(Handler h, int what, Object obj);
+    public void unregisterForImsEnable(Handler h);
+    public void registerForImsDisable(Handler h, int what, Object obj);
+    public void unregisterForImsDisable(Handler h);
+    public void setIMSEnabled(boolean enable, Message response);
+    public void registerForImsDisableDone(Handler h, int what, Object obj);
+    public void unregisterForImsDisableDone(Handler h);
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj);
+    public void unregisterForImsRegistrationInfo(Handler h);
+
+    void setTrm(int mode, Message result);
+
+    void setOnPlmnChangeNotification(Handler h, int what, Object obj);
+    void unSetOnPlmnChangeNotification(Handler h);
+    void setOnRegistrationSuspended(Handler h, int what, Object obj);
+    void unSetOnRegistrationSuspended(Handler h);
+    void storeModemType(int modemType, Message response);
+    void reloadModemType(int modemType, Message response);
+    void queryModemType(Message response);
+
+    //Remote SIM ME lock related APIs [Start]
+    void registerForMelockChanged(Handler h, int what, Object obj);
+    void unregisterForMelockChanged(Handler h);
+    //Remote SIM ME lock related APIs [End]
+
+    /** M: start */
+    void setupDataCall(String radioTechnology, String profile, String apn, String user,
+            String password, String authType, String protocol, String interfaceId, Message result);
+
+     /**
+     * @param apn for apn name
+     * @param protocol for IP type
+     * @param authType for Auth type
+     * @param username for username
+     * @param password for password
+     * @param obj for ia extend parameter
+     * @param result for result
+     */
+    void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result);
+
+    // Fast Dormancy
+    void setScri(boolean forceRelease, Message response);
+    void setFDMode(int mode, int parameter1, int parameter2, Message response);
+    public void setScriResult(Handler h, int what, Object obj);
+    public void unSetScriResult(Handler h);
+    /** M: end */
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    public void registerForEconfSrvcc(Handler h, int what, Object obj);
+    public void unregisterForEconfSrvcc(Handler h);
+
+    /* Register for updating conference call merged/added result. */
+    public void registerForEconfResult(Handler h, int what, Object obj);
+    public void unregisterForEconfResult(Handler h);
+
+    /* Register for updating call mode and pau */
+    public void registerForCallInfo(Handler h, int what, Object obj);
+    public void unregisterForCallInfo(Handler h);
+
+    /* Add/Remove VoLTE(IMS) conference call member. */
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response);
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove,
+           Message response);
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response);
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response);
+
+    /**
+     * M: notify screen state to RILD
+     *
+     * @param on The screen state
+     */
+    public void sendScreenState(boolean on);
+
+    /// @}
+
+    /**
+     * M: CC33 LTE.
+     */
+    public void registerForRacUpdate(Handler h, int what, Object obj);
+    public void unregisterForRacUpdate(Handler h);
+    public void setDataOnToMD(boolean enable, Message result);
+    public void setRemoveRestrictEutranMode(boolean enable, Message result);
+    public void registerForRemoveRestrictEutran(Handler h, int what, Object obj);
+    public void unregisterForRemoveRestrictEutran(Handler h);
+
+    /**
+     * M: Reset Attach Apn
+     */
+    public void registerForResetAttachApn(Handler h, int what, Object obj);
+    public void unregisterForResetAttachApn(Handler h);
+
+   /**
+    * M: [LTE][Low Power][UL traffic shaping]
+    */
+    public void setLteAccessStratumReport(boolean enable, Message result);
+    public void setLteUplinkDataTransfer(int state, int interfaceId, Message result);
+    public void registerForLteAccessStratumState(Handler h, int what, Object obj);
+    public void unregisterForLteAccessStratumState(Handler h);
+
+    /**
+     * IMS.
+     * @param enable if true.
+     * @param response User-defined message code.
+     */
+
+    public void setDataCentric(boolean enable, Message response);
+
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     * Notify modem about IMS call status.
+     * @param existed True if there is at least one IMS call existed, else return false.
+     * @param response User-defined message code.
+     */
+    public void setImsCallStatus(boolean existed, Message response);
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to CS modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList);
+
+    /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason);
+     /// @}
+
+    /* C2K part start */
+    /**
+     * Request to recovery telephony.
+     *
+     * @param mode The recovery mode
+     * @param result callback message
+     */
+    void setViaTRM(int mode, Message result);
+
+    /**
+     * Request to get NITZ time.
+     *
+     * @param result callback message
+     */
+    void getNitzTime(Message result);
+
+    /**
+     * Request to switch HPF.
+     * @param enableHPF true if
+     * @param response callback message
+     */
+    void requestSwitchHPF(boolean enableHPF, Message response);
+
+    /**
+     * Request to set avoid SYS.
+     * @param avoidSYS true if
+     * @param response callback message
+     */
+    void setAvoidSYS(boolean avoidSYS, Message response);
+
+    /**
+     * Request to get avoid SYS List.
+     * @param response callback message
+     */
+    void getAvoidSYSList(Message response);
+
+    /**
+     * M: oplmn is the oplmn list download from the specific url.
+     * @param oplmnInfo The info send to the modem
+     * @param response The message to send.
+     */
+    void setOplmn(String oplmnInfo, Message response);
+
+    /**
+     * M: Get the oplmn updated version.
+     * @param response the responding message.
+     */
+    void getOplmnVersion(Message response);
+
+    /**
+     * query CDMA Network Info.
+     * @param response callback message
+     */
+    void queryCDMANetworkInfo(Message response);
+
+    /**
+     * Register the handler for call accepted.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForCallAccepted(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for call accepted.
+     * @param h Handler for notification message.
+     */
+    void unregisterForCallAccepted(Handler h);
+
+    /**
+     * Sets the handler for meid.
+     * @param meid meid string.
+     * @param response callback message.
+     */
+    void setMeid(String meid, Message response);
+
+    /**
+     * Register for via gps event.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForViaGpsEvent(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for via gps event.
+     * @param h Handler for notification message.
+     */
+    void unregisterForViaGpsEvent(Handler h);
+
+    /**
+     * Request to AGPScp connected.
+     * @param connected connected number
+     * @param result callback message
+     */
+    void requestAGPSTcpConnected(int connected, Message result);
+
+    /**
+     * request AGPS set mpc ip & port address.
+     *
+     * @param ip ip address
+     * @param port port to use
+     * @param result callback message
+     */
+    void requestAGPSSetMpcIpPort(String ip, String port, Message result);
+
+    /**
+     * request AGPS get mpc ip & port address.
+     *
+     * @param result callback message
+     */
+    void requestAGPSGetMpcIpPort(Message result);
+
+    /**
+     * request set ets device.
+     *
+     * @param dev 0-uart,1-usb,2-sdio
+     * @param result callback message
+     */
+     void requestSetEtsDev(int dev, Message result);
+
+     /**
+      * For China Telecom auto-register sms.
+      *
+      * @param response The request's response
+      */
+     void queryCDMASmsAndPBStatus(Message response);
+
+     /**
+      * For China Telecom auto-register sms.
+      *
+      * @param response The request's response
+      */
+     void queryCDMANetWorkRegistrationState(Message response);
+
+     /**
+      * Register for network change callback.
+      *
+      * @param h Handler for notification message.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+     void registerForNetworkTypeChanged(Handler h, int what, Object obj);
+
+     /**
+      * Unregister for network change callback.
+      *
+      * @param h Handler for notification message.
+      */
+     void unregisterForNetworkTypeChanged(Handler h);
+
+     /**
+      * Set ARSI report threshold.
+      *
+      * @param threshold The threshold to set
+      * @param response The request's response
+      */
+     void setArsiReportThreshold(int threshold, Message response);
+
+     /**
+      * Set MDN number.
+      * @param mdn The mdn numer to set
+      * @param response The request's response
+      */
+     void setMdnNumber(String mdn, Message response);
+
+    // UTK start
+    /**
+     * set on utk session end.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkSessionEnd(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk session end.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkSessionEnd(Handler h);
+
+    /**
+     * set on utk proactive cmd.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkProactiveCmd(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk proactive cmd.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkProactiveCmd(Handler h);
+
+    /**
+     * set on utk event.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkEvent(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk event.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkEvent(Handler h);
+
+    /**
+     * handle call setup request from uim.
+     * @param accept true if.
+     * @param response callback message.
+     */
+    public void handleCallSetupRequestFromUim(boolean accept, Message response);
+
+    /**
+     * report utk service is running.
+     * @param result callback message.
+     */
+    void reportUtkServiceIsRunning(Message result);
+    /**
+     * Query Local Info.
+     *
+     * @param result callback message
+     */
+    void getUtkLocalInfo(Message result);
+
+    /**
+     * Send a UTK refresh command.
+     *
+     * @param refreshType refresh type
+     * @param result callback message
+     */
+    void requestUtkRefresh(int refreshType, Message result);
+
+    /**
+     * When Vendor UtkService is running, download profile to tell Ruim what capability phone has.
+     *
+     * @param response callback message
+     *
+     * @param profile  profile downloaded into Ruim
+     */
+    void profileDownload(String profile, Message response);
+    //UTK end
+
+    /**
+     * C2K SVLTE remote SIM access.
+     * @param modemStatus The Modem status: 0: Only MD1 active
+     *                                      1: MD1's RF is closed, but MD1's SIM task is still
+     *                                         working onlyfor MD3 SIM remove access and MD3 active
+     *                                      2: Both MD1 and MD3 active
+     * @param remoteSimProtocol MD3 decide to access SIM from which protocl of MD1
+     *                          0: MD3 access local card
+     *                          1: MD1 access MD1's SIM task1
+     *                          2: MD1 access MD1's SIM task2
+     * @param result callback message
+     */
+    void configModemStatus(int modemStatus, int remoteSimProtocol, Message result);
+
+    /**
+     * Disconnect RIL socket. For SVLTE C2K only mode to disable LTE functions.
+     */
+    void disconnectRilSocket();
+
+    /**
+     * Reconnect RIL socket.
+     */
+    void connectRilSocket();
+
+    /* C2k part end */
+    /**
+     * C2K SVLTE CDMA eHPRD control.
+     * Used to turn on/off eHPRD.
+     * @param evdoMode The mode set to MD3: 0: turn off eHPRD.
+     *                                      1: turn on eHPRD.
+     * @param result callback message
+     */
+    void configEvdoMode(int evdoMode, Message result);
+    /* C2k part end */
+
+    void setBandMode(int[] bandMode, Message response);
+
+    public void registerForAbnormalEvent(Handler h, int what, Object obj);
+
+    public void unregisterForAbnormalEvent(Handler h);
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    void registerForCdmaCardType(Handler h, int what, Object obj);
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      */
+    void unregisterForCdmaCardType(Handler h);
+
+    /// M: [C2K] for eng mode start
+    /**
+     * M: Rregister on network information for eng mode.
+     * @param h Handler for network information messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForEngModeNetworkInfo(Handler h, int what, Object obj);
+
+    /**
+     * M: Unrregister on network information for eng mode.
+     * @param h Handler for network information messages.
+     */
+    void unregisterForEngModeNetworkInfo(Handler h);
+    /// M: [C2K] for eng mode end
+
+    /**
+     * M: return display state to RILD
+     *
+     */
+    public int getDisplayState();
+
+    /**
+     *  Query operator name from network
+     * @param subId
+     *          Indicates subscription 0 or subscription 1.
+     * @param numeric for operator numeric
+     * @param desireLongName
+     *          Indicates longname or shortname
+     */
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName);
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    void conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result);
+    /* IMS VoLTE conference dial feature end*/
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    /**
+     * Register for GMSS RAT.
+     * When boot the phone,AP can use this informaiton decide PS' type(LTE or C2K).
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForGmssRatChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister GMSS RAT get GMSS RAT.
+     * When boot the phone,AP can use this informaiton decide PS' type(LTE or C2K).
+     * @param h Handler for notification message.
+     */
+    void unregisterForGmssRatChanged(Handler h);
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed. @{
+    /**
+     * Register for ps type changed.
+     * @param h Handler for ps type change messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForDataNetworkTypeChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for ps type changed.
+     * @param h Handler for ps type change messages.
+     */
+    void unregisterForDataNetworkTypeChanged(Handler h);
+    /// @}
+
+    /// [C2K][IRAT] start @{
+    /**
+     * M: Fires on any change in inter-3GPP IRAT status change.
+     * @param h Handler for IRAT status change messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForIratStateChanged(Handler h, int what, Object obj);
+
+    /**
+     * M: Unregister for inter-3GPP IRAT status change event.
+     * @param h Handler for IRAT status change messages
+     */
+    void unregisterForIratStateChanged(Handler h);
+
+    /**
+     * M: Confirm inter-3GPP IRAT change, MD will perform IRAT process after
+     * receive this command, AP need to make sure to suspend all PS requests
+     * before call this function.
+     * @param apDecision The decision of AP, need to be 1(accept) currently.
+     * @param response A callback message with the String response in the obj field
+     */
+    void confirmIratChange(int apDecision, Message response);
+
+    /**
+     * M: Set PS active slot for Gemini LTE dual connection project, send
+     * AT+EACTS=slotId to MD, the request can only send by main protocol.
+     * @param psSlot Slot to be used for data connection.
+     * @param response A callback message with the String response in the obj field
+     */
+    void requestSetPsActiveSlot(int psSlot, Message response);
+
+    /**
+     * Sync notify data call list after IRAT finished.
+     * @param dcList Data call list.
+     */
+    void syncNotifyDataCallList(AsyncResult dcList);
+    /// }@
+
+    /**
+     * Request to deactivate link down PDN to release IP address.
+     * @param response callback message.
+     */
+    void requestDeactivateLinkDownPdn(Message response);
+
+    /**
+     * Register for CDMA imsi ready.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    public void registerForCdmaImsiReady(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for CDMA imsi ready.
+     * @param h Handler for notification message.
+     */
+    public void unregisterForCdmaImsiReady(Handler h);
+
+    /**
+      * Register for imsi refresh done.
+      * @param h Handler for notification message.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    public void registerForImsiRefreshDone(Handler h, int what, Object obj);
+    /**
+      * Unregister for imsi refresh done.
+      * @param h Handler for notification message.
+      */
+    public void unregisterForImsiRefreshDone(Handler h) ;
+
+    /**
+      * To get RadioCapability stored in RILJ when phone object is not created
+      */
+    public RadioCapability getBootupRadioCapability();
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    /**
+     * M: Request to set the SVLTE Mode (SVLTE_4G or SVLTE_3G or LTE_TDD_DATA_ONLY).
+     *
+     * @param radioTechMode The radio teck mode.
+     * @param preSvlteMode The previous rat mode.
+     * @param svlteMode The rat mode.
+     * @param preRoamingMode The previous roaming mode.
+     * @param roamingMode The roaming mode.
+     * @param is3GDualModeCard Whether the SIM card is 3g dual mode card or not.
+     * @param response A callback message with the String response in the obj field.
+     */
+    void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response);
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    /**
+     * M: Request to set the STK/UTK Mode
+     *
+     * @param stkUtkMode the target STK/UTK mode
+     * @param response A callback message with the String response in the obj field.
+     */
+    void setStkUtkMode(int stkUtkMode, Message response);
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    /**
+     * M: For SVLTE to update RIL instance id.
+     * @param instanceId The new instance Id.
+     */
+    void setInstanceId(int instanceId);
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    /**
+     * Set GSM modem to suspend network registration.
+     * @param enabled True to pause and false to resume.
+     * @param response the responding message.
+     */
+    void setRegistrationSuspendEnabled(int enabled, Message response);
+
+    /**
+     * Request GSM modem to resume network registration.
+     * @param sessionId the session index.
+     * @param response the responding message.
+     */
+    void setResumeRegistration(int sessionId, Message response);
+
+    /**
+     * Set GSM modem to suspend network registration.
+     * @param enabled True to pause and false to resume.
+     * @param response the responding message.
+     */
+    void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response);
+
+    /**
+     * Request C2K modem to resume network registration.
+     * @param response the responding message.
+     */
+    void setResumeCdmaRegistration(Message response);
+
+    /**
+     * Register for mcc and mnc change.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForMccMncChange(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for mcc and mnc change.
+     * @param h Handler for notification message.
+     */
+    void unregisterForMccMncChange(Handler h);
+
+    /**
+     * Set the xTK mode.
+     * @param mode The xTK mode.
+     */
+    void setStkSwitchMode(int mode);
+
+    /**
+     * Set the UTK Bip Ps type .
+     * @param mBipPsType The Bip type.
+     */
+    void setBipPsType(int type);
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /**
+     * Register for Signal Fade notification.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnCdmaSignalFade(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for Signal Fade notification.
+     * @param h Handler for notification message.
+     */
+    void unSetOnCdmaSignalFade(Handler h);
+
+    /**
+     * Register for Tone Signal message.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnCdmaToneSignal(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for Tone Signal message.
+     * @param h Handler for notification message.
+     */
+    void unSetOnCdmaToneSignal(Handler h);
+
+    /**
+     * Switch antenna.
+     * @param callState call state, 0 means call disconnected and 1 means call established.
+     * @param ratMode RAT mode, 0 means GSM and 7 means C2K.
+     */
+    void switchAntenna(int callState, int ratMode);
+
+    /**
+     * Switch RUIM card to SIM or switch SIM to RUIM.
+     * @param cardtype that to be switched.
+     */
+    void switchCardType(int cardtype);
+
+    /**
+     * Enable or disable MD3 Sleep.
+     * @param enable MD3 sleep.
+     */
+    void enableMd3Sleep(int enable);
+
+    /**
+     * Register for network exsit or not for ECC only.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForNetworkExsit(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for network exsit.
+     * @param h Handler for notification message.
+     */
+    void unregisterForNetworkExsit(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/DriverCall.java b/src/java/com/android/internal/telephony/DriverCall.java
index a923d8f..671346b 100644
--- a/src/java/com/android/internal/telephony/DriverCall.java
+++ b/src/java/com/android/internal/telephony/DriverCall.java
@@ -51,6 +51,15 @@ public class DriverCall implements Comparable<DriverCall> {
     public int namePresentation;
     public UUSInfo uusInfo;
 
+    /// M: Add for IMS conference call. @{
+    public int     callMode;
+    public String  pau;
+    /// @}
+
+    /// M: For 3G VT only @{
+    public boolean isVideo;
+    /// @}
+
     /** returns null on error */
     static DriverCall
     fromCLCCLine(String line) {
@@ -66,6 +75,10 @@ public class DriverCall implements Comparable<DriverCall> {
             ret.state = stateFromCLCC(p.nextInt());
 
             ret.isVoice = (0 == p.nextInt());
+            /// M: For 3G VT only @{
+            // callmode: 0(voice), 10(video)
+            ret.isVideo = (10 == p.nextInt());
+            /// @}
             ret.isMpty = p.nextBoolean();
 
             // use ALLOWED as default presentation while parsing CLCC
@@ -111,9 +124,13 @@ public class DriverCall implements Comparable<DriverCall> {
                 + (isMT ? "mt" : "mo") + ","
                 + als + ","
                 + (isVoice ? "voc" : "nonvoc") + ","
+                /// M: For 3G VT only @{
+                + (isVideo ? "vid" : "nonvid") + ","
+                /// @}
                 + (isVoicePrivacy ? "evp" : "noevp") + ","
                 /*+ "number=" + number */ + ",cli=" + numberPresentation + ","
-                /*+ "name="+ name */ + "," + namePresentation;
+                /*+ "name="+ name */ + "," + namePresentation + ","
+                + callMode;
     }
 
     public static State
diff --git a/src/java/com/android/internal/telephony/IccCard.java b/src/java/com/android/internal/telephony/IccCard.java
index a2f7ca3..492ddb7 100644
--- a/src/java/com/android/internal/telephony/IccCard.java
+++ b/src/java/com/android/internal/telephony/IccCard.java
@@ -21,6 +21,7 @@ import android.os.Message;
 
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccRecords;
 
@@ -231,4 +232,102 @@ public interface IccCard {
      * @return true if ICC card is PUK2 blocked
      */
     public boolean getIccPuk2Blocked();
+
+    // MTK
+
+    /**
+     * Supply Network depersonalization code to the RIL
+     */
+    public void supplyNetworkDepersonalization (String pin, Message onComplete);
+
+    /**
+     * Use to query the network lock type.
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public PersoSubState getNetworkPersoType();
+
+    /**
+     * Use to query indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void queryIccNetworkLock(int category, Message onComplete);
+
+    /**
+     * Use to set indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param lockop 0: Unlock, 1: Lock, 2:Add, 3:Remove, 4:Permanently unlock
+     * @param password password of indicated category lock
+     * @param data_imsi IMSI
+     * @param gid1 GID1 value
+     * @param gid2 GID2 value
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete);
+
+    /**
+     * Use to repolling icc card status (Used by SIM ME lock related enhancement feature)
+     *
+     * @param needIntent indicated need an Intent to notify needed to unlock another SIM or not.
+     *                   if yes, will broadcast TelephonyIntents.ACTION_UNLOCK_SIM_LOCK to notify.
+     *                   if no, will notify by original TelephonyIntents.ACTION_SIM_STATE_CHANGED.
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent);
+
+    /**
+     * NFC API, use to exchange SIM IO.
+     *
+     * @internal
+     */
+    public void exchangeSimIo(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete);
+
+    /**
+     * NFC API, use to get ATR.
+     *
+     * @internal
+     */
+    public void iccGetAtr(Message onComplete);
+
+    public String getIccCardType();
+    // MTK-START
+    /**
+     * Request to get UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType();
+    // MTK-END
+     /**
+     * NFC API, use to open logical channel with sw.
+     *
+     * @internal
+     */
+    public void openLogicalChannelWithSw(String AID, Message onComplete);
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    public void registerForFdnChanged(Handler h, int what, Object obj);
+    public void unregisterForFdnChanged(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/MediaTekRIL.java b/src/java/com/android/internal/telephony/MediaTekRIL.java
new file mode 100644
index 0000000..6c70bd3
--- /dev/null
+++ b/src/java/com/android/internal/telephony/MediaTekRIL.java
@@ -0,0 +1,5328 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project <http://www.omnirom.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_EDGE;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_GPRS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.telephony.ModemActivityInfo;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.RadioAccessFamily;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.view.Display;
+
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Vector;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccRefreshResponse;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.SpnOverride;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.IccSmsStorageStatus;
+import com.mediatek.internal.telephony.NetworkInfoWithAcT;
+import com.mediatek.internal.telephony.SrvccCallContext;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
+
+public class MediaTekRIL extends RIL implements CommandsInterface {
+
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET = "gsm.ril.cardtypeset";
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET_2 = "gsm.ril.cardtypeset.2";
+    private static final String  PROPERTY_NET_CDMA_MDMSTAT = "net.cdma.mdmstat";
+    private static final int INITIAL_RETRY_INTERVAL_MSEC = 200;
+    private static final String  PROPERTY_CONFIG_EMDSTATUS_SEND = "ril.cdma.emdstatus.send";
+
+    /* ALPS00799783: for restore previous preferred network type when set type fail */
+    private int mPreviousPreferredType = -1;
+
+    /// M: C2K RILD socket name definition
+    static final String C2K_SOCKET_NAME_RIL = "rild-via";
+
+    private static final String[]  PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+    private static final int CARD_TYPE_SIM  = 1;
+    private static final int CARD_TYPE_USIM = 2;
+    private static final int CARD_TYPE_CSIM = 4;
+    private static final int CARD_TYPE_RUIM = 8;
+
+    /// M: CC009: DTMF request special handling @{
+    /* DTMF request will be ignored when duplicated sending */
+    private class dtmfQueueHandler {
+
+        public dtmfQueueHandler() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public void start() {
+            mDtmfStatus = DTMF_STATUS_START;
+        }
+
+        public void stop() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public boolean isStart() {
+            return (mDtmfStatus == DTMF_STATUS_START);
+        }
+
+        public void add(RILRequest o) {
+            mDtmfQueue.addElement(o);
+        }
+
+        public void remove(RILRequest o) {
+            mDtmfQueue.remove(o);
+        }
+
+        public void remove(int idx) {
+            mDtmfQueue.removeElementAt(idx);
+        }
+
+        public RILRequest get() {
+            return (RILRequest) mDtmfQueue.get(0);
+        }
+
+        public int size() {
+            return mDtmfQueue.size();
+        }
+
+        public void setPendingRequest(RILRequest r) {
+            mPendingCHLDRequest = r;
+        }
+
+        public RILRequest getPendingRequest() {
+            return mPendingCHLDRequest;
+        }
+
+        public void setSendChldRequest() {
+            mIsSendChldRequest = true;
+        }
+
+        public void resetSendChldRequest() {
+            mIsSendChldRequest = false;
+        }
+
+        public boolean hasSendChldRequest() {
+            riljLog("mIsSendChldRequest = " + mIsSendChldRequest);
+            return mIsSendChldRequest;
+        }
+
+        public final int MAXIMUM_DTMF_REQUEST = 32;
+        private final boolean DTMF_STATUS_START = true;
+        private final boolean DTMF_STATUS_STOP = false;
+
+        private boolean mDtmfStatus = DTMF_STATUS_STOP;
+        private Vector mDtmfQueue = new Vector(MAXIMUM_DTMF_REQUEST);
+
+        private RILRequest mPendingCHLDRequest = null;
+        private boolean mIsSendChldRequest = false;
+    }
+
+    private dtmfQueueHandler mDtmfReqQueue = new dtmfQueueHandler();
+    /// @}
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription) {
+            super(context, networkMode, cdmaSubscription, null);
+    }
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription, Integer instanceId) {
+            super(context, networkMode, cdmaSubscription, instanceId);
+    }
+
+    // all that C&P just for responseOperator overriding?
+    @Override
+    protected RILRequest
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return null;
+        }
+
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        if ((rr.mRequest == RIL_REQUEST_DTMF_START) ||
+            (rr.mRequest == RIL_REQUEST_DTMF_STOP)) {
+            synchronized (mDtmfReqQueue) {
+                mDtmfReqQueue.remove(rr);
+                riljLog("remove first item in dtmf queue done, size = " + mDtmfReqQueue.size());
+                if (mDtmfReqQueue.size() > 0) {
+                    RILRequest rr2 = mDtmfReqQueue.get();
+                    if (RILJ_LOGD) riljLog(rr2.serialString() + "> " + requestToString(rr2.mRequest));
+                    send(rr2);
+                } else {
+                    if (mDtmfReqQueue.getPendingRequest() != null) {
+                        riljLog("send pending switch request");
+                        send(mDtmfReqQueue.getPendingRequest());
+                        mDtmfReqQueue.setSendChldRequest();
+                        mDtmfReqQueue.setPendingRequest(null);
+                    }
+                }
+            }
+        }
+        /// @}
+        Object ret = null;
+
+        if ((rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS) ||
+            (rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT)) {
+            mGetAvailableNetworkDoneRegistrant.notifyRegistrants();
+        }
+
+        /* ALPS00799783 START */
+        if (rr.mRequest == RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE) {
+            if ((error != 0) && (mPreviousPreferredType != -1)) {
+                riljLog("restore mPreferredNetworkType from " + mPreferredNetworkType + " to " + mPreviousPreferredType);
+                mPreferredNetworkType = mPreviousPreferredType;
+            }
+            mPreviousPreferredType = -1; //reset
+        }
+        /* ALPS00799783 END */
+
+        /// M: CC012: DTMF request special handling @{
+        if (rr.mRequest == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ||
+            rr.mRequest == RIL_REQUEST_CONFERENCE ||
+            rr.mRequest == RIL_REQUEST_SEPARATE_CONNECTION ||
+            rr.mRequest == RIL_REQUEST_EXPLICIT_CALL_TRANSFER) {
+            riljLog("clear mIsSendChldRequest");
+            mDtmfReqQueue.resetSendChldRequest();
+        }
+        /// @}
+
+        if (error == 0 || p.dataAvail() > 0) {
+
+            /* Convert RIL_REQUEST_GET_MODEM_VERSION back */
+            if (SystemProperties.get("ro.cm.device").indexOf("e73") == 0 &&
+                  rr.mRequest == 220) {
+                rr.mRequest = RIL_REQUEST_BASEBAND_VERSION;
+            }
+
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: {
+                if (mTestingEmergencyCall.getAndSet(false)) {
+                    if (mEmergencyCallbackModeRegistrant != null) {
+                        riljLog("testing emergency call, notify ECM Registrants");
+                        mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                    }
+                }
+                ret =  responseVoid(p);
+                break;
+            }
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseOperator(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret = responseVoid(p); break; //VoLTE
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret = responseSetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret = responseGetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            /*ret = responseInts(p);RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM modify for UIM sms cache*/
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_ISIM_AUTHENTICATION:
+                if (SystemProperties.get("ro.mtk_tc1_feature").equals("1"))
+                    ret =  responseStringEncodeBase64(p);
+                else
+                    ret =  responseString(p);
+                break;
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: ret = responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_VOICE_RADIO_TECH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_CELL_INFO_LIST: ret = responseCellInfoList(p); break;
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_DATA_PROFILE: ret = responseVoid(p); break;
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: ret = responseInts(p); break;
+            case RIL_REQUEST_IMS_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: ret  = responseInts(p); break;
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: ret  = responseVoid(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_NV_READ_ITEM: ret = responseString(p); break;
+            case RIL_REQUEST_NV_WRITE_ITEM: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_RESET_CONFIG: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: ret = responseVoid(p); break;
+            case RIL_REQUEST_ALLOW_DATA: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: ret = responseHardwareConfig(p); break;
+            case RIL_REQUEST_SIM_AUTHENTICATION: ret =  responseICC_IOBase64(p); break;
+            case RIL_REQUEST_SHUTDOWN: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_RADIO_CAPABILITY: ret =  responseRadioCapability(p); break;
+            case RIL_REQUEST_SET_RADIO_CAPABILITY: ret =  responseRadioCapability(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_FORCE_RELEASE_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CALL_INDICATION: ret = responseVoid(p); break;
+            case RIL_REQUEST_EMERGENCY_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_LIST: ret = responseVoid(p); break;
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: ret = responseVoid(p); break;
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: ret = responseVoid(p); break;
+            case RIL_REQUEST_VOICE_ACCEPT: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPLACE_VT_CALL: ret = responseVoid(p); break;
+            /// @}
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: ret = responseVoid(p); break;
+            case RIL_REQUEST_RESUME_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_HOLD_CALL: ret = responseVoid(p); break;
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: ret = responseInts(p); break;
+            case RIL_REQUEST_SET_COLP: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_COLR: ret = responseInts(p); break;
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            //MTK-END SIM ME lock
+            //MTK-START multiple application support
+            case RIL_REQUEST_GENERAL_SIM_AUTH: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: ret = responseIccCardStatus(p); break;
+            //MTK-END multiple application support
+            case RIL_REQUEST_SIM_IO_EX: ret =  responseICC_IO(p); break;
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_PHB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY: ret = responsePhbEntries(p); break;
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_READ_UPB_GRP: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_UPB_GRP: ret = responseVoid(p); break;
+            case RIL_REQUEST_EDIT_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_DELETE_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_UPB_GAS_LIST: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE : ret = responseGetPhbMemStorage(p); break;
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE : responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: ret = responseReadPhbEntryExt(p); break;
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: ret = responseVoid(p); break;
+            // PHB End
+
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_POL_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_POL_LIST: ret = responseNetworkInfoWithActs(p); break;
+            case RIL_REQUEST_SET_POL_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_TRM: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : ret =  responseOperatorInfosWithAct(p); break;
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: ret = responseVoid(p); break;
+
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: ret = responseFemtoCellInfos(p); break;
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: ret = responseVoid(p); break;
+            case RIL_REQUEST_SELECT_FEMTOCELL: ret = responseVoid(p); break;
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+
+            case RIL_REQUEST_QUERY_MODEM_TYPE: ret = responseInts(p); break;
+            case RIL_REQUEST_STORE_MODEM_TYPE: ret = responseVoid(p); break;
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_FD_MODE: ret = responseInts(p); break;
+
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: ret = responseSmsParams(p); break;
+            case RIL_REQUEST_SET_SMS_PARAMS: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: ret = responseSimSmsMemoryStatus(p); break;
+            case RIL_REQUEST_SET_ETWS: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: ret = responseCbConfig(p); break;
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: ret = responseVoid(p); break;
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: ret = responseVoid(p); break;
+
+            /// M: SVLTE Remove access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: ret = responseVoid(p); break;
+
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: ret = responseVoid(p); break;
+
+            case RIL_REQUEST_BTSIM_CONNECT: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: ret = responseVoid(p); break;
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: ret = responseString(p); break;
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: ret =  responseVoid(p); break;
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: ret =  responseVoid(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: ret = responseVoid(p); break;
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: ret = responseVoid(p); break;
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: ret = responseVoid(p); break;
+            /// @}
+
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: ret = responseGetNitzTime(p); break;
+            case RIL_REQUEST_QUERY_UIM_INSERTED: ret = responseInts(p); break;
+            case RIL_REQUEST_SWITCH_HPF: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_AVOID_SYS: ret = responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVOID_SYS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_LOCAL_INFO: ret =  responseInts(p); break;
+            case RIL_REQUEST_UTK_REFRESH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION: ret = responseInts(p); break;
+            case RIL_REQUEST_AGPS_TCP_CONNIND: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: ret = responseStrings(p); break;
+            case RIL_REQUEST_SET_MEID: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ETS_DEV: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_MDN: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_VIA_TRM: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: ret = responseVoid(p); break;
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE: ret = responseVoid(p); break;
+            case RIL_REQUEST_CONFIG_EVDO_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: ret =  responseString(p); break;
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: ret =  responseString(p); break;
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN: ret = responseVoid(p); break;
+            /* M: C2K part end */
+
+            case RIL_REQUEST_MODEM_POWERON: ret =  responseVoid(p); break;
+            case RIL_REQUEST_MODEM_POWEROFF: ret =  responseVoid(p); break;
+
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: ret =  responseVoid(p); break;
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: ret = responseVoid(p); break;
+            case RIL_REQUEST_RESUME_REGISTRATION: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA: ret =  responseVoid(p); break;
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA: ret =  responseVoid(p); break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+            case RIL_REQUEST_SET_STK_UTK_MODE: ret = responseVoid(p); break;
+
+            case RIL_REQUEST_SWITCH_ANTENNA: ret = responseVoid(p); break;
+            case RIL_REQUEST_START_LCE: ret = responseLceStatus(p); break;
+            case RIL_REQUEST_STOP_LCE: ret = responseLceStatus(p); break;
+            case RIL_REQUEST_PULL_LCEDATA: ret = responseLceData(p); break;
+            case RIL_REQUEST_GET_ACTIVITY_INFO: ret = responseActivityData(p); break;
+            case RIL_REQUEST_SWITCH_CARD_TYPE: ret = responseVoid(p); break;
+            case RIL_REQUEST_ENABLE_MD3_SLEEP: ret = responseVoid(p); break;
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER: ret = responseVoid(p); break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                return rr;
+            }
+        }
+
+        if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
+            // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
+            // regardless of error code to continue shutdown procedure.
+            riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " +
+                    error + " Setting Radio State to Unavailable regardless of error.");
+            setRadioState(RadioState.RADIO_UNAVAILABLE);
+        }
+
+        // Here and below fake RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, see b/7255789.
+        // This is needed otherwise we don't automatically transition to the main lock
+        // screen when the pin or puk is entered incorrectly.
+        switch (rr.mRequest) {
+            case RIL_REQUEST_ENTER_SIM_PUK:
+            case RIL_REQUEST_ENTER_SIM_PUK2:
+                if (mIccStatusChangedRegistrants != null) {
+                    if (RILJ_LOGD) {
+                        riljLog("ON enter sim puk fakeSimStatusChanged: reg count="
+                                + mIccStatusChangedRegistrants.size());
+                    }
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+        }
+
+        if (error != 0) {
+            switch (rr.mRequest) {
+                case RIL_REQUEST_ENTER_SIM_PIN:
+                case RIL_REQUEST_ENTER_SIM_PIN2:
+                case RIL_REQUEST_CHANGE_SIM_PIN:
+                case RIL_REQUEST_CHANGE_SIM_PIN2:
+                case RIL_REQUEST_SET_FACILITY_LOCK:
+                    if (mIccStatusChangedRegistrants != null) {
+                        if (RILJ_LOGD) {
+                            riljLog("ON some errors fakeSimStatusChanged: reg count="
+                                    + mIccStatusChangedRegistrants.size());
+                        }
+                        mIccStatusChangedRegistrants.notifyRegistrants();
+                    }
+                    break;
+                case RIL_REQUEST_GET_RADIO_CAPABILITY: {
+                    // Ideally RIL's would support this or at least give NOT_SUPPORTED
+                    // but the hammerhead RIL reports GENERIC :(
+                    // TODO - remove GENERIC_FAILURE catching: b/21079604
+                    if (REQUEST_NOT_SUPPORTED == error ||
+                            GENERIC_FAILURE == error) {
+                        // we should construct the RAF bitmask the radio
+                        // supports based on preferred network bitmasks
+                        ret = makeStaticRadioCapability();
+                        error = 0;
+                    }
+                    break;
+                }
+                case RIL_REQUEST_GET_ACTIVITY_INFO:
+                    ret = new ModemActivityInfo(0, 0, 0,
+                            new int [ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
+                    error = 0;
+                    break;
+            }
+
+            rr.onError(error, ret);
+            return rr;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        return rr;
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition(); // save off position within the Parcel
+        int response = p.readInt();
+
+        switch(response) {
+            // select AOSP unsols to process differently
+            /*
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            */
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            // MTK unsols
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_NETWORK_EXIST: ret = responseInts(p); break;
+            case RIL_UNSOL_FEMTOCELL_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: ret =  responseInts(p); break;
+            case RIL_UNSOL_INVALID_SIM:  ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_ACMT: ret = responseInts(p); break;
+            case RIL_UNSOL_IMEI_LOCK: ret = responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_EVDL_CALL: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_CALL_CTRL: ret = responseStrings(p); break;
+
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: ret =  responseInts(p); break;
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: ret = responseHardwareConfig(p); break;
+            case RIL_UNSOL_RADIO_CAPABILITY:
+                    ret = responseRadioCapability(p); break;
+            case RIL_UNSOL_ON_SS: ret =  responseSsData(p); break;
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: ret =  responseStrings(p); break;
+            case RIL_UNSOL_LCEDATA_RECV: ret = responseLceData(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING: ret = responseInts(p); break;
+            case RIL_UNSOL_CRSS_NOTIFICATION: ret = responseCrssNotification(p); break;
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: ret = responseStrings(p); break;
+            case RIL_UNSOL_CIPHER_INDICATION: ret = responseStrings(p); break;
+            //case RIL_UNSOL_CNAP: ret = responseStrings(p); break; //obsolete
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO: ret =  responseInts(p); break;
+            /// @}
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: ret = responseInts(p); break;
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_RECOVERY: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_ON: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_PLUG_OUT: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_PLUG_IN: ret = responseVoid(p); break;
+            case RIL_UNSOL_TRAY_PLUG_IN: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: ret = responseVoid(p); break;
+            case RIL_UNSOL_DATA_ALLOWED: ret = responseVoid(p); break;
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: ret = responseVoid(p); break;
+            // IMS
+            case RIL_UNSOL_IMS_ENABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_DISABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: ret = responseInts(p); break;
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: ret = responseInts(p); break;
+
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [End]
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT: ret = responseInts(p); break;
+
+            /// M: IMS feature. @{
+            //For updating call ids for conference call after SRVCC is done.
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: ret = responseInts(p); break;
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: ret = responseStrings(p); break;
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : ret = responseStrings(p); break;
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:ret = responseInts(p); break;
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: ret = responseVoid(p); break;
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: ret = responseVoid(p); break;
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: ret = responseInts(p); break;
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SSAC_BARRING_INFO: ret = responseInts(p); break;
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY: ret = responseInts(p); break;
+            /// @}
+
+            /* M: C2K part start*/
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_VIA_GPS_EVENT: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: ret = responseVoid(p); break;
+            /* M: C2K part end*/
+            case RIL_UNSOL_ABNORMAL_EVENT: ret = responseStrings(p); break;
+            case RIL_UNSOL_CDMA_CARD_TYPE: ret = responseInts(p); break;
+            /// M: [C2K] for eng mode start
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO:
+                ret = responseStrings(p);
+                unsljLog(response);
+                break;
+            /// M: [C2K] for eng mode end
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED: ret = responseStrings(p); break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED: ret = responseInts(p); break;
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+            case RIL_UNSOL_SET_ATTACH_APN: ret = responseVoid(p); break;
+
+            // MTK-START, SMS part
+            // SMS ready
+            case RIL_UNSOL_SMS_READY_NOTIFICATION: ret = responseVoid(p); break;
+            // New SMS but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL: ret = responseVoid(p); break;
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION: ret = responseEtwsNotification(p); break;
+            // MTK-END, SMS part
+
+            /// M: [C2K] For ps type changed.
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED: ret = responseInts(p); break;
+
+            ///M: [C2K][MD IRAT] start @{
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                riljLog(" RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE...");
+                ret = responseIratStateChange(p);
+                break;
+            /// }@ [C2K][MD IRAT] end
+            case RIL_UNSOL_IMSI_REFRESH_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_IMSI_READY: ret = responseVoid(p); break;
+            // M: Notify RILJ that the AT+EUSIM was received
+            case RIL_UNSOL_EUSIM_READY: ret = responseVoid(p); break;
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE: ret = responseInts(p); break;
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS: ret = responseInts(p); break;
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND: ret = responseString(p); break;
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED: ret = responseInts(p); break;
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_VT_RING_INFO: ret = responseVoid(p); break;
+            /// @}
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE: ret = responseInts(p); break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        // To avoid duplicating code from RIL.java, we rewrite some response codes to fit
+        // AOSP's one (when they do the same effect)
+        boolean rewindAndReplace = false;
+        int newResponseCode = 0;
+
+        switch (response) {
+            // xen0n: MTK TODO
+            /*
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                /// M: SVLTE UTK feature @{
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkSessionEndRegistrant != null)
+                        && (mUtkSessionEndRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)) {
+                    riljLog("SVLTE UTK received PS session end from MD1");
+                    mUtkSessionEndRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                } else {
+                    if (mCatSessionEndRegistrant != null) {
+                        mCatSessionEndRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                    }
+                }
+                /// @}
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLog(response);
+
+                /// M: SVLTE UTK feature @{
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkProCmdRegistrant != null)
+                        && (mUtkProCmdRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)
+                        && (mBipPsType != IUtkService.SVLTE_BIP_TYPE_ON_LTE)) {
+                    riljLog("SVLTE UTK received PS proactive command from MD1");
+                    mUtkProCmdRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                } else {
+                    if (mCatProCmdRegistrant != null) {
+                        mCatProCmdRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                    }
+                }
+                /// @}
+                break;
+
+            // case RIL_UNSOL_STK_EVENT_NOTIFY:
+            // identical to upstream, not ported
+            */
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                // MTK-START, SMS part
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                } else {
+                    // Phone process is not ready and cache it then wait register to notify
+                    if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "Cache sim sms full event");
+                    mIsSmsSimFull = true;
+                }
+                // MTK-END, SMS part
+                break;
+
+            case RIL_UNSOL_RIL_CONNECTED: {
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // Set ecc list before MO call
+                if  (TelephonyManager.getDefault().getMultiSimConfiguration() == TelephonyManager.MultiSimVariants.DSDA
+                        || mInstanceId == 0) {
+                    setEccList();
+                }
+
+                // Initial conditions
+                //setRadioPower(false, null);
+
+                setCdmaSubscriptionSource(mCdmaSubscription, null);
+                setCellInfoListRate(Integer.MAX_VALUE, null);
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                //[ALPS01810775,ALPS01868743]-Start
+                //"isScreenOn" removed and replaced by mDefaultDisplayState
+                //sendScreenState(isScreenOn);
+                if (mDefaultDisplayState == Display.STATE_ON) {
+                    sendScreenState(true);
+                } else if (mDefaultDisplayState == Display.STATE_OFF) {
+                    sendScreenState(false);
+                } else {
+                    riljLog("not setScreenState mDefaultDisplayState="
+                            + mDefaultDisplayState);
+                }
+                //[ALPS01810775,ALPS01868743]-End
+                break;
+            }
+
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mNeighboringInfoRegistrants != null) {
+                    mNeighboringInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_NETWORK_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                 /* M: Start - abnormal event logging for logger */
+                if (ret != null) {
+                    String[] networkinfo = (String[]) ret;
+                    int type = Integer.parseInt(networkinfo[0]);
+                    //type 400 for abnormal testing event.
+                    //type 401 for no service event.
+                    //type 402 for C2K voice call drop.
+                    //type 403 for C2K SMS failure.
+                    if (type == 401 || type == 402 || type == 403) {
+                        Intent intent = new Intent(
+                                TelephonyIntents.ACTION_EXCEPTION_HAPPENED);
+                        intent.putExtra("Reason", "SmartLogging");
+                        intent.putExtra("from_where", "RIL");
+                        mContext.sendBroadcast(intent);
+                        riljLog("Broadcast for SmartLogging " + type);
+                        break;
+                    }
+                }
+                /* M: End - abnormal event logging for logger */
+                if (mNetworkInfoRegistrants != null) {
+                    mNetworkInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_NETWORK_EXIST:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mNetworkExistRegistrants != null) {
+                    mNetworkExistRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mHardwareConfigChangeRegistrants != null) {
+                    mHardwareConfigChangeRegistrants.notifyRegistrants(
+                                             new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RADIO_CAPABILITY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                mRadioCapability = (RadioCapability)ret;
+                if (mPhoneRadioCapabilityChangedRegistrants != null) {
+                    mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                 }
+                 break;
+            case RIL_UNSOL_ON_SS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsRegistrant != null) {
+                    mSsRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatCcAlphaRegistrant != null) {
+                    mCatCcAlphaRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_LCEDATA_RECV:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mLceInfoRegistrant != null) {
+                    mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mCallForwardingInfoRegistrants != null) {
+                    boolean bCfuEnabled = (((int[]) ret)[0] == 1);
+                    boolean bIsLine1 = (((int[]) ret)[1] == 1);
+                    /* ONLY notify for Line1 */
+                    if (bIsLine1) {
+                        mCfuReturnValue = ret;
+                        mCallForwardingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+
+            case RIL_UNSOL_CRSS_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallRelatedSuppSvcRegistrant != null) {
+                    mCallRelatedSuppSvcRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_INCOMING_CALL_INDICATION:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                // example of how mindless copying can adversely affect functionality
+                // if (mIncomingCallIndicationRegistrant != null) {
+                //     mIncomingCallIndicationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                // }
+                setCallIndication((String[])ret);
+                rewindAndReplace = true;
+                newResponseCode = RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED;
+                break;
+
+            case RIL_UNSOL_CIPHER_INDICATION:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+
+                int simCipherStatus = Integer.parseInt(((String[]) ret)[0]);
+                int sessionStatus = Integer.parseInt(((String[]) ret)[1]);
+                int csStatus = Integer.parseInt(((String[]) ret)[2]);
+                int psStatus = Integer.parseInt(((String[]) ret)[3]);
+
+                riljLog("RIL_UNSOL_CIPHER_INDICATION :" + simCipherStatus + " " + sessionStatus + " " + csStatus + " " + psStatus);
+
+                int[] cipherResult = new int[3];
+
+                cipherResult[0] = simCipherStatus;
+                cipherResult[1] = csStatus;
+                cipherResult[2] = psStatus;
+
+                if (mCipherIndicationRegistrant != null) {
+                    mCipherIndicationRegistrant.notifyRegistrants(
+                        new AsyncResult(null, cipherResult, null));
+                }
+
+                break;
+            //obsolete
+            /*
+            case RIL_UNSOL_CNAP:
+                    String[] respCnap = (String[]) ret;
+                    int validity = Integer.parseInt(((String[]) ret)[1]);
+
+                    riljLog("RIL_UNSOL_CNAP :" + respCnap[0] + " " + respCnap[1]);
+                    if (validity == 0) {
+                        if (mCnapNotifyRegistrant != null) {
+                            mCnapNotifyRegistrant.notifyRegistrant(
+                                            new AsyncResult(null, respCnap, null));
+                        }
+                    }
+
+                break;
+                */
+            /// @}
+
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+
+                if (mSpeechCodecInfoRegistrant != null) {
+                    mSpeechCodecInfoRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+            break;
+            /// @}
+
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                int[] stat = null;
+                if (ret != null) {
+                    stat = (int[]) ret;
+                }
+                mPsNetworkStateRegistrants
+                        .notifyRegistrants(new AsyncResult(null, stat, null));
+            break;
+
+            /* M: network part start */
+            case RIL_UNSOL_IMEI_LOCK:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImeiLockRegistrant != null) {
+                    mImeiLockRegistrant.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            //ALPS00248788 START
+            case RIL_UNSOL_INVALID_SIM:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mInvalidSimInfoRegistrant != null) {
+                   mInvalidSimInfoRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            //ALPS00248788 END
+            //MTK-START [MTK80515] [ALPS00368272]
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (ret != null) {
+                    int[] emmrrs = (int[]) ret;
+                    int ps_status = Integer.valueOf(emmrrs[0]);
+
+                    /*
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        try {
+                            if (mServiceStateExt.isBroadcastEmmrrsPsResume(ps_status)) {
+                                riljLog("Broadcast for EMMRRS: android.intent.action.EMMRRS_PS_RESUME ");
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                    */
+                }
+                break;
+            //MTK-END [MTK80515] [ALPS00368272]
+
+            case RIL_UNSOL_FEMTOCELL_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                mFemtoCellInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                break;
+
+            // ALPS00297719 START
+            case RIL_UNSOL_RESPONSE_ACMT:
+                if (RILJ_LOGD) unsljLog(response);
+                if (ret != null) {
+                    int[] acmt = (int[]) ret;
+                    if (acmt.length == 2) {
+                        int error_type = Integer.valueOf(acmt[0]);
+                        int error_cause = acmt[1];
+
+                        /*
+                        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                            try {
+                                if (mServiceStateExt.needBrodcastAcmt(error_type, error_cause)
+                                        == true) {
+                                    Intent intent = new Intent(
+                                            TelephonyIntents.ACTION_ACMT_NETWORK_SERVICE_STATUS_INDICATOR);
+                                    intent.putExtra("CauseCode", acmt[1]);
+                                    intent.putExtra("CauseType", acmt[0]);
+                                    mContext.sendBroadcast(intent);
+                                    riljLog("Broadcast for ACMT: com.VendorName.CauseCode "
+                                            + acmt[1] + "," + acmt[0]);
+                                }
+                            } catch (RuntimeException e) {
+                                e.printStackTrace();
+                            }
+                        }
+                        */
+                    }
+                }
+                break;
+            // ALPS00297719 END
+            /* M: network part end */
+            case RIL_UNSOL_STK_EVDL_CALL:
+                // if (false == SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    if (RILJ_LOGD) unsljLogvRet(response, ret);
+                    if (mStkEvdlCallRegistrant != null) {
+                        mStkEvdlCallRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                    }
+                // }
+                break;
+
+            case RIL_UNSOL_STK_CALL_CTRL:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mStkCallCtrlRegistrant != null) {
+                    mStkCallCtrlRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_STK_SETUP_MENU_RESET:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkSetupMenuResetRegistrant != null) {
+                    mStkSetupMenuResetRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: {
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSessionChangedRegistrants != null) {
+                    mSessionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            }
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimMissing != null) {
+                    mSimMissing.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_SIM_RECOVERY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimRecovery != null) {
+                    mSimRecovery.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIRTUAL_SIM_ON:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOn != null) {
+                    mVirtualSimOn.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIRTUAL_SIM_OFF:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOff != null) {
+                    mVirtualSimOff.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_SIM_PLUG_OUT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugOutRegistrants != null) {
+                    mSimPlugOutRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                mCfuReturnValue = null;
+                break;
+            case RIL_UNSOL_SIM_PLUG_IN:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugInRegistrants != null) {
+                    mSimPlugInRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_TRAY_PLUG_IN:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mTrayPlugInRegistrants != null) {
+                    mTrayPlugInRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            // MTK-START, SMS part
+            // SMS ready notification
+            case RIL_UNSOL_SMS_READY_NOTIFICATION:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mSmsReadyRegistrants.size() != 0) {
+                    mSmsReadyRegistrants.notifyRegistrants();
+                } else {
+                    // Phone process is not ready and cache it then wait register to notify
+                    if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "Cache sms ready event");
+                    mIsSmsReady = true;
+                }
+                break;
+
+            // New SMS but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mMeSmsFullRegistrant != null) {
+                    mMeSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEtwsNotificationRegistrant != null) {
+                    mEtwsNotificationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            // MTK-END, SMS part
+
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mCommonSlotNoChangedRegistrants != null) {
+                    mCommonSlotNoChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+            case RIL_UNSOL_DATA_ALLOWED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mDataAllowedRegistrants != null) {
+                    mDataAllowedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_PHB_READY_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mPhbReadyRegistrants != null) {
+                    mPhbReadyRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_IMS_REGISTRATION_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsRegistrationInfoRegistrants != null) {
+                    mImsRegistrationInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                synchronized (mWPMonitor) {
+                    mEcopsReturnValue = ret;
+                    if (mPlmnChangeNotificationRegistrant.size() > 0) {
+                        if (RILJ_LOGD) riljLog("ECOPS,notify mPlmnChangeNotificationRegistrant");
+                        mPlmnChangeNotificationRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                synchronized (mWPMonitor) {
+                    mEmsrReturnValue = ret;
+                    if (mRegistrationSuspendedRegistrant != null) {
+                        if (RILJ_LOGD) riljLog("EMSR, notify mRegistrationSuspendedRegistrant");
+                        mRegistrationSuspendedRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mMelockRegistrants != null) {
+                    mMelockRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            //Remote SIM ME lock related APIs [End]
+            case RIL_UNSOL_IMS_ENABLE_DONE:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsEnableRegistrants != null) {
+                    mImsEnableRegistrants.notifyRegistrants();
+                }
+                break;
+            case RIL_UNSOL_IMS_DISABLE_DONE:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsDisableRegistrants != null) {
+                    mImsDisableRegistrants.notifyRegistrants();
+                }
+                break;
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT:
+                Integer scriResult = (((int[]) ret)[0]);
+                riljLog("s:" + scriResult + ":" + (((int[]) ret)[0]));
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mScriResultRegistrant != null) {
+                   mScriResultRegistrant.notifyRegistrant(new AsyncResult(null, scriResult, null));
+                }
+                break;
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mEpsNetworkFeatureSupportRegistrants != null) {
+                    mEpsNetworkFeatureSupportRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            /// M: IMS feature. @{
+            //For updating call ids for conference call after SRVCC is done.
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEconfSrvccRegistrants != null) {
+                    mEconfSrvccRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEconfResultRegistrants != null) {
+                     riljLog("Notify ECONF result");
+                     String[] econfResult = (String[]) ret;
+                     riljLog("ECONF result = " + econfResult[3]);
+                     mEconfResultRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION :
+                if (RILJ_LOGD) unsljLog(response);
+                if (mCallInfoRegistrants != null) {
+                   mCallInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEpsNetworkFeatureInfoRegistrants != null) {
+                   mEpsNetworkFeatureInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSrvccHandoverInfoIndicationRegistrants != null) {
+                    mSrvccHandoverInfoIndicationRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                break;
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mMoDataBarringInfoRegistrants != null) {
+                    mMoDataBarringInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SSAC_BARRING_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSsacBarringInfoRegistrants != null) {
+                    mSsacBarringInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @[
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEmergencyBearerSupportInfoRegistrants != null) {
+                    mEmergencyBearerSupportInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE:
+                if (RILJ_LOGD) unsljLog(response);
+                mRacUpdateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN:
+                if (RILJ_LOGD) unsljLog(response);
+                mRemoveRestrictEutranRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+
+            case RIL_UNSOL_SET_ATTACH_APN:
+                if (RILJ_LOGD) unsljLog(response);
+                mResetAttachApnRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mAcceptedRegistrant != null) {
+                    mAcceptedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_SESSION_END:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+
+                if (mUtkSessionEndRegistrant != null) {
+                    mUtkSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mUtkProCmdRegistrant != null) {
+                    mUtkProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_EVENT_NOTIFY:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mUtkEventRegistrant != null) {
+                    mUtkEventRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_GPS_EVENT:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mViaGpsEvent != null) {
+                    mViaGpsEvent.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mNetworkTypeChangedRegistrant != null) {
+                    mNetworkTypeChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mInvalidSimDetectedRegistrant != null) {
+                    mInvalidSimDetectedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /* M: C2K part end*/
+            case RIL_UNSOL_ABNORMAL_EVENT:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mAbnormalEventRegistrant != null) {
+                    mAbnormalEventRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_CDMA_CARD_TYPE:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaCardTypeRegistrants != null) {
+                    mCdmaCardTypeValue = ret;
+                    mCdmaCardTypeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M:[C2K] for eng mode start
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mEngModeNetworkInfoRegistrant != null) {
+                    mEngModeNetworkInfoRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M:[C2K] for eng mode end
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                String mccmnc = "";
+                if (ret != null && ret instanceof String[]) {
+                    String s[] = (String[]) ret;
+                    if (s.length >= 2) {
+                        mccmnc = s[0] + s[1];
+                    }
+                }
+                riljLog("mccmnc changed mccmnc=" + mccmnc);
+                mMccMncChangeRegistrants.notifyRegistrants(new AsyncResult(null, mccmnc, null));
+                break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                int[] rat = (int[]) ret;
+                riljLog("Notify RIL_UNSOL_GMSS_RAT_CHANGED result rat = " + rat);
+                if (mGmssRatChangedRegistrant != null) {
+                    mGmssRatChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, rat, null));
+                }
+                break;
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+            /// M: [C2K] for ps type changed. @{
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mDataNetworkTypeChangedRegistrant != null) {
+                    mDataNetworkTypeChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+            ///M: [C2K][MD IRAT] start @{
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                mIratStateChangeRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                break;
+            /// @} [C2K][MD IRAT] end
+            case RIL_UNSOL_IMSI_REFRESH_DONE:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (mImsiRefreshDoneRegistrant != null) {
+                    mImsiRefreshDoneRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_CDMA_IMSI_READY:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (mCdmaImsiReadyRegistrant != null) {
+                    mCdmaImsiReadyRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_EUSIM_READY:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                mIsEusimReady = true;
+                if (mEusimReady != null) {
+                    mEusimReady.notifyRegistrants(new AsyncResult(null, null, null));
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                        if ((mInstanceId == 0) || (mInstanceId == 10)) {
+                            SystemProperties.set(PROPERTY_RIL_CARD_TYPE_SET, "1");
+                            riljLog("set gsm.ril.cardtypeset to 1");
+                        } else if ((mInstanceId == 1) || (mInstanceId == 11)) {
+                            SystemProperties.set(PROPERTY_RIL_CARD_TYPE_SET_2, "1");
+                            riljLog("set gsm.ril.cardtypeset.2 to 1");
+                        } else {
+                            riljLog("not set cardtypeset mInstanceId=" + mInstanceId);
+                        }
+                    }
+                }
+                break;
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaSignalFadeRegistrant != null) {
+                    mCdmaSignalFadeRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaToneSignalsRegistrant != null) {
+                    mCdmaToneSignalsRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            // xen0n: MTK TODO
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLog(response);
+                /*
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkProCmdRegistrant != null)
+                        && (mUtkProCmdRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)
+                        && (mBipPsType != IUtkService.SVLTE_BIP_TYPE_ON_LTE)) {
+                    riljLog("SVLTE UTK received BIP proactive command from MD1");
+                    mUtkProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                } else {
+                */
+                    if (mBipProCmdRegistrant != null) {
+                        mBipProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                    }
+                // }
+                break;
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED:
+                int[] state = null;
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (ret != null) {
+                    state = (int[]) ret;
+
+                    //update switching state
+                    if (state[0] == 0){
+                        WorldMode.updateSwitchingState(true);
+                    }else{
+                        WorldMode.updateSwitchingState(false);
+                    }
+
+                    //sendBroadcast with state
+                    Intent intent = new Intent(
+                            TelephonyIntents.ACTION_WORLD_MODE_CHANGED);
+                    intent.putExtra(TelephonyIntents.EXTRA_WORLD_MODE_CHANGE_STATE,
+                            (Integer)state[0]);
+                    mContext.sendBroadcast(intent);
+                    if (RILJ_LOGD) {
+                        riljLog("Broadcast for WorldModeChanged: state=" + state[0]);
+                    }
+                }
+                break;
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mVtStatusInfoRegistrants != null) {
+                    mVtStatusInfoRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_VT_RING_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mVtRingRegistrants != null) {
+                    mVtRingRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mLteAccessStratumStateRegistrants != null) {
+                    mLteAccessStratumStateRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                Rlog.i(RILJ_LOG_TAG, "Unprocessed unsolicited known MTK response: " + response);
+        }
+
+        if (rewindAndReplace) {
+            Rlog.w(RILJ_LOG_TAG, "Rewriting MTK unsolicited response " + response + " to " + newResponseCode);
+
+            // Rewrite
+            p.setDataPosition(dataPosition);
+            p.writeInt(newResponseCode);
+
+            // And rewind again in front
+            p.setDataPosition(dataPosition);
+
+            super.processUnsolicited(p);
+        }
+    }
+
+    /*
+     * to protect modem status we need to avoid two case :
+     * 1. DTMF start -> CHLD request -> DTMF stop
+     * 2. CHLD request -> DTMF request
+     */
+    private void handleChldRelatedRequest(RILRequest rr) {
+        synchronized (mDtmfReqQueue) {
+            int queueSize = mDtmfReqQueue.size();
+            int i, j;
+            if (queueSize > 0) {
+                RILRequest rr2 = mDtmfReqQueue.get();
+                if (rr2.mRequest == RIL_REQUEST_DTMF_START) {
+                    // need to send the STOP command
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is START, send stop dtmf and pending switch");
+                    if (queueSize > 1) {
+                        j = 2;
+                    } else {
+                        // need to create a new STOP command
+                        j = 1;
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  " + mDtmfReqQueue.size());
+
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  after " + mDtmfReqQueue.size());
+                    if (mDtmfReqQueue.size() == 1) { // only start command, we need to add stop command
+                        RILRequest rr3 = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, null);
+                        if (RILJ_LOGD) riljLog("add dummy stop dtmf request");
+                        mDtmfReqQueue.stop();
+                        mDtmfReqQueue.add(rr3);
+                    }
+                }
+                else {
+                    // first request is STOP, just remove it and send switch
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is STOP, penging switch");
+                    j = 1;
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                }
+                mDtmfReqQueue.setPendingRequest(rr);
+            } else {
+                if (RILJ_LOGD) riljLog("DTMF queue is 0, send switch Immediately");
+                mDtmfReqQueue.setSendChldRequest();
+                send(rr);
+            }
+        }
+    }
+
+    private static int readRilMessage(InputStream is, byte[] buffer)
+            throws IOException {
+        int countRead;
+        int offset;
+        int remaining;
+        int messageLength;
+
+        // First, read in the length of the message
+        offset = 0;
+        remaining = 4;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message length");
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        messageLength = ((buffer[0] & 0xff) << 24)
+                | ((buffer[1] & 0xff) << 16)
+                | ((buffer[2] & 0xff) << 8)
+                | (buffer[3] & 0xff);
+
+        // Then, re-use the buffer and read in the message itself
+        offset = 0;
+        remaining = messageLength;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message.  messageLength=" + messageLength
+                        + " remaining=" + remaining);
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        return messageLength;
+    }
+
+        protected RILReceiver createRILReceiver() {
+        return new MTKRILReceiver();
+    }
+
+        protected class MTKRILReceiver extends RILReceiver {
+        byte[] buffer;
+
+        protected MTKRILReceiver() {
+            buffer = new byte[RIL_MAX_COMMAND_BYTES];
+        }
+
+        /// M: For SVLTE to disconnect socket in C2K only mode.
+        boolean mStoped = false;
+
+        @Override
+        public void
+        run() {
+            int retryCount = 0;
+            String rilSocket = "rild";
+
+            try {for (;;) {
+                /// M: For SVLTE to disconnect socket in C2K only mode.
+                if (mStoped) {
+                    riljLog("[RIL SWITCH] stoped now!");
+                    return;
+                }
+
+                LocalSocket s = null;
+                LocalSocketAddress l;
+
+                /// M: If SVLTE support, LTE RIL ID is a special value, force connect to rild socket
+                if (mInstanceId == null || SvlteUtils.isValidPhoneId(mInstanceId)) {
+                    rilSocket = SOCKET_NAME_RIL[SvlteUtils.getSlotId(mInstanceId)];
+                } else {
+                    if (SystemProperties.getInt("ro.mtk_dt_support", 0) != 1) {
+                        // dsds
+                        rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                    } else {
+                        // dsda
+                        if (SystemProperties.getInt("ro.evdo_dt_support", 0) == 1) {
+                            // c2k dsda
+                            rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                        } else if (SystemProperties.getInt("ro.telephony.cl.config", 0) == 1) {
+                            // for C+L
+                            rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                        } else {
+                            // gsm dsda
+                            rilSocket = "rild-md2";
+                        }
+                    }
+                }
+
+                /* M: C2K start */
+                int phoneType = TelephonyManager.getPhoneType(mPreferredNetworkType);
+                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                    rilSocket = C2K_SOCKET_NAME_RIL;
+                }
+                /* M: C2K end */
+
+                riljLog("rilSocket[" + mInstanceId + "] = " + rilSocket);
+
+                try {
+                    s = new LocalSocket();
+                    l = new LocalSocketAddress(rilSocket,
+                            LocalSocketAddress.Namespace.RESERVED);
+                    s.connect(l);
+                } catch (IOException ex){
+                    try {
+                        if (s != null) {
+                            s.close();
+                        }
+                    } catch (IOException ex2) {
+                        //ignore failure to close after failure to connect
+                    }
+
+                    // don't print an error message after the the first time
+                    // or after the 8th time
+
+                    if (retryCount == 8) {
+                        Rlog.e (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket after " + retryCount
+                            + " times, continuing to retry silently");
+                    } else if (retryCount >= 0 && retryCount < 8) {
+                        Rlog.i (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket; retrying after timeout");
+                    }
+
+                    try {
+                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                    } catch (InterruptedException er) {
+                    }
+
+                    retryCount++;
+                    continue;
+                }
+
+                retryCount = 0;
+
+                mSocket = s;
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '"
+                        + rilSocket + "' socket");
+
+                int length = 0;
+                try {
+                    InputStream is = mSocket.getInputStream();
+                    for (;;) {
+                        Parcel p;
+                        length = readRilMessage(is, buffer);
+                        if (length < 0) {
+                            // End-of-stream reached
+                            break;
+                        }
+                        p = Parcel.obtain();
+                        p.unmarshall(buffer, 0, length);
+                        p.setDataPosition(0);
+
+                        //Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
+
+                        processResponse(p);
+                        p.recycle();
+                    }
+                } catch (java.io.IOException ex) {
+                    Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed",
+                          ex);
+                } catch (Throwable tr) {
+                    Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length +
+                        "Exception:" + tr.toString());
+                }
+
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket
+                      + "' socket");
+
+                setRadioState (RadioState.RADIO_UNAVAILABLE);
+
+                try {
+                    mSocket.close();
+                } catch (IOException ex) {
+                }
+
+                mSocket = null;
+                RILRequest.resetSerial();
+
+                // Clear request list on close
+                clearRequestList(RADIO_NOT_AVAILABLE, false);
+            }} catch (Throwable tr) {
+                Rlog.e(RILJ_LOG_TAG,"Uncaught exception", tr);
+            }
+
+            /* We're disconnected so we don't know the ril version */
+            notifyRegistrantsRilConnectionChanged(-1);
+        }
+    }
+
+    /* broken by new version of MTK RIL, disable for now */
+    /*
+    public void handle3GSwitch() {
+        int simId = mInstanceId == null ? 0 : mInstanceId;
+        int newsim = SystemProperties.getInt("gsm.3gswitch", 0);
+        newsim = newsim - 1;
+        if(!(simId==newsim)) {
+            int prop = SystemProperties.getInt("gsm.3gswitch", 0);
+            if (RILJ_LOGD) riljLog("Setting data subscription on SIM" + (simId + 1) + " mInstanceid=" + mInstanceId + " gsm.3gswitch=" + prop);
+            RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_3G_CAPABILITY, null);
+            rr.mParcel.writeInt(1);
+            int realsim = simId + 1;
+            rr.mParcel.writeInt(realsim);
+            if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+            send(rr);
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException er) {
+            }
+            resetRadio(null);
+            try {
+                Thread.sleep(4*1000);
+            } catch (InterruptedException er) {
+            }
+        }
+        else {
+            if (RILJ_LOGD) riljLog("Not setting data subscription on same SIM");
+        }
+    }
+
+    public void setDataAllowed(boolean allowed, Message result) {
+        handle3GSwitch();
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ALLOW_DATA, result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + allowed);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(allowed ? 1 : 0);
+        send(rr);
+    }
+    */
+
+    @Override
+    public void connectRilSocket() {
+        if (RILJ_LOGD) {
+            riljLog("[RIL SWITCH]reconnectRilSocket()");
+        }
+        if (mReceiverThread == null && mReceiver == null) {
+            connectRild();
+        } else {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH] Already connected, abort connect request.");
+            }
+        }
+    }
+
+    @Override
+    public void disconnectRilSocket() {
+        if (RILJ_LOGD) {
+            riljLog("[RIL SWITCH]disconnectRilSocket()");
+        }
+        if (mSenderThread != null) {
+            mSenderThread.getLooper().quit();
+            mSenderThread = null;
+        }
+        if (mReceiver != null) {
+            if (mReceiver instanceof MTKRILReceiver) {
+                ((MTKRILReceiver) mReceiver).mStoped = true;
+            }
+        }
+
+        try {
+            if (mSocket != null) {
+                mSocket.shutdownInput();
+            }
+            if (mReceiverThread != null) {
+                while (mReceiverThread.isAlive()) {
+                    riljLog("[RIL SWITCH]mReceiverThread.isAlive() = true;");
+                    Thread.sleep(500);
+                }
+            }
+            mReceiverThread = null;
+            mReceiver = null;
+            // Set mRilVersion to -1, it will not notifyRegistrant in registerForRilConnected.
+            mRilVersion = -1;
+        } catch (IOException ex) {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH]IOException ex = " + ex);
+            }
+        } catch (InterruptedException er) {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH]InterruptedException er = " + er);
+            }
+        }
+    }
+
+    // ported from sprout RIL
+    protected Object
+    responseFailCause(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+        LastCallFailCause failCause = new LastCallFailCause();
+        failCause.causeCode = response[0];
+        if (p.dataAvail() > 0) {
+          failCause.vendorCause = p.readString();
+        }
+        return failCause;
+    }
+
+    // CommandsInterface impl
+
+    public void setUiccSubscription(int slotId, int appIndex, int subId,
+            int subStatus, Message result) {
+        //Note: This RIL request is also valid for SIM and RUIM (ICC card)
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " slot: " + slotId + " appIndex: " + appIndex
+                + " subId: " + subId + " subStatus: " + subStatus);
+
+        rr.mParcel.writeInt(slotId);
+        rr.mParcel.writeInt(appIndex);
+        rr.mParcel.writeInt(subId);
+        rr.mParcel.writeInt(subStatus);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, String type, Message result) {
+        riljLog("supplyNetworkDepersonalization: type is ignored on MTK!");
+        supplyNetworkDepersonalization(netpin, result);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeString(netpin);
+
+        send(rr);
+    }
+
+    // xen0n refactored
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        if (PhoneNumberUtils.isUriNumber(address)) {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL_WITH_SIP_URI, result);
+
+           rr.mParcel.writeString(address);
+           if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+           send(rr);
+           return;
+        }
+
+        super.dial(address, clirMode, uusInfo, result);
+    }
+
+    @Override
+    public void
+    switchWaitingOrHoldingAndActive (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(
+                        RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE,
+                                        result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    conference (Message result) {
+
+        /// M: CC053: MoMS [Mobile Managerment] @{
+        // 3. Permission Control for Conference call
+        /*
+        if (MobileManagerUtils.isSupported()) {
+            if (!checkMoMSSubPermission(SubPermissions.MAKE_CONFERENCE_CALL)) {
+                return;
+            }
+        }
+        */
+        /// @}
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        ///@}
+    }
+
+    @Override
+    public void
+    separateConnection (int gsmIndex, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SEPARATE_CONNECTION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                            + " " + gsmIndex);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(gsmIndex);
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    explicitCallTransfer (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_EXPLICIT_CALL_TRANSFER, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    startDtmf(char c, Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (!mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+                    rr.mParcel.writeString(Character.toString(c));
+                    mDtmfReqQueue.start();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send start dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    @Override
+    public void
+    stopDtmf(Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
+
+                    mDtmfReqQueue.stop();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send stop dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+        /* [Note by mtk01411] In original Android2.1 release: MAX PDP Connection is 1
+        * request_cid is only allowed to set as "1" manually
+        */
+        setupDataCall(radioTechnology, profile, apn, user, password, authType, protocol, "1", result);
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            String interfaceId, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mParcel.writeInt(8); //the number should be changed according to number of parameters
+
+        rr.mParcel.writeString(radioTechnology);
+        rr.mParcel.writeString(profile);
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(user);
+        rr.mParcel.writeString(password);
+        rr.mParcel.writeString(authType);
+        rr.mParcel.writeString(protocol);
+
+        /** M: specify interface Id */
+        rr.mParcel.writeString(interfaceId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol + " " + interfaceId);
+
+        send(rr);
+    }
+
+    @Override
+    public void setModemPower(boolean power, Message result) {
+
+        if (RILJ_LOGD) riljLog("Set Modem power as: " + power);
+        RILRequest rr;
+
+        if (power) {
+            rr = RILRequest.obtain(RIL_REQUEST_MODEM_POWERON, result);
+        }
+        else {
+            rr = RILRequest.obtain(RIL_REQUEST_MODEM_POWEROFF, result);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+            + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: SS part */
+    // mtk00732 add for getCOLP
+    public void
+    getCOLP(Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_GET_COLP, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_GET_COLP, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    // mtk00732 add for setCOLP
+    public void
+    setCOLP(boolean enable, Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_SET_COLP, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_SET_COLP, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + enable);
+
+        send(rr);
+    }
+
+    // mtk00732 add for getCOLR
+    public void
+    getCOLR(Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_GET_COLR, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_GET_COLR, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    @Override
+    public void
+    getAvailableNetworks(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    cancelAvailableNetworks(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    /* M: SS part */
+    ///M: For query CNAP
+    public void sendCNAPSS(String cnapssString, Message response) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_SEND_CNAP, response, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_SEND_CNAP, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + cnapssString);
+
+        rr.mParcel.writeString(cnapssString);
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    public void setBandMode(int[] bandMode, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_BAND_MODE, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(bandMode[0]);
+        rr.mParcel.writeInt(bandMode[1]);
+        rr.mParcel.writeInt(bandMode[2]);
+
+        Rlog.d(RILJ_LOG_TAG, "Set band modes: " + bandMode[1] + ", " + bandMode[2]);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                 + " " + bandMode);
+
+        send(rr);
+     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+
+        RILRequest rr = RILRequest.obtain(
+            RILConstants.RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM,
+            response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        int[] param = new int[1];
+        if (resCode == 0x21 || resCode == 0x20) {
+            param[0] = resCode;
+        } else {
+            param[0] = accept ? 1 : 0;
+        }
+        rr.mParcel.writeIntArray(param);
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_QUERY_UTK_MENU_FROM_MD, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void queryStkSetUpMenuFromMD(String contents, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_QUERY_STK_MENU_FROM_MD, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(networkType);
+
+        mPreviousPreferredType = mPreferredNetworkType; //ALPS00799783
+        mPreferredNetworkType = networkType;
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+        }
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setLocationUpdates(boolean enable, Message response) {
+        //MTK-START [ALPS00093395]Consider screen on/off state
+        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        if ((pm.isScreenOn()) && (false == enable)) return;
+        //MTK-END [ALPS00093395]Consider screen on/off state
+
+        super.setLocationUpdates(enable, response);
+    }
+
+    @Override
+    protected Object
+    responseInts(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+
+        response = new int[numInts];
+        // MTK
+        riljLog("responseInts numInts=" + numInts);
+
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+            // MTK
+            riljLog("responseInts response[" + i + "]=" + response[i]);
+        }
+
+        return response;
+    }
+
+    protected Object
+    responseStringEncodeBase64(Parcel p) {
+        String response;
+
+        response = p.readString();
+
+        if (RILJ_LOGD) {
+            riljLog("responseStringEncodeBase64 - Response = " + response);
+        }
+
+        byte[] auth_output = new byte[response.length() / 2];
+        for (int i = 0; i < auth_output.length; i++) {
+            auth_output[i] |= Character.digit(response.charAt(i * 2), 16) * 16;
+            auth_output[i] |= Character.digit(response.charAt(i * 2 + 1), 16);
+        }
+        response = android.util.Base64.encodeToString(auth_output, android.util.Base64.NO_WRAP);
+
+        if (RILJ_LOGD) {
+            riljLog("responseStringEncodeBase64 - Encoded Response = " + response);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSimRefresh(Parcel p) {
+        IccRefreshResponse response = new IccRefreshResponse();
+
+        int i = 0;
+        int files_num = 0;
+        String efId_String;
+
+        if (SystemProperties.get("ro.mtk_wifi_calling_ril_support").equals("1")) {
+            response.sessionId = p.readInt();
+            //files_num = numInts - 2; //sessionid + refresh type
+        } else {
+            //files_num = numInts - 1; //refresh type
+        }
+        //refresh type
+        response.refreshResult = p.readInt();
+        //efIds hex string
+        efId_String = p.readString();
+        if (null != efId_String && 4 <= efId_String.length()) {
+            files_num = efId_String.length() / 4;
+        }
+        response.efId = new int[files_num];
+        riljLog("efId_String: " + efId_String + ", files_num: " + files_num);
+
+        int startIdx = 0;
+        int endIdx = 0;
+        if (null != efId_String && 4 <= efId_String.length()) {
+            for (i = 0; i < files_num; i++) {
+                String efidStr = efId_String.substring(startIdx, startIdx + 4);
+                response.efId[i] = (Integer.valueOf(efidStr, 16)).intValue();
+                startIdx += 4;
+                riljLog("EFId " + i + ":" + response.efId[i]);
+            }
+        }
+        /*
+        for (i = 0; i < files_num; i++) {
+            response.efId[i] = p.readInt();
+            riljLog("EFId " + i + ":" + response.efId[i]);
+        }
+        */
+        response.aid = p.readString();
+
+        if (SystemProperties.get("ro.mtk_wifi_calling_ril_support").equals("1")) {
+            riljLog("responseSimRefresh, sessionId=" + response.sessionId + ", result=" + response.refreshResult
+                + ", efId=" + response.efId + ", aid=" + response.aid);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        if (RILJ_LOGV) {
+            riljLog("responseCallList: num=" + num +
+                    " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant +
+                    " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
+        }
+        for (int i = 0 ; i < num ; i++) {
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            dc.index = p.readInt();
+            dc.TOA = p.readInt();
+            dc.isMpty = (0 != p.readInt());
+            dc.isMT = (0 != p.readInt());
+            dc.als = p.readInt();
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            /// M: For 3G VT only @{
+            // Assume that call can be either Voice or Video (no Fax, data type is supported)
+            dc.isVideo = !(dc.isVoice);
+            riljLog("isVoice = " + dc.isVoice + ", isVideo = " + dc.isVideo);
+            /// @}
+            dc.isVoicePrivacy = (0 != p.readInt());
+            dc.number = p.readString();
+            int np = p.readInt();
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            // according to ril.h, namePresentation should be handled as numberPresentation;
+            dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
+            int uusInfoPresent = p.readInt();
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                                dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                                dc.uusInfo.getUserData().length));
+                riljLogv("Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                riljLogv("Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                riljLogv("Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
+            if (mEmergencyCallbackModeRegistrant != null) {
+                riljLog("responseCallList: call ended, testing emergency call," +
+                            " notify ECM Registrants");
+                mEmergencyCallbackModeRegistrant.notifyRegistrant();
+            }
+        }
+
+        return response;
+    }
+
+    // slightly modified from the original MediaTekRIL
+    private Object
+    responseOperator(Parcel p) {
+        int num;
+        String response[] = null;
+
+        response = p.readStringArray();
+
+        for (int i = 0; i < response.length; i++) {
+            if((response[i] != null) && (response[i].startsWith("uCs2") == true))
+            {
+                riljLog("responseOperator handling UCS2 format name: response[" + i + "]");
+                try{
+                    response[i] = new String(IccUtils.hexStringToBytes(response[i].substring(4)),"UTF-16");
+                }catch(UnsupportedEncodingException ex){
+                    riljLog("responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+        }
+
+        // NOTE: the original code seemingly has some nontrivial SpnOverride
+        // modifications, so I'm not going to port that.
+        if (response.length > 2 && response[2] != null) {
+            if (response[0] != null && (response[0].equals("") || response[0].equals(response[2]))) {
+                // xen0n: seems the Operators class is now gone
+                // Operators init = new Operators ();
+                // String temp = init.unOptimizedOperatorReplace(response[2]);
+
+                // NOTE: using MTK methods here! (all the used methods are not visible from this class)
+                SpnOverride spnOverride = SpnOverride.getInstance();
+                final String mccmnc = response[2];
+                final String temp = spnOverride.containsCarrierEx(mccmnc) ? spnOverride.getSpnEx(mccmnc) : mccmnc;
+                riljLog("lookup RIL responseOperator() " + response[2] + " gave " + temp + " was " + response[0] + "/" + response[1] + " before.");
+                response[0] = temp;
+                response[1] = temp;
+            }
+        }
+
+        return response;
+    }
+
+    // MTK TODO
+    /*
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        SpnOverride spnOverride = SpnOverride.getInstance();
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 4");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            String strOperatorLong = null;
+            if (spnOverride.containsCarrierEx(strings[i + 2])) {
+                strOperatorLong = spnOverride.getSpnEx(strings[i + 2]);
+            } else {
+                strOperatorLong = strings[i + 0]; // use operator name from RIL
+            }
+            ret.add (
+                new OperatorInfo(
+                    strOperatorLong,
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+    */
+
+    protected Object
+    responseOperatorInfosWithAct(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        String lacStr = SystemProperties.get("gsm.cops.lac");
+        boolean lacValid = false;
+        int lacIndex = 0;
+
+        Rlog.d(RILJ_LOG_TAG, "lacStr = " + lacStr + " lacStr.length=" + lacStr.length() + " strings.length=" + strings.length);
+        if ((lacStr.length() > 0) && (lacStr.length() % 4 == 0) && ((lacStr.length() / 4) == (strings.length / 5))) {
+            Rlog.d(RILJ_LOG_TAG, "lacValid set to true");
+            lacValid = true;
+        }
+
+        SystemProperties.set("gsm.cops.lac", ""); //reset property
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            /* Default display manufacturer maintained operator name table */
+            if (strings[i + 2] != null) {
+                strings[i + 0] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true, mContext);
+                strings[i + 1] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], false, mContext);
+                riljLog("lookup RIL responseOperator(), longAlpha= " + strings[i + 0] + ",shortAlpha= " + strings[i + 1] + ",numeric=" + strings[i + 2]);
+            }
+
+            String longName = null;
+            String shortName = null;
+            /* Operator name from network MM information has higher priority to display */
+            longName = lookupOperatorNameFromNetwork(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true);
+            shortName = lookupOperatorNameFromNetwork(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], false);
+            if (longName != null) {
+                strings[i + 0] = longName;
+            }
+            if (shortName != null) {
+                strings[i + 1] = shortName;
+            }
+            riljLog("lookupOperatorNameFromNetwork in responseOperatorInfosWithAct(),updated longAlpha= " + strings[i + 0] + ",shortAlpha= " + strings[i + 1] + ",numeric=" + strings[i + 2]);
+
+            // Not to show MVNO name for registered operator name display for certain SIM @{
+            // MTK TODO
+            /*
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                int phoneNum = TelephonyManager.getDefault().getPhoneCount();
+                int[] cardType = new int[phoneNum];
+                int targetCardType;
+                String strOperatorOverride = "";
+                boolean isCdma3GDualModeOr4GSim = false;
+                SpnOverride spnOverride = SpnOverride.getInstance();
+
+                if ((strings[i + 2].equals("45403")) || (strings[i + 2].equals("45404"))) {
+                    cardType = UiccController.getInstance().getC2KWPCardType();
+                    //FIX ME in svlte solution 2
+                    if (mInstanceId == PhoneConstants.SIM_ID_1) {
+                        targetCardType = cardType[PhoneConstants.SIM_ID_1];
+
+                        if (((targetCardType & UiccController.CARD_TYPE_RUIM) > 0 || (targetCardType & UiccController.CARD_TYPE_CSIM) > 0)
+                            && ((targetCardType & UiccController.CARD_TYPE_USIM) > 0)
+                            || SvlteUiccUtils.getInstance().isCt3gDualMode(
+                                    PhoneConstants.SIM_ID_1)) {
+                                isCdma3GDualModeOr4GSim = true;
+                        }
+
+                        if ((spnOverride != null) && (spnOverride.containsCarrierEx(strings[i + 2]))) {
+                            strOperatorOverride = spnOverride.getSpnEx(strings[i + 2]);
+                        }
+
+                        riljLog("targetCardType= " + targetCardType + " strOperatorOverride= " + strOperatorOverride
+                                + " isCdma3GDualModeOr4GSim=" + isCdma3GDualModeOr4GSim
+                                + " opNumeric= " + strings[i + 2]);
+
+                        if (isCdma3GDualModeOr4GSim == true) {
+                            riljLog("longAlpha: " + strings[i + 0] + " is overwritten to " + strOperatorOverride);
+                            strings[i + 0] = strOperatorOverride;
+                        }
+                    }
+                }
+            }
+            */
+            ///Not to show MVNO name for registered operator name display for certain SIM.@}
+
+
+            /* Operator name from SIM (EONS/CPHS) has highest priority to display. This will be handled in GsmSST updateSpnDisplay() */
+            /* ALPS00353868: To get operator name from OPL/PNN/CPHS, which need lac info */
+            // MTK TODO
+            /*
+            if ((lacValid == true) && (strings[i + 0] != null)) {
+                int phoneId = mInstanceId;
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                       phoneId = SvlteUtils.getSlotId(phoneId);
+                }
+                UiccController uiccController = UiccController.getInstance();
+                SIMRecords simRecord = (SIMRecords) uiccController.getIccRecords(mInstanceId, UiccController.APP_FAM_3GPP);
+                int lacValue = -1;
+                String sEons = null;
+                String lac = lacStr.substring(lacIndex, lacIndex + 4);
+                Rlog.d(RILJ_LOG_TAG, "lacIndex=" + lacIndex + " lacValue=" + lacValue + " lac=" + lac + " plmn numeric=" + strings[i + 2] + " plmn name" + strings[i + 0]);
+
+                if (lac != "") {
+                    lacValue = Integer.parseInt(lac, 16);
+                    lacIndex += 4;
+                    if (lacValue != 0xfffe) {
+                        sEons = simRecord.getEonsIfExist(strings[i + 2], lacValue, true);
+                        if (sEons != null) {
+                            strings[i + 0] = sEons;
+                            Rlog.d(RILJ_LOG_TAG, "plmn name update to Eons: " + strings[i + 0]);
+                        } else {
+                            //[ALPS01858353]-Start: The CPHS operator name shall only be used for HPLMN name dispaly
+                            String mSimOperatorNumeric = simRecord.getOperatorNumeric();
+                            if ((mSimOperatorNumeric != null) &&
+                                    (mSimOperatorNumeric.equals(strings[i + 2]))) {
+                                String sCphsOns = null;
+                                sCphsOns = simRecord.getSIMCPHSOns();
+                                if (sCphsOns != null) {
+                                    strings[i + 0] = sCphsOns;
+                                    Rlog.d(RILJ_LOG_TAG, "plmn name update to CPHS Ons: "
+                                            + strings[i + 0]);
+                                }
+                            }
+                            //[ALPS01858353]-End
+                        }
+                    } else {
+                        Rlog.d(RILJ_LOG_TAG, "invalid lac ignored");
+                    }
+                }
+            }
+            */
+            // ALPS00353868 END
+
+            /* ALPS01597054 Always show Act info(ex: "2G","3G","4G") for PLMN list result */
+            strings[i + 0] = strings[i + 0].concat(" " + strings[i + 4]);
+            strings[i + 1] = strings[i + 1].concat(" " + strings[i + 4]);
+
+            ret.add(
+                new OperatorInfo(
+                    strings[i + 0],
+                    strings[i + 1],
+                    strings[i + 2],
+                    strings[i + 3]));
+        }
+        return ret;
+    }
+
+    @Override
+    protected Object
+    responseCellList(Parcel p) {
+       int num, rssi;
+       String location;
+       ArrayList<NeighboringCellInfo> response;
+       NeighboringCellInfo cell;
+
+       num = p.readInt();
+       response = new ArrayList<NeighboringCellInfo>();
+
+       // ALPS00269882 START
+       // Get the radio access type
+       /*
+       int[] subId = SubscriptionManager.getSubId(mInstanceId);
+       int radioType =
+               ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).
+               getDataNetworkType(subId[0]);
+       */
+       int radioType = SystemProperties.getInt("gsm.enbr.rat", NETWORK_TYPE_GPRS);
+       riljLog("gsm.enbr.rat=" + radioType);
+       // ALPS00269882 END
+
+       // Interpret the location based on radio access type
+       if (radioType != NETWORK_TYPE_UNKNOWN) {
+           for (int i = 0 ; i < num ; i++) {
+               rssi = p.readInt();
+               location = p.readString();
+               cell = new NeighboringCellInfo(rssi, location, radioType);
+               response.add(cell);
+           }
+       }
+       return response;
+    }
+
+    protected Object responseSetPreferredNetworkType(Parcel p) {
+        int count = getRequestCount(RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE);
+        if (count == 0) {
+            Intent intent = new Intent(
+                    TelephonyIntents.ACTION_RAT_CHANGED);
+            intent.putExtra(PhoneConstants.PHONE_KEY, mInstanceId);
+            intent.putExtra(TelephonyIntents.EXTRA_RAT, mPreferredNetworkType);
+            mContext.sendBroadcast(intent);
+        }
+        riljLog("SetRatRequestCount: " + count);
+
+        return null;
+    }
+
+    private int getRequestCount(int reuestId) {
+        int count = 0;
+        synchronized (mRequestList) {
+            for (int i = 0, s = mRequestList.size() ; i < s ; i++) {
+                RILRequest rr = mRequestList.valueAt(i);
+                if (rr != null && rr.mRequest == reuestId) {
+                    count++;
+                }
+            }
+        }
+        return count;
+    }
+
+    //MTK-START Femtocell (CSG)
+    protected Object
+    responseFemtoCellInfos(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<FemtoCellInfo> ret;
+
+        if (strings.length % 6 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_GET_FEMTOCELL_LIST: invalid response. Got "
+                + strings.length + " strings, expected multible of 6");
+        }
+
+        ret = new ArrayList<FemtoCellInfo>(strings.length / 6);
+
+        /* <plmn numeric>,<act>,<plmn long alpha name>,<csgId>,,csgIconType>,<hnbName> */
+        for (int i = 0 ; i < strings.length ; i += 6) {
+            String actStr;
+            String hnbName;
+            int rat;
+
+            /* ALPS00273663 handle UCS2 format name : prefix + hex string ex: "uCs2806F767C79D1" */
+            if ((strings[i + 1] != null) && (strings[i + 1].startsWith("uCs2") == true))
+            {
+                Rlog.d(RILJ_LOG_TAG, "responseOperatorInfos handling UCS2 format name");
+
+                try {
+                    strings[i + 0] = new String(IccUtils.hexStringToBytes(strings[i + 1].substring(4)), "UTF-16");
+                } catch (UnsupportedEncodingException ex) {
+                    Rlog.d(RILJ_LOG_TAG, "responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+
+            if (strings[i + 1] != null && (strings[i + 1].equals("") || strings[i + 1].equals(strings[i + 0]))) {
+                Rlog.d(RILJ_LOG_TAG, "lookup RIL responseFemtoCellInfos() for plmn id= " + strings[i + 0]);
+                strings[i + 1] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 0], true, mContext);
+            }
+
+            if (strings[i + 2].equals("7")) {
+                actStr = "4G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_LTE;
+            } else if (strings[i + 2].equals("2")) {
+                actStr = "3G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_UMTS;
+            } else {
+                actStr = "2G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_GPRS;
+            }
+
+            //1 and 2 is 2g. above 2 is 3g
+            String property_name = "gsm.baseband.capability";
+            if (mInstanceId > PhoneConstants.SIM_ID_1) {
+                property_name = property_name + (mInstanceId + 1) ;
+            }
+
+            int basebandCapability = SystemProperties.getInt(property_name, 3);
+            Rlog.d(RILJ_LOG_TAG, "property_name=" + property_name + ",basebandCapability=" + basebandCapability);
+            if (3 < basebandCapability) {
+                strings[i + 1] = strings[i + 1].concat(" " + actStr);
+            }
+
+            hnbName = new String(IccUtils.hexStringToBytes(strings[i + 5]));
+
+            Rlog.d(RILJ_LOG_TAG, "FemtoCellInfo(" + strings[i + 3] + "," + strings[i + 4] + "," + strings[i + 5] + "," + strings[i + 0] + "," + strings[i + 1] + "," + rat + ")" + "hnbName=" + hnbName);
+
+            ret.add(
+                new FemtoCellInfo(
+                    Integer.parseInt(strings[i + 3]),
+                    Integer.parseInt(strings[i + 4]),
+                    hnbName,
+                    strings[i + 0],
+                    strings[i + 1],
+                    rat));
+        }
+
+        return ret;
+    }
+    //MTK-END Femtocell (CSG)
+
+    // xen0n refactored
+    @Override
+    public void requestIsimAuthentication(String nonce, Message response) {
+        if (SystemProperties.get("ro.mtk_tc1_feature").equals("1")) {
+            byte[] result = android.util.Base64.decode(nonce, android.util.Base64.DEFAULT);
+            StringBuilder mStringBuilder = new StringBuilder(result.length * 2);
+            for (byte mByte: result)
+               mStringBuilder.append(String.format("%02x", mByte & 0xff));
+            nonce = mStringBuilder.toString();
+            if (RILJ_LOGD) riljLog("requestIsimAuthentication - nonce = " + nonce);
+        }
+
+        super.requestIsimAuthentication(nonce, response);
+    }
+
+    /** M: add extra parameter */
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Message result) {
+        IaExtendParam param = new IaExtendParam();
+        setInitialAttachApn(apn, protocol, authType, username, password, (Object) param, result);
+    }
+
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_INITIAL_ATTACH_APN, null);
+
+        if (RILJ_LOGD) { riljLog("Set RIL_REQUEST_SET_INITIAL_ATTACH_APN"); }
+
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(protocol);
+        rr.mParcel.writeInt(authType);
+        rr.mParcel.writeString(username);
+        rr.mParcel.writeString(password);
+
+        /** M: start */
+        IaExtendParam param = (IaExtendParam) obj;
+        rr.mParcel.writeString(param.mOperatorNumeric);
+        rr.mParcel.writeInt(param.mCanHandleIms ? 1 : 0);
+        rr.mParcel.writeStringArray(param.mDualApnPlmnList);
+        /* M: end */
+
+        if (RILJ_LOGD) { riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", apn:" + apn + ", protocol:" + protocol + ", authType:" + authType
+                + ", username:" + username + ", password:" + password + " ," + param);
+        }
+
+        send(rr);
+    }
+
+    // xen0n: MTK REQUEST_SIM_GET_ATR has a different format, thus the AOSP
+    // impl has to be overriden.
+    @Override
+    public void getAtr(Message response) {
+        riljLog("getAtr: using MTK impl");
+        iccGetATR(response);
+    }
+
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_OPEN_ICC_APPLICATION, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(application);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", application = " + application);
+        send(rr);
+    }
+
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_ICC_APPLICATION_STATUS, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", session = " + sessionId);
+        send(rr);
+    }
+
+    //MTK-END Support Multi-Application
+
+    @Override public void
+    queryNetworkLock(int category, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("queryNetworkLock:" + category);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(category);
+
+        send(rr);
+    }
+
+    @Override public void
+    setNetworkLock(int catagory, int lockop, String password,
+                        String data_imsi, String gid1, String gid2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("setNetworkLock:" + catagory + ", " + lockop + ", " + password + ", " + data_imsi
+                + ", " + gid1 + ", " + gid2);
+
+        rr.mParcel.writeInt(6);
+        rr.mParcel.writeString(Integer.toString(catagory));
+        rr.mParcel.writeString(Integer.toString(lockop));
+        if (null != password) {
+            rr.mParcel.writeString(password);
+        } else {
+            rr.mParcel.writeString("");
+        }
+        rr.mParcel.writeString(data_imsi);
+        rr.mParcel.writeString(gid1);
+        rr.mParcel.writeString(gid2);
+
+        send(rr);
+    }
+
+    @Override public void
+    doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                         String param2, Message response) {
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GENERAL_SIM_AUTH, response);
+
+        rr.mParcel.writeInt(sessionId);
+        rr.mParcel.writeInt(mode);
+
+        // Calcuate param1 length in byte length
+        if (param1 != null && param1.length() > 0) {
+            String length = Integer.toHexString(param1.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param1 : (length + param1)));
+        } else {
+            rr.mParcel.writeString(param1);
+        }
+
+        // Calcuate param2 length in byte length
+        if (param2 != null && param2.length() > 0) {
+            String length = Integer.toHexString(param2.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param2 : (length + param2)));
+        } else {
+            rr.mParcel.writeString(param2);
+        }
+
+        if (mode == 1) {
+            rr.mParcel.writeInt(tag);
+        }
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " +
+            "session = " + sessionId + ",mode = " + mode + ",tag = " + tag + ", "  + param1 + ", " + param2);
+
+        send(rr);
+    }
+    // Added by M begin
+    @Override
+    public void
+    iccGetATR(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_GET_ATR, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    iccOpenChannelWithSw(String AID, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW, result);
+
+        rr.mParcel.writeString(AID);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccOpenChannelWithSw: " + requestToString(rr.mRequest)
+                + " " + AID);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response) {
+        if (RILJ_LOGD) riljLog(" sendBTSIMProfile nAction is " + nAction);
+        switch (nAction) {
+            case 0:
+                requestConnectSIM(response);
+                break;
+            case 1:
+                requestDisconnectOrPowerOffSIM(nAction, response);
+                break;
+            case 2:
+                requestPowerOnOrResetSIM(nAction, nType, response);
+                break;
+            case 3:
+                requestDisconnectOrPowerOffSIM(nAction, response);
+                break;
+            case 4:
+                requestPowerOnOrResetSIM(nAction, nType, response);
+                break;
+            case 5:
+                requestTransferApdu(nAction, nType, strData, response);
+                break;
+        }
+    }
+
+    //***** Private Methods
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestConnectSIM(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_CONNECT, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestDisconnectOrPowerOffSIM(int nAction, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF, response);
+
+         rr.mParcel.writeString(Integer.toString(nAction));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + nAction);
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestPowerOnOrResetSIM(int nAction, int nType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(Integer.toString(nAction));
+        rr.mParcel.writeString(Integer.toString(nType));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + nAction + " nType: " + nType);
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestTransferApdu(int nAction, int nType, String strData, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_TRANSFERAPDU, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(nAction));
+        rr.mParcel.writeString(Integer.toString(nType));
+        rr.mParcel.writeString(strData);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + nAction + " nType: " + nType + " data: " + strData);
+
+        send(rr);
+    }
+    // Added by M end
+
+    /**
+     * {@inheritDoc}
+     */
+    public void queryPhbStorageInfo(int type, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_PHB_STORAGE_INFO, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + type);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void writePhbEntry(PhbEntry entry, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_PHB_ENTRY, result);
+
+        rr.mParcel.writeInt(entry.type);
+        rr.mParcel.writeInt(entry.index);
+        rr.mParcel.writeString(entry.number);
+        rr.mParcel.writeInt(entry.ton);
+        rr.mParcel.writeString(entry.alphaId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + entry);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_PHB_ENTRY, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(type);
+        rr.mParcel.writeInt(bIndex);
+        rr.mParcel.writeInt(eIndex);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + type + " begin: " + bIndex + " end: " + eIndex);
+
+        send(rr);
+    }
+
+    private Object
+    responsePhbEntries(Parcel p) {
+        int numerOfEntries;
+        PhbEntry[] response;
+
+        numerOfEntries = p.readInt();
+        response = new PhbEntry[numerOfEntries];
+
+        Rlog.d(RILJ_LOG_TAG, "Number: " + numerOfEntries);
+
+        for (int i = 0; i < numerOfEntries; i++) {
+            response[i] = new PhbEntry();
+            response[i].type = p.readInt();
+            response[i].index = p.readInt();
+            response[i].number = p.readString();
+            response[i].ton = p.readInt();
+            response[i].alphaId = p.readString();
+        }
+
+        return response;
+    }
+
+    public void queryUPBCapability(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_UPB_CAPABILITY, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal, String tonForNum, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EDIT_UPB_ENTRY, response);
+        if (entryType == 0) {
+            rr.mParcel.writeInt(5);
+        } else {
+            rr.mParcel.writeInt(4);
+        }
+        rr.mParcel.writeString(Integer.toString(entryType));
+        rr.mParcel.writeString(Integer.toString(adnIndex));
+        rr.mParcel.writeString(Integer.toString(entryIndex));
+        rr.mParcel.writeString(strVal);
+
+        if (entryType == 0) {
+            rr.mParcel.writeString(tonForNum);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    public void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DELETE_UPB_ENTRY, response);
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(entryType);
+        rr.mParcel.writeInt(adnIndex);
+        rr.mParcel.writeInt(entryIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void readUPBGasList(int startIndex, int endIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_UPB_GAS_LIST, response);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(startIndex);
+        rr.mParcel.writeInt(endIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void readUPBGrpEntry(int adnIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_UPB_GRP, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(adnIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_UPB_GRP, response);
+        int nLen = grpIds.length;
+        rr.mParcel.writeInt(nLen + 1);
+        rr.mParcel.writeInt(adnIndex);
+        for (int i = 0; i < nLen; i++) {
+            rr.mParcel.writeInt(grpIds[i]);
+        }
+        if (RILJ_LOGD) riljLog("writeUPBGrpEntry nLen is " + nLen);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    private Object responseGetPhbMemStorage(Parcel p) {
+        /*
+        PBMemStorage response = PBMemStorage.createFromParcel(p);
+        riljLog("responseGetPhbMemStorage:" +  response);
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseGetPhbMemStorage: stub!");
+        return null;
+    }
+
+    // ALPS01977595 - KOR MVNO Operator Support
+    private Object responseReadPhbEntryExt(Parcel p) {
+        /*
+        int numerOfEntries;
+        PBEntry[] response;
+
+        numerOfEntries = p.readInt();
+        response = new PBEntry[numerOfEntries];
+
+        Rlog.d(RILJ_LOG_TAG, "responseReadPhbEntryExt Number: " + numerOfEntries);
+
+        for (int i = 0; i < numerOfEntries; i++) {
+            response[i] = new PBEntry();
+            response[i].setIndex1(p.readInt());
+            response[i].setNumber(p.readString());
+            response[i].setType(p.readInt());
+            response[i].setText(getAdnRecordFromPBEntry(p.readString()));
+            response[i].setHidden(p.readInt());
+            response[i].setGroup(p.readString());
+            response[i].setAdnumber(p.readString());
+            response[i].setAdtype(p.readInt());
+            response[i].setSecondtext(p.readString());
+            response[i].setEmail(getEmailRecordFromPBEntry(p.readString()));
+
+            Rlog.d(RILJ_LOG_TAG, "responseReadPhbEntryExt[" + i + "] " + response[i].toString());
+        }
+
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseReadPhbEntryExt: stub!");
+        return null;
+    }
+
+    public static String convertKSC5601(String input) {
+        Rlog.d(RILJ_LOG_TAG, "convertKSC5601");
+
+        String output = "";
+        try {
+            int    ucslen = 0;
+            byte[] inData = IccUtils.hexStringToBytes(input.substring(4));
+            if (inData != null)
+            {
+                String strKSC = new String(inData , "KSC5601");
+
+                if (strKSC != null) {
+                    ucslen = strKSC.length();
+                    while (ucslen > 0 && strKSC.charAt(ucslen - 1) == '\uF8F7')
+                        ucslen--;
+
+                    output = strKSC.substring(0, ucslen);
+                }
+            }
+        } catch (UnsupportedEncodingException ex) {
+            Rlog.d(RILJ_LOG_TAG, "Implausible UnsupportedEncodingException : " + ex);
+        }
+
+        return output;
+    }
+
+    public static String getEmailRecordFromPBEntry(String text) {
+        if (text == null)
+            return null;
+
+        String email = "";
+
+        if (text.trim().length() > 2 && text.startsWith("FEFE"))
+            email = convertKSC5601(text);
+        else
+            email = text;
+
+        Rlog.d(RILJ_LOG_TAG, "getEmailRecordFromPBEntry - email = " + email);
+
+        return email;
+    }
+
+    public static String getAdnRecordFromPBEntry(String text) {
+        if (text == null)
+            return null;
+
+        String alphaId = "";
+
+        if (text.trim().length() > 2 && text.startsWith("FEFE"))
+            alphaId = convertKSC5601(text);
+        else
+        {
+            Rlog.d(RILJ_LOG_TAG, "getRecordFromPBEntry - Not KSC5601 Data");
+            try {
+                byte[] ba = IccUtils.hexStringToBytes(text);
+                if (ba == null)
+                    return null;
+
+                alphaId = new String(ba, 0, text.length() / 2, "utf-16be");
+            } catch (UnsupportedEncodingException ex) {
+                Rlog.d(RILJ_LOG_TAG, "Implausible UnsupportedEncodingException : " + ex);
+            }
+        }
+
+        Rlog.d(RILJ_LOG_TAG, "getRecordFromPBEntry - alphaId = " + alphaId);
+
+        return alphaId;
+    }
+    // ALPS01977595 - KOR MVNO Operator Support
+
+    /**
+     * at+cpbr=?
+     * @return  <nlength><tlength><glength><slength><elength>
+     */
+    public void getPhoneBookStringsLength(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_PHB_STRING_LENGTH, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * at+cpbs?
+     * @return  PBMemStorage :: +cpbs:<storage>,<used>,<total>
+     */
+    public void getPhoneBookMemStorage(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_PHB_MEM_STORAGE, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * at+epin2=<p2>; at+cpbs=<storage>
+     * @return
+     */
+    public void setPhoneBookMemStorage(String storage, String password, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_PHB_MEM_STORAGE, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(storage);
+        rr.mParcel.writeString(password);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * M at+cpbr=<index1>,<index2>
+     * +CPBR:<indexn>,<number>,<type>,<text>,<hidden>,<group>,<adnumber>,<adtype>,<secondtext>,<email>
+     */
+    public void readPhoneBookEntryExt(int index1, int index2, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_PHB_ENTRY_EXT, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(index1);
+        rr.mParcel.writeInt(index2);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // MTK TODO
+    /**
+     * M AT+CPBW=<index>,<number>,<type>,<text>,<hidden>,<group>,<adnumber>,<adtype>,<secondtext>,<email>
+     */
+    /*
+    public void writePhoneBookEntryExt(PBEntry entry, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_PHB_ENTRY_EXT, result);
+
+        rr.mParcel.writeInt(entry.getIndex1());
+        rr.mParcel.writeString(entry.getNumber());
+        rr.mParcel.writeInt(entry.getType());
+        rr.mParcel.writeString(entry.getText());
+        rr.mParcel.writeInt(entry.getHidden());
+
+        rr.mParcel.writeString(entry.getGroup());
+        rr.mParcel.writeString(entry.getAdnumber());
+        rr.mParcel.writeInt(entry.getAdtype());
+        rr.mParcel.writeString(entry.getSecondtext());
+        rr.mParcel.writeString(entry.getEmail());
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + entry);
+
+        send(rr);
+    }
+    */
+
+    // MTK-START, SMS part
+    /**
+     * {@inheritDoc}
+     */
+    public void getSmsParameters(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SMS_PARAMS, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    private Object
+    responseSmsParams(Parcel p) {
+        /*
+        int format = p.readInt();
+        int vp = p.readInt();
+        int pid = p.readInt();
+        int dcs = p.readInt();
+
+        return new SmsParameters(format, vp, pid, dcs);
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseSmsParams: stub!");
+        return null;
+    }
+
+    // MTK TODO
+    /**
+     * {@inheritDoc}
+     */
+    /*
+    public void setSmsParameters(SmsParameters params, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SMS_PARAMS, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(4);
+        rr.mParcel.writeInt(params.format);
+        rr.mParcel.writeInt(params.vp);
+        rr.mParcel.writeInt(params.pid);
+        rr.mParcel.writeInt(params.dcs);
+
+        send(rr);
+    }
+    */
+
+    /**
+     * {@inheritDoc}
+     */
+    public void getSmsSimMemoryStatus(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SMS_SIM_MEM_STATUS, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    private Object responseSimSmsMemoryStatus(Parcel p) {
+        IccSmsStorageStatus response;
+
+        response = new IccSmsStorageStatus();
+        response.mUsed = p.readInt();
+        response.mTotal = p.readInt();
+        return response;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setEtws(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ETWS, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                mode);
+
+        send(rr);
+    }
+
+    public void setCellBroadcastChannelConfigInfo(String config, int cb_set_type,
+            Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(config);
+        rr.mParcel.writeString(Integer.toString(cb_set_type));
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setCellBroadcastLanguageConfigInfo(String config, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO, response);
+
+        rr.mParcel.writeString(config);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void queryCellBroadcastConfigInfo(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_CB_CONFIG_INFO, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    private Object responseCbConfig(Parcel p) {
+        /*
+        int mode            = p.readInt();
+        String channels     = p.readString();
+        String languages    = p.readString();
+        boolean allOn       = (p.readInt() == 1) ? true : false;
+
+        return new CellBroadcastConfigInfo(mode, channels, languages, allOn);
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseCbConfig: stub!");
+        return null;
+    }
+
+    public void removeCellBroadcastMsg(int channelId, int serialId, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_CB_MESSAGE, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(channelId);
+        rr.mParcel.writeInt(serialId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+            channelId + ", " + serialId);
+
+        send(rr);
+    }
+
+    private Object responseEtwsNotification(Parcel p) {
+        // MTK TODO
+        /*
+        EtwsNotification response = new EtwsNotification();
+
+        response.warningType = p.readInt();
+        response.messageId = p.readInt();
+        response.serialNumber = p.readInt();
+        response.plmnId = p.readString();
+        response.securityInfo = p.readString();
+
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseEtwsNotification: stub!");
+        return null;
+    }
+    // MTK-END, SMS part
+
+    public void setTrm(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_TRM, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void queryModemType(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_MODEM_TYPE, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void storeModemType(int modemType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_STORE_MODEM_TYPE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(modemType);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void reloadModemType(int modemType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RELOAD_MODEM_TYPE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(modemType);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setStkEvdlCallByAP(int enabled, Message response) {
+        RILRequest rr =
+                //RILRequest.obtain(RIL_REQUEST_STK_EVDL_CALL_BY_AP, response, mySimId);
+                RILRequest.obtain(RIL_REQUEST_STK_EVDL_CALL_BY_AP, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + ">>> " + requestToString(rr.mRequest));
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled);
+        send(rr);
+    }
+
+    /// M: CC053: MoMS [Mobile Managerment] @{
+    // 3. Permission Control for Conference call
+    /**
+    * To check sub-permission for MoMS before using API.
+    *
+    * @param subPermission  The permission to be checked.
+    *
+    * @return Return true if the permission is granted else return false.
+    */
+    private boolean checkMoMSSubPermission(String subPermission) {
+        riljLog("MoMS: no-op!");
+        /*
+        try {
+            IMobileManagerService mMobileManager;
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            mMobileManager = IMobileManagerService.Stub.asInterface(binder);
+            int result = mMobileManager.checkPermission(subPermission, Binder.getCallingUid());
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                riljLog("[Error]Subpermission is not granted!!");
+                return false;
+            }
+        } catch (Exception e) {
+            riljLog("[Error]Failed to chcek permission: " +  subPermission);
+            return false;
+        }
+        */
+
+        return true;
+    }
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    private Object
+    responseCrssNotification(Parcel p) {
+        // MTK TODO
+        /*
+        SuppCrssNotification notification = new SuppCrssNotification();
+
+        notification.code = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+        notification.alphaid = p.readString();
+        notification.cli_validity = p.readInt();
+
+        return notification;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseCrssNotification: stub!");
+        return null;
+    }
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    public void
+    hangupAll(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_ALL,
+                                        result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void forceReleaseCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_FORCE_RELEASE_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + index);
+
+        send(rr);
+    }
+
+    public void setCallIndication(int mode, int callId, int seqNumber, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_CALL_INDICATION, result);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(mode);
+        rr.mParcel.writeInt(callId);
+        rr.mParcel.writeInt(seqNumber);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + mode + ", " + callId + ", " + seqNumber);
+
+        send(rr);
+    }
+
+    // ported from CM12.1 MediaTekRIL
+    private void setCallIndication(final String[] incomingCallInfo) {
+        final int callId = Integer.parseInt(incomingCallInfo[0]);
+        final int callMode = Integer.parseInt(incomingCallInfo[3]);
+        final int seqNumber = Integer.parseInt(incomingCallInfo[4]);
+        // just call into the MTK impl
+        setCallIndication(callMode, callId, seqNumber, null);
+    }
+
+    public void
+    emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EMERGENCY_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+        rr.mParcel.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void
+    conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFERENCE_DIAL, result);
+
+        int numberOfParticipants = participants.length;
+        /* numberOfStrings is including
+         * 1. isvideoCall
+         * 2. numberofparticipants
+         * 3. participants numbers
+         * 4. clirmod
+         */
+        int numberOfStrings = 1 + 1 + numberOfParticipants + 1 ;
+        List<String> participantList = Arrays.asList(participants);
+
+        if (RILJ_LOGD) {
+            Rlog.d(RILJ_LOG_TAG, "conferenceDial: numberOfParticipants "
+                    + numberOfParticipants + "numberOfStrings:" + numberOfStrings);
+        }
+
+        rr.mParcel.writeInt(numberOfStrings);
+
+        if (isVideoCall) {
+            rr.mParcel.writeString(Integer.toString(1));
+        } else {
+            rr.mParcel.writeString(Integer.toString(0));
+        }
+
+        rr.mParcel.writeString(Integer.toString(numberOfParticipants));
+
+        for (String dialNumber : participantList) {
+            rr.mParcel.writeString(dialNumber);
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "conferenceDial: dialnumber " + dialNumber);
+            }
+        }
+        rr.mParcel.writeString(Integer.toString(clirMode));
+        if (RILJ_LOGD) {
+            Rlog.d(RILJ_LOG_TAG, "conferenceDial: clirMode " + clirMode);
+        }
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+
+    }
+    /* IMS VoLTE conference dial feature end*/
+
+    public void setEccServiceCategory(int serviceCategory) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_SERVICE_CATEGORY, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(serviceCategory);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + serviceCategory);
+
+        send(rr);
+    }
+
+    private void setEccList() {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_LIST, null);
+        ArrayList<PhoneNumberUtils.EccEntry> eccList = PhoneNumberUtils.getEccList();
+
+        rr.mParcel.writeInt(eccList.size() * 3);
+        for (PhoneNumberUtils.EccEntry entry : eccList) {
+            rr.mParcel.writeString(entry.getEcc());
+            rr.mParcel.writeString(entry.getCategory());
+            String strCondition = entry.getCondition();
+            if (strCondition.equals(PhoneNumberUtils.EccEntry.ECC_FOR_MMI))
+                strCondition = PhoneNumberUtils.EccEntry.ECC_NO_SIM;
+            rr.mParcel.writeString(strCondition);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SPEECH_CODEC_INFO,
+                response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enable ? 1 : 0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + enable);
+        send(rr);
+    }
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void
+    vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VT_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    acceptVtCallWithVoiceOnly(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_ACCEPT, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void replaceVtCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_REPLACE_VT_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: IMS feature. @{
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToAdd));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToRemove));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_CALL, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callIdToResume);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HOLD_CALL, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callIdToHold);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+    /// @}
+
+    /* M: SS part */
+    public void
+    changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm, Message result) {
+        //RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result, mySimId);
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(4);
+        rr.mParcel.writeString(facility);
+        rr.mParcel.writeString(oldPwd);
+        rr.mParcel.writeString(newPwd);
+        rr.mParcel.writeString(newCfm);
+        send(rr);
+    }
+
+    public void setCLIP(boolean enable, Message result) {
+        //RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CLIP, result, mySimId);
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CLIP, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + enable);
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    /* M: Network part start */
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName) {
+        int phoneId = SubscriptionManager.getPhoneId((int) subId);
+        String nitzOperatorNumeric = null;
+        String nitzOperatorName = null;
+
+        nitzOperatorNumeric = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_CODE, "");
+        if ((numeric != null) && (numeric.equals(nitzOperatorNumeric))) {
+            if (desireLongName == true) {
+                nitzOperatorName = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_LNAME, "");
+            } else {
+                nitzOperatorName = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_SNAME, "");
+            }
+        }
+
+        /* ALPS00273663 handle UCS2 format name : prefix + hex string ex: "uCs2806F767C79D1" */
+        if ((nitzOperatorName != null) && (nitzOperatorName.startsWith("uCs2") == true))
+        {
+            riljLog("lookupOperatorNameFromNetwork handling UCS2 format name");
+            try {
+                nitzOperatorName = new String(IccUtils.hexStringToBytes(nitzOperatorName.substring(4)), "UTF-16");
+            } catch (UnsupportedEncodingException ex) {
+                riljLog("lookupOperatorNameFromNetwork UnsupportedEncodingException");
+            }
+        }
+
+        riljLog("lookupOperatorNameFromNetwork numeric= " + numeric + ",subId= " + subId + ",nitzOperatorNumeric= " + nitzOperatorNumeric + ",nitzOperatorName= " + nitzOperatorName);
+
+        return nitzOperatorName;
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManualWithAct(String operatorNumeric, String act, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric + "" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(act);
+        rr.mParcel.writeString("0"); //the 3rd parameter is for MTK RIL to identify it shall be processed as semi auto network selection mode or not
+
+        send(rr);
+    }
+
+    private Object
+    responseNetworkInfoWithActs(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<NetworkInfoWithAcT> ret;
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_GET_POL_LIST: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<NetworkInfoWithAcT>(strings.length / 4);
+
+        String strOperName = null;
+        String strOperNumeric = null;
+        int nAct = 0;
+        int nIndex = 0;
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            strOperName = null;
+            strOperNumeric = null;
+            if (strings[i] != null) {
+                nIndex = Integer.parseInt(strings[i]);
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: no invalid index. i is " + i);
+            }
+
+            if (strings[i + 1] != null) {
+                int format = Integer.parseInt(strings[i + 1]);
+                switch (format) {
+                    case 0:
+                    case 1:
+                        strOperName = strings[i + 2];
+                        break;
+                    case 2:
+                        if (strings[i + 2] != null) {
+                            strOperNumeric = strings[i + 2];
+                            strOperName = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true, mContext);
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            if (strings[i + 3] != null) {
+                nAct = Integer.parseInt(strings[i + 3]);
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: no invalid Act. i is " + i);
+            }
+            if (strOperNumeric != null && !strOperNumeric.equals("?????")) {
+                ret.add(
+                    new NetworkInfoWithAcT(
+                        strOperName,
+                        strOperNumeric,
+                        nAct,
+                        nIndex));
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: invalid oper. i is " + i);
+            }
+        }
+
+        return ret;
+    }
+
+    public void
+    setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric + "" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(act);
+        rr.mParcel.writeString("1"); //the 3rd parameter is for MTK RIL to identify it shall be processed as semi auto network selection mode
+
+        send(rr);
+    }
+
+    public void getPOLCapabilty(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_POL_CAPABILITY, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void getCurrentPOLList(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_POL_LIST, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setPOLEntry(int index, String numeric, int nAct, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_POL_ENTRY, response);
+        if (numeric == null || (numeric.length() == 0)) {
+            rr.mParcel.writeInt(1);
+            rr.mParcel.writeString(Integer.toString(index));
+        } else {
+            rr.mParcel.writeInt(3);
+            rr.mParcel.writeString(Integer.toString(index));
+            rr.mParcel.writeString(numeric);
+            rr.mParcel.writeString(Integer.toString(nAct));
+        }
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // Femtocell (CSG) feature START
+    public void getFemtoCellList(String operatorNumeric, int rat, Message response) {
+        RILRequest rr
+        = RILRequest.obtain(RIL_REQUEST_GET_FEMTOCELL_LIST,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(Integer.toString(rat));
+        send(rr);
+    }
+
+    public void abortFemtoCellList(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ABORT_FEMTOCELL_LIST, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void selectFemtoCell(FemtoCellInfo femtocell, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SELECT_FEMTOCELL,
+                                    response);
+        int act = femtocell.getCsgRat();
+
+        if (act == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
+            act = 7;
+        } else if (act == ServiceState.RIL_RADIO_TECHNOLOGY_UMTS) {
+            act = 2;
+        } else {
+            act = 0;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " csgId=" + femtocell.getCsgId() + " plmn=" + femtocell.getOperatorNumeric() + " rat=" + femtocell.getCsgRat() + " act=" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(femtocell.getOperatorNumeric());
+        rr.mParcel.writeString(Integer.toString(act));
+        rr.mParcel.writeString(Integer.toString(femtocell.getCsgId()));
+
+        send(rr);
+    }
+    // Femtocell (CSG) feature END
+
+    // M: CC33 LTE.
+    @Override
+    public void
+    setDataOnToMD(boolean enable, Message result) {
+        //AT+EDSS = <on/off>
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_ON_TO_MD, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    @Override
+    public void
+    setRemoveRestrictEutranMode(boolean enable, Message result) {
+        //AT+ECODE33 = <on/off>
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    @Override
+    public void
+    setLteAccessStratumReport(boolean enable, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    @Override
+    public void
+    setLteUplinkDataTransfer(int state, int interfaceId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(state);
+        rr.mParcel.writeInt(interfaceId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest)
+                                + " state = " + state
+                                + ", interfaceId = " + interfaceId);
+        send(rr);
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    public boolean isGettingAvailableNetworks() {
+        synchronized (mRequestList) {
+            for (int i = 0, s = mRequestList.size() ; i < s ; i++) {
+                RILRequest rr = mRequestList.valueAt(i);
+                if (rr != null &&
+                    (rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS ||
+                     rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /* M: Network part end */
+    // IMS
+    public void setIMSEnabled(boolean enable, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SCRI, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(forceRelease ? 1 : 0);
+
+        send(rr);
+
+    }
+
+    //[New R8 modem FD]
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FD_MODE, response);
+
+        //AT+EFD=<mode>[,<param1>[,<param2>]]
+        //mode=0:disable modem Fast Dormancy; mode=1:enable modem Fast Dormancy
+        //mode=3:inform modem the screen status; parameter1: screen on or off
+        //mode=2:Fast Dormancy inactivity timer; parameter1:timer_id; parameter2:timer_value
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        if (mode == 0 || mode == 1) {
+            rr.mParcel.writeInt(1);
+            rr.mParcel.writeInt(mode);
+        } else if (mode == 3) {
+            rr.mParcel.writeInt(2);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+        } else if (mode == 2) {
+            rr.mParcel.writeInt(3);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+            rr.mParcel.writeInt(parameter2);
+        }
+
+        send(rr);
+
+    }
+
+    // @argument:
+    // enable: yes   -> data centric
+    //         false -> voice centric
+    public void setDataCentric(boolean enable, Message response) {
+        if (RILJ_LOGD) riljLog("setDataCentric");
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_CENTRIC, response);
+
+        rr.mParcel.writeInt(1);
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     * Notify modem about IMS call status.
+     * @param existed True if there is at least one IMS call existed, else return false.
+     * @param response User-defined message code.
+     */
+    @Override
+    public void setImsCallStatus(boolean existed, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_CALL_STATUS, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(existed ? 1 : 0);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to CS modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     @Override
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER, null);
+
+        if ((numberOfCall <= 0) || (callList == null)) {
+              return;
+        }
+
+        rr.mParcel.writeInt(numberOfCall * 9 + 1);
+        rr.mParcel.writeString(Integer.toString(numberOfCall));
+        for (int i = 0; i < numberOfCall; i++) {
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallId()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallMode()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallDirection()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallState()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getEccCategory()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getNumberType()));
+            rr.mParcel.writeString(callList[i].getNumber());
+            rr.mParcel.writeString(callList[i].getName());
+            rr.mParcel.writeString(Integer.toString(callList[i].getCliValidity()));
+        }
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+     }
+
+     /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS, null);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(regState);
+        rr.mParcel.writeInt(regType);
+        rr.mParcel.writeInt(reason);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+     }
+     /// @}
+
+    /* M: C2K part start */
+    @Override
+    public void setViaTRM(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_VIA_TRM, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void getNitzTime(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_GET_NITZ_TIME, result);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void requestSwitchHPF(boolean enableHPF, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SWITCH_HPF, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + enableHPF);
+        }
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enableHPF ? 1 : 0);
+
+        send(rr);
+    }
+
+    @Override
+    public void setAvoidSYS(boolean avoidSYS, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_AVOID_SYS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + avoidSYS);
+        }
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(avoidSYS ? 1 : 0);
+
+        send(rr);
+    }
+
+    @Override
+    public void getAvoidSYSList(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_AVOID_SYS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMANetworkInfo(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_CDMA_NETWORK_INFO, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void setOplmn(String oplmnInfo, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_OPLMN, response);
+        rr.mParcel.writeString(oplmnInfo);
+        riljLog("sendOplmn, OPLMN is" + oplmnInfo);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void getOplmnVersion(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_OPLMN_VERSION, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSTcpConnected(int connected, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_TCP_CONNIND, result);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(connected);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + connected);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSSetMpcIpPort(String ip, String port, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_SET_MPC_IPPORT, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(ip);
+        rr.mParcel.writeString(port);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " : " + ip + ", " + port);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSGetMpcIpPort(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_GET_MPC_IPPORT, result);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestSetEtsDev(int dev, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ETS_DEV, result);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(dev);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + dev);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setArsiReportThreshold(int threshold, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_ARSI_THRESHOLD, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(threshold);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + threshold);
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMASmsAndPBStatus(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMANetWorkRegistrationState(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_NETWORK_REGISTRATION, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void setMeid(String meid, Message response) {
+        RILRequest rr
+               = RILRequest.obtain(RIL_REQUEST_SET_MEID, response);
+
+       rr.mParcel.writeString(meid);
+       if (RILJ_LOGD) {
+           riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + meid);
+       }
+
+       send(rr);
+   }
+
+    @Override
+    public void setMdnNumber(String mdn, Message response) {
+         RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_WRITE_MDN, response);
+
+        rr.mParcel.writeString(mdn);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + mdn);
+        }
+
+        send(rr);
+    }
+
+    private Object responseGetNitzTime(Parcel p) {
+        Object[] result = new Object[2];
+        String response;
+
+        response = p.readString();
+        long nitzReceiveTime = p.readLong();
+        result[0] = response;
+        result[1] = Long.valueOf(nitzReceiveTime);
+
+        return result;
+    }
+
+    /// M: UTK started @{
+    @Override
+    public void getUtkLocalInfo(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_LOCAL_INFO, result);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void requestUtkRefresh(int refreshType, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_UTK_REFRESH, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(refreshType);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void reportUtkServiceIsRunning(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, result);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void profileDownload(String profile, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_STK_SET_PROFILE, response);
+
+        rr.mParcel.writeString(profile);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        RILRequest rr = RILRequest.obtain(
+            RILConstants.RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM,
+            response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(accept ? 1 : 0);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + (accept ? 1 : 0));
+        }
+
+        send(rr);
+    }
+    /// UTK end @}
+
+    ///M: [C2K][SVLTE] Removt SIM access feature @{
+    @Override
+    public void configModemStatus(int modemStatus, int remoteSimProtocol, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFIG_MODEM_STATUS, result);
+
+        // count ints
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(modemStatus);
+        rr.mParcel.writeInt(remoteSimProtocol);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + modemStatus + ", " + remoteSimProtocol);
+        }
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: [C2K][SVLTE] C2K SVLTE CDMA eHPRD control @{
+    @Override
+    public void configEvdoMode(int evdoMode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFIG_EVDO_MODE, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(evdoMode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + evdoMode);
+        }
+
+        send(rr);
+    }
+    /// @}
+
+    ///M: [C2K][IRAT] code start @{
+    @Override
+    public void confirmIratChange(int apDecision, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE,
+                response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(apDecision);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + apDecision);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestSetPsActiveSlot(int psSlot, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_ACTIVE_PS_SLOT, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(psSlot);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + psSlot);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void syncNotifyDataCallList(AsyncResult dcList) {
+        riljLog("[C2K_IRAT_RIL] notify data call list!");
+        mDataNetworkStateRegistrants.notifyRegistrants(dcList);
+    }
+
+    @Override
+    public void requestDeactivateLinkDownPdn(Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN, response);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    private Object responseIratStateChange(Parcel p) {
+        // MTK TODO
+        /*
+        MdIratInfo pdnIratInfo = new MdIratInfo();
+        pdnIratInfo.sourceRat = p.readInt();
+        pdnIratInfo.targetRat = p.readInt();
+        pdnIratInfo.action = p.readInt();
+        pdnIratInfo.type = IratType.getIratTypeFromInt(p.readInt());
+        riljLog("[C2K_IRAT_RIL]responseIratStateChange: pdnIratInfo = " + pdnIratInfo);
+        return pdnIratInfo;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseIratStateChange: stub!");
+        return null;
+    }
+    ///@} [C2K] IRAT code end
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    @Override
+    public void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_SVLTE_RAT_MODE, response);
+        rr.mParcel.writeInt(6);
+        rr.mParcel.writeInt(radioTechMode);
+        rr.mParcel.writeInt(preSvlteMode);
+        rr.mParcel.writeInt(svlteMode);
+        rr.mParcel.writeInt(preRoamingMode);
+        rr.mParcel.writeInt(roamingMode);
+        rr.mParcel.writeInt(is3GDualModeCard ? 1 : 0);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " radioTechMode: " + radioTechMode
+                    + " preSvlteMode: " + preSvlteMode + " svlteMode: " + svlteMode
+                    + " preRoamingMode: " + preRoamingMode + " roamingMode: " + roamingMode
+                    + " is3GDualModeCard: " + is3GDualModeCard);
+        }
+        send(rr);
+    }
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+    @Override
+    public void setStkUtkMode(int stkUtkMode, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_STK_UTK_MODE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(stkUtkMode);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " stkUtkMode: " + stkUtkMode);
+        }
+        send(rr);
+    }
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    @Override
+    public void setInstanceId(int instanceId) {
+        mInstanceId = instanceId;
+    }
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    @Override
+    public void setRegistrationSuspendEnabled(int enabled, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REG_SUSPEND_ENABLED, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_REGISTRATION, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled ? 1 : 0);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable=" + enabled);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setResumeCdmaRegistration(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_REGISTRATION_CDMA, response);
+        mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /* M: C2K part end */
+
+    //[ALPS01810775,ALPS01868743]-Start
+    public int getDisplayState() {
+        return mDefaultDisplayState;
+    }
+    //[ALPS01810775,ALPS01868743]-End
+
+    // M: [C2K] SVLTE Remote SIM Access start.
+    private int getFullCardType(int slot) {
+        String cardType;
+        if (slot == 0) {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType slot0");
+            cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[0]);
+        } else if (slot == 1) {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType slot1");
+            cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[1]);
+        } else {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType invalid slotId = " + slot);
+            return 0;
+        }
+        Rlog.d(RILJ_LOG_TAG, "getFullCardType=" + cardType);
+        String appType[] = cardType.split(",");
+        int fullType = 0;
+        for (int i = 0; i < appType.length; i++) {
+            if ("USIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_USIM;
+            } else if ("SIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_SIM;
+            } else if ("CSIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_CSIM;
+            } else if ("RUIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_RUIM;
+            }
+        }
+        Rlog.d(RILJ_LOG_TAG, "fullType=" + fullType);
+        return fullType;
+    }
+
+    /**
+     * Set the xTK mode.
+     * @param mode The xTK mode.
+     */
+    public void setStkSwitchMode(int mode) { // Called by SvlteRatController
+        if (RILJ_LOGD) {
+            riljLog("setStkSwitchMode=" + mode + " old value=" + mStkSwitchMode);
+        }
+        mStkSwitchMode = mode;
+    }
+
+    /**
+     * Set the UTK Bip Ps type .
+     * @param mBipPsType The Bip type.
+     */
+    public void setBipPsType(int type) { // Called by SvltePhoneProxy
+        if (RILJ_LOGD) {
+            riljLog("setBipPsType=" + type + " old value=" + mBipPsType);
+        }
+        mBipPsType = type;
+    }
+    // M: [C2K] SVLTE Remote SIM Access end.
+
+    /**
+     * Switch antenna.
+     * @param callState call state, 0 means call disconnected and 1 means call established.
+     * @param ratMode RAT mode, 0 means GSM and 7 means C2K.
+     */
+    @Override
+    public void switchAntenna(int callState, int ratMode) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SWITCH_ANTENNA, null);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(callState);
+        rr.mParcel.writeInt(ratMode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " callState: " + callState
+                + ", ratMode:" + ratMode);
+        }
+
+        send(rr);
+    }
+
+    /**
+     * Switch RUIM card to SIM or switch SIM to RUIM.
+     * @param cardtype that to be switched.
+     */
+    public void switchCardType(int cardtype) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SWITCH_CARD_TYPE, null);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(cardtype);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " cardtype: " + cardtype);
+        }
+        send(rr);
+    }
+
+    /**
+     * Enable or disable MD3 Sleep.
+     * @param enable MD3 sleep.
+     */
+    public void enableMd3Sleep(int enable) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENABLE_MD3_SLEEP, null);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enable);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " enable MD3 sleep: " + enable);
+        }
+        send(rr);
+    }
+}
diff --git a/src/java/com/android/internal/telephony/PhbEntry.java b/src/java/com/android/internal/telephony/PhbEntry.java
new file mode 100755
index 0000000..cefc222
--- /dev/null
+++ b/src/java/com/android/internal/telephony/PhbEntry.java
@@ -0,0 +1,71 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+/**
+ * See also RIL_PhbEntryStrucutre in include/telephony/ril.h
+ *
+ * {@hide}
+ */
+public class PhbEntry {
+    public int type;
+    public int index;
+    public String number;
+    public int ton;
+    public String alphaId;
+
+    public String toString() {
+        return super.toString() + "type: " + type + " index: " + index
+            + " number: " + number + " ton: " + ton + " alphaId: " + alphaId;
+    }
+}
+
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 4b6f9ad..167e471 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -45,6 +45,21 @@ import com.android.internal.telephony.uicc.IccCardProxy;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.IndentingPrintWriter;
 
+import com.mediatek.internal.telephony.NetworkManager;
+import com.mediatek.internal.telephony.RadioManager;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.LteDcPhoneProxy;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteDcPhone;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteRoamingController;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccController;
+import com.mediatek.internal.telephony.worldphone.IWorldPhone;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneWrapper;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.HashMap;
@@ -80,6 +95,29 @@ public class PhoneFactory {
 
     static private final HashMap<String, LocalLog>sLocalLogs = new HashMap<String, LocalLog>();
 
+    // MTK
+    // static private SvlteUiccController sSvlteUiccController;  // MTK TODO
+    // MTK-END, Refine SVLTE remote SIM APP type, 2015/04/29
+    //MTK-START [mtk06800]  RadioManager for proprietary power on flow
+    static private RadioManager mRadioManager;
+    //MTK-END [mtk06800]  RadioManager for proprietary power on flow
+    static private NetworkManager mNetworkManager;
+
+    static private IWorldPhone sWorldPhone = null;
+
+    /* C2K support start */
+    static final String EVDO_DT_SUPPORT = "ril.evdo.dtsupport";
+
+    // MTK TODO
+    /*
+    // SVLTE RIL instance
+    static private CommandsInterface[] sCommandsInterfaceLteDcs;
+    // SVLTE LTE dual connection PhoneProxy
+    static private LteDcPhoneProxy[] sLteDcPhoneProxys;
+    static private int sActiveSvlteModeSlotId;
+    */
+    /* C2K support end */
+
     //***** Class Methods
 
     public static void makeDefaultPhones(Context context) {
@@ -144,12 +182,32 @@ public class PhoneFactory {
                 int[] networkModes = new int[numPhones];
                 sProxyPhones = new PhoneProxy[numPhones];
                 sCommandsInterfaces = new RIL[numPhones];
+                /// M: SVLTE solution2 modify, expand to object array
+                /// and get active svlte mode slot id. @{
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    sLteDcPhoneProxys = new SvltePhoneProxy[numPhones];
+                    sCommandsInterfaceLteDcs = new CommandsInterface[numPhones];
+                    sActiveSvlteModeSlotId = SvlteModeController.getActiveSvlteModeSlotId();
+                    SvlteModeController.setCdmaSocketSlotId(sActiveSvlteModeSlotId
+                            == SvlteModeController.CSFB_ON_SLOT
+                            ? PhoneConstants.SIM_ID_1 : sActiveSvlteModeSlotId);
+                }
+                */
+                /// @}
+                //[ALPS01784188]
+                int capabilityPhoneId = Integer.valueOf(
+                        SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1"));
+
                 String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
                 Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
 
                 for (int i = 0; i < numPhones; i++) {
                     // reads the system properties and makes commandsinterface
                     // Get preferred network type.
+                    // MTK
+                    /*
                    try {
                         networkModes[i]  = TelephonyManager.getIntAtIndex(
                                 context.getContentResolver(),
@@ -160,6 +218,41 @@ public class PhoneFactory {
                         networkModes[i] = preferredNetworkMode;
                     }
                     Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
+                    */
+
+                    // EVDO project need phone type to be C+G
+                    if (CdmaFeatureOptionUtils.isEvdoDTSupport()) {
+                        try {
+                            networkModes[i] =
+                                    TelephonyManager.getIntAtIndex(context.getContentResolver(),
+                                    Settings.Global.PREFERRED_NETWORK_MODE, i);
+                        } catch (SettingNotFoundException snfe) {
+                            Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for"
+                                    + " Settings.Global.PREFERRED_NETWORK_MODE");
+                            networkModes[i] = preferredNetworkMode;
+                        }
+                        // workaround for cannot get phone 1 network mode
+                        if (i == 1) {
+                            networkModes[i] = RILConstants.NETWORK_MODE_GSM_ONLY;
+                        }
+                        Rlog.i(LOG_TAG, "EVDO Network Mode set to " +
+                        Integer.toString(networkModes[i]));
+                    } else {
+                        if (i == (capabilityPhoneId - 1)) {
+                            networkModes[i] = calculatePreferredNetworkType(context);
+                        } else {
+                            networkModes[i] = RILConstants.NETWORK_MODE_GSM_ONLY;
+                        }
+                        /// M: SVLTE solution2 modify, calculate network type for SVLTE @{
+                        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                            networkModes[i] = calculateNetworkType(context, i);
+                        }
+                        /// @}
+                    }
+                    Rlog.i(LOG_TAG, "RILJ Sub = " + i);
+                    Rlog.i(LOG_TAG, "capabilityPhoneId=" + capabilityPhoneId
+                            + " Network Mode set to " + Integer.toString(networkModes[i]));
+
                     // Use reflection to construct the RIL class (defaults to RIL)
                     try {
                         sCommandsInterfaces[i] = instantiateCustomRIL(
@@ -183,6 +276,23 @@ public class PhoneFactory {
                 // call getInstance()
                 mUiccController = UiccController.make(context, sCommandsInterfaces);
 
+                // MTK-START, Refine SVLTE remote SIM APP type, 2015/04/29
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    sSvlteUiccController = SvlteUiccController.make();
+                }
+                */
+                // MTK-END, Refine SVLTE remote SIM APP type, 2015/04/29
+                //MTK-START [mtk06800] create RadioManager for proprietary power on flow
+                mRadioManager = RadioManager.init(context, numPhones, sCommandsInterfaces);
+                //MTK-END [mtk06800] create RadioManager for proprietary power on flow
+                mNetworkManager = NetworkManager.init(context, numPhones, sCommandsInterfaces);
+
+                // MTK SVLTE
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    svlteInit(context);
+                } else {
                 for (int i = 0; i < numPhones; i++) {
                     PhoneBase phone = null;
                     int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
@@ -197,6 +307,7 @@ public class PhoneFactory {
 
                     sProxyPhones[i] = TelephonyPluginDelegate.getInstance().makePhoneProxy(phone);
                 }
+                }  // MTK
                 mProxyController = ProxyController.getInstance(context, sProxyPhones,
                         mUiccController, sCommandsInterfaces);
 
@@ -241,6 +352,18 @@ public class PhoneFactory {
                         sProxyPhones[i].setPreferredNetworkType(userNwType, null);
                     }
                 }
+
+                // MTK
+                //[WorldMode]
+                if (WorldPhoneUtil.isWorldModeSupport() && WorldPhoneUtil.isWorldPhoneSupport()) {
+                    Rlog.i(LOG_TAG, "World mode support");
+                    WorldMode.init();
+                } else if (WorldPhoneUtil.isWorldPhoneSupport()) {
+                    Rlog.i(LOG_TAG, "World phone support");
+                    sWorldPhone = WorldPhoneWrapper.getWorldPhoneInstance();
+                } else {
+                    Rlog.i(LOG_TAG, "World phone not support");
+                }
             }
         }
     }
@@ -291,6 +414,11 @@ public class PhoneFactory {
                 if (DBG) dbgInfo = "phoneId == DEFAULT_PHONE_ID return sProxyPhone";
                 phone = sProxyPhone;
             } else {
+                /// M: for SVLTE @{
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    phoneId = SvlteUtils.getSvltePhoneIdByPhoneId(phoneId);
+                }
+                /// @}
                 if (DBG) dbgInfo = "phoneId != DEFAULT_PHONE_ID return sProxyPhones[phoneId]";
                 phone = (((phoneId >= 0)
                                 && (phoneId < TelephonyManager.getDefault().getPhoneCount()))
@@ -613,4 +741,137 @@ public class PhoneFactory {
     public static SubscriptionInfoUpdater getSubscriptionInfoUpdater() {
         return sSubInfoRecordUpdater;
     }
+
+    // MTK
+
+    public static int calculatePreferredNetworkType(Context context) {
+        // TODO: allow overriding like in the AOSP impl
+        int networkType = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                android.provider.Settings.Global.PREFERRED_NETWORK_MODE,
+                RILConstants.PREFERRED_NETWORK_MODE);
+        Rlog.d(LOG_TAG, "calculatePreferredNetworkType: networkType = " + networkType);
+        return networkType;
+    }
+
+    /// M: SVLTE solution2 modify, svlte will create Phones,
+    /// Ril of inactive phone and SvltePhoneProxy here. @{
+    // MTK TODO
+
+    private static void svlteInit(Context context) {
+        /*
+        PhoneBase svlteDcPhone = null;
+        PhoneBase cdmaPhone = null;
+        int networkType = -1;
+        int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
+        int numPhones = TelephonyManager.getDefault().getPhoneCount();
+        for (int phoneId = 0; phoneId < numPhones; phoneId++) {
+            networkType = calculateNetworkType(context, SvlteUtils.getLteDcPhoneId(phoneId));
+            Rlog.i(LOG_TAG, "svlteInit, phoneId = " + phoneId + ", networkType = " + networkType);
+            if (sActiveSvlteModeSlotId == phoneId) {
+                cdmaPhone = new CDMAPhone(context,
+                                          sCommandsInterfaces[phoneId],
+                                          sPhoneNotifier,
+                                          phoneId);
+
+                sCommandsInterfaceLteDcs[phoneId] = new RIL(context,
+                                                            networkType,
+                                                            cdmaSubscription,
+                                                            SvlteUtils.getLteDcPhoneId(phoneId));
+                svlteDcPhone = new SvlteDcPhone(context,
+                                                sCommandsInterfaceLteDcs[phoneId],
+                                                sPhoneNotifier,
+                                                SvlteUtils.getLteDcPhoneId(phoneId));
+                sLteDcPhoneProxys[phoneId] = new SvltePhoneProxy(svlteDcPhone,
+                                                     cdmaPhone,
+                                                     SvlteModeController.RADIO_TECH_MODE_SVLTE);
+            } else {
+                svlteDcPhone = new SvlteDcPhone(context,
+                                                sCommandsInterfaces[phoneId],
+                                                sPhoneNotifier,
+                                                phoneId);
+                //sCommandsInterfaceLteDcs is for cdma phone in csfb mode.
+                sCommandsInterfaceLteDcs[phoneId] = new RIL(context,
+                                                            networkType,
+                                                            cdmaSubscription,
+                                                            SvlteUtils.getLteDcPhoneId(phoneId));
+                cdmaPhone = new CDMAPhone(context,
+                                          sCommandsInterfaceLteDcs[phoneId],
+                                          sPhoneNotifier,
+                                          SvlteUtils.getLteDcPhoneId(phoneId));
+
+                sLteDcPhoneProxys[phoneId] = new SvltePhoneProxy(svlteDcPhone,
+                                                     cdmaPhone,
+                                                     SvlteModeController.RADIO_TECH_MODE_CSFB);
+            }
+            sLteDcPhoneProxys[phoneId].initialize();
+            sProxyPhones[phoneId] = sLteDcPhoneProxys[phoneId];
+        }
+        SvlteModeController.make(context);
+        sLteDcPhoneProxys[SvlteModeController.getInstance().getCdmaSocketSlotId()]
+                .getNLtePhone().mCi.connectRilSocket();
+        int sCdmaSocketSlotId = SvlteModeController.getInstance().getCdmaSocketSlotId();
+        mUiccController.setSvlteCi(sCommandsInterfaceLteDcs[sCdmaSocketSlotId]);
+        mUiccController.setSvlteIndex(sCdmaSocketSlotId);
+        SvlteRoamingController.make(sLteDcPhoneProxys);
+        */
+    }
+    /// @}
+    /// M: SVLTE solution2 modify,calculate network type by phoneId. @{
+    private static int calculateNetworkType(Context context, int phoneId) {
+        int networkMode = -1;
+        int capabilityPhoneId = Integer.valueOf(
+                        SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1")) - 1;
+
+        if (!SvlteUtils.isValidPhoneId(phoneId)) {
+            Rlog.i(LOG_TAG, "calculateNetworkType error, phone id : " + phoneId);
+            return networkMode;
+        }
+
+        // MTK TODO
+        /*
+        if (sActiveSvlteModeSlotId == phoneId) {
+            networkMode = RILConstants.NETWORK_MODE_CDMA;
+            return networkMode;
+        } else */ if (SvlteUtils.isValidateSlotId(phoneId)) {
+            if (phoneId == capabilityPhoneId) {
+                networkMode = calculatePreferredNetworkType(context);
+            } else {
+                networkMode = RILConstants.NETWORK_MODE_GSM_ONLY;
+            }
+            return networkMode;
+        }
+
+        phoneId = SvlteUtils.getSlotId(phoneId);
+
+        //handle second phone in svltepohoneproxy
+        // MTK TODO
+        /*
+        if (sActiveSvlteModeSlotId != phoneId) {
+            networkMode = RILConstants.NETWORK_MODE_CDMA;
+        } else */ if (SvlteUtils.isValidateSlotId(phoneId)) {
+            if (phoneId == capabilityPhoneId) {
+                networkMode = calculatePreferredNetworkType(context);
+            } else {
+                networkMode = RILConstants.NETWORK_MODE_GSM_ONLY;
+            }
+        }
+        return networkMode;
+    }
+    /// @}
+
+    public static IWorldPhone getWorldPhone() {
+        if (sWorldPhone == null) {
+            Rlog.d(LOG_TAG, "sWorldPhone is null");
+        }
+
+        return sWorldPhone;
+    }
+
+    public static boolean isEvdoDTSupport() {
+        if (SystemProperties.get(EVDO_DT_SUPPORT).equals("1")) {
+            return true;
+        } else {
+            return false;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 2b22a61..6748cc5 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -82,6 +82,8 @@ import com.android.internal.telephony.RadioCapability;
 import com.android.internal.telephony.TelephonyDevController;
 import com.android.internal.telephony.HardwareConfig;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
 import java.io.ByteArrayInputStream;
 import java.io.DataInputStream;
 import java.io.FileDescriptor;
@@ -299,7 +301,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     //***** Constants
 
     // match with constant in ril.cpp
-    static final int RIL_MAX_COMMAND_BYTES = (8 * 1024);
+    static final int RIL_MAX_COMMAND_BYTES = (20 * 1024);  // MTK
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
@@ -691,35 +693,53 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 DEFAULT_WAKE_LOCK_TIMEOUT);
         mWakeLockCount = 0;
 
-        mSenderThread = new HandlerThread("RILSender" + mInstanceId);
-        mSenderThread.start();
-
-        Looper looper = mSenderThread.getLooper();
-        mSender = new RILSender(looper);
-
-        ConnectivityManager cm = (ConnectivityManager)context.getSystemService(
-                Context.CONNECTIVITY_SERVICE);
-        if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE) == false) {
-            riljLog("Not starting RILReceiver: wifi-only");
-        } else {
-            riljLog("Starting RILReceiver" + mInstanceId);
-            mReceiver = createRILReceiver();
-            mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
-            mReceiverThread.start();
-
+        ///M: SVLTE solution2 C2K RIL connect/disconnect  control. @{
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            if (mPreferredNetworkType != RILConstants.NETWORK_MODE_CDMA) {
+                connectRild();
+            }
             DisplayManager dm = (DisplayManager)context.getSystemService(
                     Context.DISPLAY_SERVICE);
             mDefaultDisplay = dm.getDisplay(Display.DEFAULT_DISPLAY);
             dm.registerDisplayListener(mDisplayListener, null);
-            mDefaultDisplayState = mDefaultDisplay.getState();
+        } else {
+            mSenderThread = new HandlerThread("RILSender" + mInstanceId);
+            mSenderThread.start();
+
+            Looper looper = mSenderThread.getLooper();
+            mSender = new RILSender(looper);
 
-            IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
-            Intent batteryStatus = context.registerReceiver(mBatteryStateListener, filter);
-            if (batteryStatus != null) {
-                // 0 means it's on battery
-                mIsDevicePlugged = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;
+            ConnectivityManager cm = (ConnectivityManager)context.getSystemService(
+                    Context.CONNECTIVITY_SERVICE);
+            if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE) == false) {
+                riljLog("Not starting RILReceiver: wifi-only");
+            } else {
+                riljLog("Starting RILReceiver" + mInstanceId);
+                mReceiver = createRILReceiver();
+                mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
+                mReceiverThread.start();
+
+                DisplayManager dm = (DisplayManager)context.getSystemService(
+                        Context.DISPLAY_SERVICE);
+                mDefaultDisplay = dm.getDisplay(Display.DEFAULT_DISPLAY);
+                dm.registerDisplayListener(mDisplayListener, null);
+                mDefaultDisplayState = mDefaultDisplay.getState();
+
+                IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
+                Intent batteryStatus = context.registerReceiver(mBatteryStateListener, filter);
+                if (batteryStatus != null) {
+                    // 0 means it's on battery
+                    mIsDevicePlugged = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;
+                }
             }
         }
+        /// @}
+        // xen0n: (useless) refactoring
+        /*
+        IntentFilter filter = new IntentFilter();
+        filter.addAction("com.mtk.TEST_TRM");
+        context.registerReceiver(mIntentReceiver, filter);
+        */
 
         TelephonyDevController tdc = TelephonyDevController.getInstance();
         tdc.registerRIL(this);
@@ -2042,7 +2062,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
                             Message response) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
 
-        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        // MTK
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                                                 + " [" + facility + " " + serviceClass
+                                                 + " " + appId + "]");
 
         boolean oldRil = needsOldRilFeature("facilitylock");
 
@@ -2492,7 +2515,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    protected void sendScreenState(boolean on) {
+    public /* MTK */ void sendScreenState(boolean on) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
         rr.mParcel.writeInt(1);
         rr.mParcel.writeInt(on ? 1 : 0);
@@ -3747,7 +3770,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
         IccRefreshResponse response = new IccRefreshResponse();
 
         response.refreshResult = p.readInt();
-        response.efId   = p.readInt();
+        // xen0n
+        // response.efId   = p.readInt();
+        response.efId = new int[1];
+        response.efId[0] = p.readInt();
         response.aid = p.readString();
         return response;
     }
@@ -4353,6 +4379,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
             case RIL_REQUEST_SIM_IO: return "SIM_IO";
             case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            /* M: SS part */
+            ///M: For query CNAP
+            case RIL_REQUEST_SEND_CNAP: return "SEND_CNAP";
+            /* M: SS part end */
             case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
             case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
             case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
@@ -4372,6 +4402,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
             case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
             case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
             case RIL_REQUEST_DTMF_START: return "DTMF_START";
             case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
             case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
@@ -4461,6 +4492,194 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_PULL_LCEDATA: return "RIL_REQUEST_PULL_LCEDATA";
             case RIL_REQUEST_GET_ACTIVITY_INFO: return "RIL_REQUEST_GET_ACTIVITY_INFO";
             case RIL_REQUEST_SET_MAX_TRANSMIT_POWER: return "RIL_REQUEST_SET_MAX_TRANSMIT_POWER";
+
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: return "RIL_REQUEST_VT_DIAL";
+            case RIL_REQUEST_VOICE_ACCEPT: return "VOICE_ACCEPT";
+            case RIL_REQUEST_REPLACE_VT_CALL: return "RIL_REQUEST_REPLACE_VT_CALL";
+            /// @}
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RESUME_CALL: return "RIL_REQUEST_RESUNME_CALL";
+            case RIL_REQUEST_HOLD_CALL: return "RIL_REQUEST_HOLD_CALL";
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: return "GET_COLP";
+            case RIL_REQUEST_SET_COLP: return "SET_COLP";
+            case RIL_REQUEST_GET_COLR: return "GET_COLR";
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: return "RIL_REQUEST_CONFERENCE_DIAL";
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: return "RIL_REQUEST_RELOAD_MODEM_TYPE";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: return "RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER";
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: return "RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS";
+            /// @}
+
+            /// M: SVLTE remote SIM access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: return "RIL_REQUEST_CONFIG_MODEM_STATUS";
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS:
+                return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION:
+                return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_UTK_MENU_FROM_MD";
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_STK_MENU_FROM_MD";
+            /* M: C2K part end */
+            // M: [C2K][MD IRAT]RIL
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: return "RIL_REQUEST_SET_ACTIVE_PS_SLOT";
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE:
+                return "RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE";
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN:
+                return "RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN";
+            /// @}
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: return "RIL_REQUEST_SET_SVLTE_RAT_MODE";
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED";
+            case RIL_REQUEST_RESUME_REGISTRATION: return "RIL_REQUEST_RESUME_REGISTRATION";
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA:
+                return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA";
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA:
+                return "RIL_REQUEST_RESUME_REGISTRATION_CDMA";
+            case RIL_REQUEST_CONFIG_EVDO_MODE:
+                return "RIL_REQUEST_CONFIG_EVDO_MODE";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                return "RIL_UNSOL_CDMA_SIGNAL_FADE";
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                return "RIL_UNSOL_CDMA_TONE_SIGNALS";
+
+            case RIL_REQUEST_SET_STK_UTK_MODE:
+                return "RIL_REQUEST_SET_STK_UTK_MODE";
+
+            case RIL_REQUEST_SWITCH_ANTENNA: return "RIL_REQUEST_SWITCH_ANTENNA";
+            case RIL_REQUEST_SWITCH_CARD_TYPE: return "RIL_REQUEST_SWITCH_CARD_TYPE";
+            case RIL_REQUEST_ENABLE_MD3_SLEEP: return "RIL_REQUEST_ENABLE_MD3_SLEEP";
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT:
+                return "RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT";
+            case RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER:
+                return "RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER";
+            // M: [LTE][Low Power][UL traffic shaping] End
             default: return "<unknown request>";
         }
     }
@@ -4523,6 +4742,131 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
             case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
             case RIL_UNSOL_LCEDATA_RECV: return "UNSOL_LCE_INFO_RECV";
+
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "UNSOL_CIPHER_INDICATION";
+            //case RIL_UNSOL_CNAP: return "UNSOL_CNAP"; //obsolete
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /// @}
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_TRAY_PLUG_IN: return "UNSOL_TRAY_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_FEMTOCELL_INFO: return "RIL_UNSOL_FEMTOCELL_INFO";
+            case RIL_UNSOL_INVALID_SIM: return "RIL_UNSOL_INVALID_SIM";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: return "RIL_UNSOL_MO_DATA_BARRING_INFO";
+            case RIL_UNSOL_SSAC_BARRING_INFO: return "RIL_UNSOL_SSAC_BARRING_INFO";
+
+            case RIL_UNSOL_SET_ATTACH_APN: return "RIL_UNSOL_SET_ATTACH_APN";
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY: return "RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY";
+            /// @}
+
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: return "RIL_UNSOL_CDMA_CALL_ACCEPTED";
+            case RIL_UNSOL_UTK_SESSION_END: return "RIL_UNSOL_UTK_SESSION_END";
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: return "RIL_UNSOL_UTK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: return "RIL_UNSOL_UTK_EVENT_NOTIFY";
+            case RIL_UNSOL_VIA_GPS_EVENT: return "RIL_UNSOL_VIA_GPS_EVENT";
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: return "RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE";
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: return "RIL_UNSOL_VIA_INVALID_SIM_DETECTED";
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED: return "RIL_UNSOL_CDMA_PLMN_CHANGED";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED: return "RIL_UNSOL_GMSS_RAT_CHANGED";
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+            /// M: [C2K] for ps type changed.
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED:
+                return "RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED";
+            /* M: C2K part end */
+            case RIL_UNSOL_ABNORMAL_EVENT: return "RIL_UNSOL_ABNORMAL_EVENT";
+            case RIL_UNSOL_CDMA_CARD_TYPE: return "RIL_UNSOL_CDMA_CARD_TYPE";
+            /// M: [C2K][MD IRAT] start
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                return "UNSOL_INTER_3GPP_IRAT_STATE_CHANGE";
+            /// @} [C2K][MD IRAT] end
+            /// M:[C2K] for eng mode
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO: return "RIL_UNSOL_ENG_MODE_NETWORK_INFO";
+            // MTK-START, SMS part
+            // SMS ready notification
+            case RIL_UNSOL_SMS_READY_NOTIFICATION: return "RIL_UNSOL_SMS_READY_NOTIFICATION";
+            // New sms but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL: return "RIL_UNSOL_ME_SMS_STORAGE_FULL";
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION: return "RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION";
+            // MTK-END, SMS part
+            case RIL_UNSOL_CDMA_IMSI_READY: return "RIL_UNSOL_CDMA_IMSI_READY";
+            case RIL_UNSOL_IMSI_REFRESH_DONE: return "RIL_UNSOL_IMSI_REFRESH_DONE";
+            // M: Notify RILJ that the AT+EUSIM was received
+            case RIL_UNSOL_EUSIM_READY: return "UNSOL_EUSIM_READY";
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND: return "UNSOL_STK_BIP_PROACTIVE_COMMAND";
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED: return "RIL_UNSOL_WORLD_MODE_CHANGED";
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO: return "UNSOL_VT_STATUS_INFO";
+            case RIL_UNSOL_VT_RING_INFO: return "UNSOL_VT_RING_INFO";
+            /// @}
+            //M: Add for ECC only
+            case RIL_UNSOL_NETWORK_EXIST: return "UNSOL_NETWORK_EXIST";
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE:
+                return "RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE";
+            // M: [LTE][Low Power][UL traffic shaping] End
             default: return "<unknown response>";
         }
     }
@@ -4553,7 +4897,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
         riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-    private Object
+    // xen0n: changed to protected for access from MediaTekRIL
+    protected Object
     responseSsData(Parcel p) {
         int num;
         SsData ssData = new SsData();
@@ -5182,4 +5527,149 @@ public class RIL extends BaseCommands implements CommandsInterface {
         rr.mParcel.writeInt(state);
         send(rr);
     }
+
+    // MTK
+    // xen0n: move MTK-specific method implementations into MediaTekRIL
+
+    protected void unexpectedMTKCall() {
+        Rlog.e(RILJ_LOG_TAG, "MTK-only method called on generic RIL!", new Exception());
+    }
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result)  {
+        unexpectedMTKCall();
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+        unexpectedMTKCall();
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void getCOLR(Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void getCOLP(Message response) {
+        unexpectedMTKCall();
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+        unexpectedMTKCall();
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+        unexpectedMTKCall();
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+        unexpectedMTKCall();
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+        unexpectedMTKCall();
+    }
+
+    public void profileDownload(String profile, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setStkSwitchMode(int mode) {
+        unexpectedMTKCall();
+    }
+
+    public void setBipPsType(int type) {
+        unexpectedMTKCall();
+    }
+    //UTK end
+
+    ///M: C2K RIL SWITCH @{
+    protected void connectRild() {
+        mSenderThread = new HandlerThread("RILSender" + mInstanceId);
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new RILSender(looper);
+
+        riljLog("Starting RILReceiver" + mInstanceId);
+        mReceiver = new RILReceiver();
+        mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
+        mReceiverThread.start();
+    }
+
+    @Override
+    public void connectRilSocket() {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void disconnectRilSocket() {
+        unexpectedMTKCall();
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index f8ab9ad..4973eaf 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -187,6 +187,13 @@ public abstract class ServiceStateTracker extends Handler {
     protected static final int EVENT_IMS_CAPABILITY_CHANGED            = 48;
     protected static final int EVENT_RADIO_POWER_OFF_DONE                  = 49;
 
+    // MTK events
+    // MTK TODO
+    protected static final int EVENT_SET_IMS_ENABLED_DONE = 109;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE = 110;
+    protected static final int EVENT_IMS_DISABLED_URC = 111;
+    protected static final int EVENT_IMS_REGISTRATION_INFO = 112;
+
     protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
 
     /**
diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 2979a76..1316211 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -46,6 +46,8 @@ import android.util.Log;
 import java.util.Objects;
 import com.android.internal.telephony.IccCardConstants.State;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -141,6 +143,10 @@ public class SubscriptionController extends ISub.Stub {
 
     private int[] colorArr;
 
+    // MTK
+    private static final boolean MTK_LTEDC_SUPPORT = CdmaFeatureOptionUtils.isCdmaLteDcSupport();
+    private boolean mIsReady = false;
+
     public static SubscriptionController init(Phone phone) {
         synchronized (SubscriptionController.class) {
             if (sInstance == null) {
@@ -261,6 +267,9 @@ public class SubscriptionController extends ISub.Stub {
              // Should never happen because its always available.
          }
 
+         // MTK
+         setReadyState(true);
+
          // FIXME: Remove if listener technique accepted.
          broadcastSimInfoContentChanged();
      }
@@ -1295,6 +1304,9 @@ public class SubscriptionController extends ISub.Stub {
                 return 0;
             }
 
+            // MTK
+            setReadyState(false);
+
             sSlotIdxToSubId.clear();
             if (DBG) logdl("[clearSubInfo]- clear size=" + size);
             return size;
@@ -1611,6 +1623,26 @@ public class SubscriptionController extends ISub.Stub {
     // FIXME: We need we should not be assuming phoneId == slotId as it will not be true
     // when there are multiple subscriptions per sim and probably for other reasons.
     public int getSubIdUsingPhoneId(int phoneId) {
+        // MTK-START
+        // Add the special handle for LTE_DC_PHONE_ID
+        if (MTK_LTEDC_SUPPORT) {
+            if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+                logd("[getSubIdUsingPhoneId]- phone is LTE_DC_PHONE_ID_1.");
+                if (!isReady()) {
+                    return SubscriptionManager.LTE_DC_SUB_ID_1 - 2;
+                } else {
+                    return SubscriptionManager.LTE_DC_SUB_ID_1;
+                }
+            } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+                logd("[getSubIdUsingPhoneId]- phone is LTE_DC_PHONE_ID_2.");
+                if (!isReady()) {
+                    return SubscriptionManager.LTE_DC_SUB_ID_2 - 2;
+                } else {
+                    return SubscriptionManager.LTE_DC_SUB_ID_2;
+                }
+            }
+        }
+        // MTK-END
         int[] subIds = getSubId(phoneId);
         if (subIds == null || subIds.length == 0) {
             return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
@@ -1976,4 +2008,24 @@ public class SubscriptionController extends ISub.Stub {
             Binder.restoreCallingIdentity(token);
         }
     }
+
+    // MTK
+
+    /**
+     * Query if sub module always initialization done.
+     *
+     */
+    public boolean isReady() {
+        logd("[isReady]- " + mIsReady);
+        return mIsReady;
+    }
+
+    /**
+     * Set sub module initialization state.
+     *
+     */
+    public void setReadyState(boolean isReady) {
+        logd("[setReadyState]- " + isReady);
+        mIsReady = isReady;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/SuppSrvRequest.java b/src/java/com/android/internal/telephony/SuppSrvRequest.java
new file mode 100755
index 0000000..912b769
--- /dev/null
+++ b/src/java/com/android/internal/telephony/SuppSrvRequest.java
@@ -0,0 +1,101 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.internal.telephony;
+
+import android.os.Message;
+import android.os.Parcel;
+
+/**
+ * SuppSrvRequest: to encapsulate a Supplementary Service Request.
+ *
+ *  @hide
+ */
+public class SuppSrvRequest {
+    int mRequestCode;
+    Message mResultCallback;
+    public Parcel mParcel;
+
+    // Request Code
+    public static final int SUPP_SRV_REQ_SET_CLIP               = 1;
+    public static final int SUPP_SRV_REQ_GET_CLIP               = 2;
+    public static final int SUPP_SRV_REQ_SET_CLIR               = 3;
+    public static final int SUPP_SRV_REQ_GET_CLIR               = 4;
+    public static final int SUPP_SRV_REQ_SET_COLP               = 5;
+    public static final int SUPP_SRV_REQ_GET_COLP               = 6;
+    public static final int SUPP_SRV_REQ_SET_COLR               = 7;
+    public static final int SUPP_SRV_REQ_GET_COLR               = 8;
+    public static final int SUPP_SRV_REQ_SET_CB                 = 9;
+    public static final int SUPP_SRV_REQ_GET_CB                 = 10;
+    public static final int SUPP_SRV_REQ_SET_CF                 = 11;
+    public static final int SUPP_SRV_REQ_GET_CF                 = 12;
+    public static final int SUPP_SRV_REQ_SET_CW                 = 13;
+    public static final int SUPP_SRV_REQ_GET_CW                 = 14;
+    public static final int SUPP_SRV_REQ_MMI_CODE               = 15;
+    public static final int SUPP_SRV_REQ_GET_CF_IN_TIME_SLOT    = 16;
+    public static final int SUPP_SRV_REQ_SET_CF_IN_TIME_SLOT    = 17;
+
+    /**
+     * Create SuppSrvRequest object with request and callback.
+     * @param request SS request code
+     * @param resultCallback callback Message
+     * @return the created SuppSrvRequest object
+     */
+    public static SuppSrvRequest obtain(int request, Message resultCallback) {
+        SuppSrvRequest ss = new SuppSrvRequest();
+
+        ss.mRequestCode = request;
+        ss.mResultCallback = resultCallback;
+        ss.mParcel = Parcel.obtain();
+
+        return ss;
+    }
+
+    private SuppSrvRequest() {
+    }
+
+    public Message getResultCallback() {
+        return mResultCallback;
+    }
+
+    public void setResultCallback(Message resultCallback) {
+        mResultCallback = resultCallback;
+    }
+
+    public int getRequestCode() {
+        return mRequestCode;
+    }
+}
+
diff --git a/src/java/com/android/internal/telephony/cat/AppInterface.java b/src/java/com/android/internal/telephony/cat/AppInterface.java
index 681f069..6f16f73 100644
--- a/src/java/com/android/internal/telephony/cat/AppInterface.java
+++ b/src/java/com/android/internal/telephony/cat/AppInterface.java
@@ -94,7 +94,12 @@ public interface AppInterface {
         RECEIVE_DATA(0x42),
         SEND_DATA(0x43),
         GET_CHANNEL_STATUS(0x44),
-        ACTIVATE(0x70);
+        ACTIVATE(0x70),
+        // MTK
+        /**
+         * Proprietay message for Call Control alpha id display
+         */
+        CALLCTRL_RSP_MSG(0XFF);
 
         private int mValue;
 
diff --git a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
index e99473c..0fa62e3 100644
--- a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
+++ b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
@@ -35,6 +35,9 @@ public class CatCmdMessage implements Parcelable {
     private CallSettings mCallSettings = null;
     private SetupEventListSettings mSetupEventListSettings = null;
     private boolean mLoadIconFailed = false;
+    // MTK
+    public int mInfoType = 0;
+    public String mDestAddress = null;
 
     // Command Qualifier values for refresh command
     static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
@@ -129,6 +132,13 @@ public class CatCmdMessage implements Parcelable {
             break;
         case ACTIVATE:
         case PROVIDE_LOCAL_INFORMATION:
+            break;
+        // MTK
+        case CALLCTRL_RSP_MSG:
+            mTextMsg = ((CallCtrlBySimParams) cmdParams).mTextMsg;
+            mInfoType = ((CallCtrlBySimParams) cmdParams).mInfoType;
+            mDestAddress = ((CallCtrlBySimParams) cmdParams).mDestAddress;
+            break;
         default:
             break;
         }
diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index ec23bd9..4fe2a95 100755
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -891,11 +891,52 @@ public class CatService extends Handler implements AppInterface {
             }
             break;
         case MSG_ID_ALPHA_NOTIFY:
+            // MTK
             CatLog.d(this, "Received CAT CC Alpha message from card");
             if (msg.obj != null) {
                 AsyncResult ar = (AsyncResult) msg.obj;
                 if (ar != null && ar.result != null) {
-                    broadcastAlphaMessage((String)ar.result);
+                    if (ar.result instanceof String) {
+                        broadcastAlphaMessage((String)ar.result);
+                    } else if (ar.result instanceof String[]) {
+                        // MTK
+                        String[] callCtrlInfo = (String[]) ar.result;
+                        CatLog.d(this, "callCtrlInfo.length: " + callCtrlInfo.length + "," +
+                                callCtrlInfo[0] + "," + callCtrlInfo[1] + "," +
+                                callCtrlInfo[2]);
+                        byte[] rawData = null;
+                        try {
+                            if (null != callCtrlInfo[1] && callCtrlInfo[1].length() > 0) {
+                                rawData = IccUtils.hexStringToBytes(callCtrlInfo[1]);
+                            } else {
+                                CatLog.d(this, "Null CC alpha id.");
+                                break;
+                            }
+                        } catch (Exception e) {
+                            // zombie messages are dropped
+                            CatLog.d(this, "CC message drop");
+                            break;
+                        }
+                        String alphaId = null;
+                        try {
+                            alphaId = IccUtils.adnStringFieldToString(
+                                    rawData, 0, rawData.length);
+                        } catch (IndexOutOfBoundsException e) {
+                            CatLog.d(this, "IndexOutOfBoundsException adnStringFieldToString");
+                            break;
+                        }
+                        CatLog.d(this, "CC Alpha msg: " + alphaId + ", sim id: " + mSlotId);
+                        TextMessage textMessage = new TextMessage();
+                        CommandDetails cmdDet = new CommandDetails();
+                        cmdDet.typeOfCommand = AppInterface.CommandType.CALLCTRL_RSP_MSG.value();
+                        textMessage.text = alphaId;
+                        CallCtrlBySimParams cmdParams = new CallCtrlBySimParams(cmdDet,
+                                textMessage, Integer.parseInt(callCtrlInfo[0]), callCtrlInfo[2]);
+                        CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
+                        broadcastCatCmdIntent(cmdMsg);
+                    } else {
+                        CatLog.d(this, "CAT Alpha message: unexpected response type!");
+                    }
                 } else {
                     CatLog.d(this, "CAT Alpha message: ar.result is null");
                 }
diff --git a/src/java/com/android/internal/telephony/cat/CommandParams.java b/src/java/com/android/internal/telephony/cat/CommandParams.java
index b87b042..c6df26c 100644
--- a/src/java/com/android/internal/telephony/cat/CommandParams.java
+++ b/src/java/com/android/internal/telephony/cat/CommandParams.java
@@ -254,3 +254,22 @@ class SendUSSDParams extends DisplayTextParams {
         ussdString = ussdstring;
     }
 }
+
+// MTK
+
+/**
+ * CallCtrlBySimParams class for CC by SIM parameters.
+ */
+class CallCtrlBySimParams extends CommandParams {
+    TextMessage mTextMsg;
+    int mInfoType;
+    String mDestAddress;
+
+    CallCtrlBySimParams(CommandDetails cmdDet, TextMessage textMsg,
+        int infoType, String destAddress) {
+        super(cmdDet);
+        mTextMsg = textMsg;
+        mInfoType = infoType;
+        mDestAddress = destAddress;
+    }
+}
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index e1569ae..5beb9b6 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -81,6 +81,10 @@ import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -3013,15 +3017,19 @@ public class DcTracker extends DcTrackerBase {
 
         int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
         int appFamily = UiccController.getFamilyFromRadioTechnology(dataRat);
-        IccRecords newIccRecords = getUiccRecords(appFamily);
+        final int mtkFamily = getUiccFamily(mPhone);  // MTK
+        IccRecords newIccRecords = getUiccRecords(mtkFamily /* appFamily */);
         log("onUpdateIcc: newIccRecords " + ((newIccRecords != null) ?
                 newIccRecords.getClass().getName() : null));
+        // MTK stack would fail to perform IA with this as on MTK dataRat is set late *AFTER* IA
+        /*
         if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
             // Ignore this. This could be due to data not registered
             // We want to ignore RADIO_TECHNOLOGY_UNKNOWN so that we do not tear down data
             // call in case we are out of service.
             return false;
         }
+        */
 
         IccRecords r = mIccRecords.get();
         if (r != newIccRecords) {
@@ -3044,6 +3052,66 @@ public class DcTracker extends DcTrackerBase {
             // Records changed -> return true
             result = true;
         }
+
+        // MTK TODO
+        /*
+        // M: [C2K][IRAT] Register for LTE records loaded.
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && SvlteUtils.isActiveSvlteMode(mPhone)) {
+            IccRecords newLteIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
+            IccRecords oldLteIccRecords = mLteIccRecords.get();
+            log("[IRAT_DcTracker] Register for LTE IccRecords: newLteIccRecords = "
+                    + newLteIccRecords
+                    + ", oldLteIccRecords = "
+                    + oldLteIccRecords);
+
+            // Do not judge whether the records is the same before registering
+            // LTE records, because only single SIM record on Android, the SIM
+            // record instance is always the same.
+            if (oldLteIccRecords != null) {
+                log("Removing stale LTE icc objects.");
+                oldLteIccRecords.unregisterForRecordsLoaded(this);
+                mLteIccRecords.set(null);
+
+                // Register back the records loaded event if it is removed.
+                if (oldLteIccRecords == newIccRecords) {
+                    newIccRecords.registerForRecordsLoaded(this,
+                            DctConstants.EVENT_RECORDS_LOADED, null);
+                }
+            }
+            if (newLteIccRecords != null) {
+                log("New LTE records found");
+                mLteIccRecords.set(newLteIccRecords);
+                newLteIccRecords.registerForRecordsLoaded(this,
+                        LteDcConstants.EVENT_LTE_RECORDS_LOADED, null);
+            }
+        }
+
+        if (mAllApnSettings != null && r == null && newIccRecords == null) {
+            mAllApnSettings.clear();
+        }
+
+        //MTK START: FDN Support
+        UiccCardApplication app = mUiccCardApplication.get();
+        UiccCardApplication newUiccCardApp = mUiccController.getUiccCardApplication(
+                mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA ?
+                UiccController.APP_FAM_3GPP2 : UiccController.APP_FAM_3GPP);
+
+        if (app != newUiccCardApp) {
+            if (app != null) {
+                log("Removing stale UiccCardApplication objects.");
+                app.unregisterForFdnChanged(this);
+                mUiccCardApplication.set(null);
+            }
+
+            if (newUiccCardApp != null) {
+                log("New UiccCardApplication found");
+                newUiccCardApp.registerForFdnChanged(this, DctConstants.EVENT_FDN_CHANGED, null);
+                mUiccCardApplication.set(newUiccCardApp);
+            }
+        }
+        //MTK END: FDN Support
+        */
+
         return result;
     }
 
@@ -3342,4 +3410,65 @@ public class DcTracker extends DcTrackerBase {
             notifyAllDataDisconnected();
         }
     }
+
+    // MTK
+
+    private static final String PROP_NAME_SET_TEST_RAT = "mtk.test.rat";
+
+    // Set APP family to unknown when radio technology is not specified.
+    public static final int APP_FAM_UNKNOWN = 0;
+
+    // NOTE: DcTracker.java:4983
+    private int getUiccFamily(PhoneBase phone) {
+        int family = UiccController.APP_FAM_3GPP;
+        if (!CdmaFeatureOptionUtils.isCdmaLteDcSupport() || !SvlteUtils.isActiveSvlteMode(phone)) {
+            if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                family = UiccController.APP_FAM_3GPP2;
+            }
+        } else {
+            int radioTech = getRilDataRadioTechnology(phone);
+            if (radioTech != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                family = getUiccFamilyByRat(radioTech);
+            } else {
+                // Return 3GPP2 family if the phone is CDMA.
+                if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                    family = UiccController.APP_FAM_3GPP2;
+                }
+            }
+            log("[IRAT_DcTracker] getUiccFamily: radioTech = " + radioTech
+                    + ", family=" + family + ", phone = " + phone);
+        }
+        return family;
+    }
+
+    private int getRilDataRadioTechnology(PhoneBase phone) {
+        int testRat = SystemProperties.getInt(PROP_NAME_SET_TEST_RAT, 0);
+        if (testRat != 0) {
+            log("[IRAT_DcTracker] Use test RAT " + testRat + " instead of "
+                    + phone.getServiceState().getRilDataRadioTechnology()
+                    + " for test.");
+            return testRat;
+        }
+        return phone.getServiceState().getRilDataRadioTechnology();
+    }
+
+    // NOTE: DcTracker.java:5082
+    /**
+     * M: Get Uicc Family by radio technology.
+     * @param radioTech Ratio technology.
+     * @return APP family of the RAT.
+     */
+    private static int getUiccFamilyByRat(int radioTech) {
+        if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+            return APP_FAM_UNKNOWN;
+        }
+
+        if ((radioTech >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A
+                && radioTech <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A)
+                || radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_B) {
+            return UiccController.APP_FAM_3GPP2;
+        } else {
+            return UiccController.APP_FAM_3GPP;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index febed59..464cbe8 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -58,11 +58,17 @@ import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneBase;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.RILConstants;
 import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.dataconnection.DataSubSelector;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -1795,6 +1801,66 @@ public abstract class DcTrackerBase extends Handler {
 
     protected void setInitialAttachApn(ArrayList <ApnSetting> apnList,
             ApnSetting preferredApn) {
+        // MTK
+        // M:[C2K][IRAT] Set initial attach APN for SVLTE. {@
+        if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && SvlteUtils.isActiveSvlteMode(mPhone)
+                    && mSvlteOperatorNumeric != null) {
+                // MTK TODO
+                // setInitialAttachApnForSvlte();
+            } else {
+                log("[IRAT_DcTracker] DO NOT setInitialApn for CDMA: numeric = "
+                        + mSvlteOperatorNumeric);
+            }
+            return;
+        } else if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
+            log("[IRAT_DcTracker] GSM setInitialAttachApn: numeric = "
+                    + mSvlteOperatorNumeric);
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()
+                    && SvlteUtils.isActiveSvlteMode(mPhone)) {
+                if (mSvlteOperatorNumeric != null) {
+                    // Since only CTLTE/Empty APN can be used to attach LTE
+                    // network for CT network, only set CTLTE as initial attach.
+                    if (OPERATOR_NUMERIC_CTLTE.equals(mSvlteOperatorNumeric)) {
+                        // MTK TODO
+                        // setInitialAttachApnForSvlte();
+                        return;
+                    }
+                    // Else if the SIM is not CT card(not equals 46011), follow
+                    // the default flow.
+                } else {
+                    // Do nothing since LTE records is not loaded yet.
+                    log("[IRAT_DcTracker] GSM ignore IA because SIM not loaded.");
+                    IccRecords r = mIccRecords.get();
+                    String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+                    if (operatorNumeric == null || operatorNumeric.length() == 0) {
+                        log("setInitialApn: but no operator numeric");
+                        return;
+                    }
+                }
+            }
+        }
+        // M: @}
+
+        // MTK TODO: mInitialAttachApnSetting
+        // ApnSetting previousAttachApn = mInitialAttachApnSetting;
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (operatorNumeric == null || operatorNumeric.length() == 0) {
+            log("setInitialApn: but no operator numeric");
+            return;
+        }
+
+        String[] dualApnPlmnList = null;
+        /*
+        if (MTK_DUAL_APN_SUPPORT == true) {
+            dualApnPlmnList = mPhone.getContext().getResources()
+                        .getStringArray(com.mediatek.internal.R.array.dtag_dual_apn_plmn_list);
+        }
+        */
+
+        // log("setInitialApn: current attach Apn [" + mInitialAttachApnSetting + "]");
+
         ApnSetting iaApnSetting = null;
         ApnSetting defaultApnSetting = null;
         ApnSetting firstApnSetting = null;
@@ -1845,13 +1911,29 @@ public abstract class DcTrackerBase extends Handler {
         }
 
         if (initialAttachApnSetting == null) {
+            // MTK
+            if (operatorNumeric == null) {
+                if (DBG) log("setInitialAttachApn: but no operator and no available apn");
+            } else {
             if (DBG) log("setInitialAttachApn: X There in no available apn");
+            IaExtendParam param = new IaExtendParam(operatorNumeric, dualApnPlmnList);
+            mPhone.mCi.setInitialAttachApn("", RILConstants.SETUP_DATA_PROTOCOL_IP, -1, "", "",
+                    (Object) param, null);
+            } // MTK
         } else {
+            // MTK
+            if (operatorNumeric == null) {
+                if (DBG) log("setInitialAttachApn: but no operator");
+            } else {
             if (DBG) log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
 
+            IaExtendParam param = new IaExtendParam(operatorNumeric,
+                        initialAttachApnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS),
+                        dualApnPlmnList);
             mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn,
                     initialAttachApnSetting.protocol, initialAttachApnSetting.authType,
-                    initialAttachApnSetting.user, initialAttachApnSetting.password, null);
+                    initialAttachApnSetting.user, initialAttachApnSetting.password, /* MTK */ param, null);
+            }  // MTK
         }
     }
 
@@ -2042,4 +2124,30 @@ public abstract class DcTrackerBase extends Handler {
         pw.println(" mDataRoamingSettingObserver=" + mDataRoamingSettingObserver);
         pw.flush();
     }
+
+    // MTK
+
+    protected static final String PROPERTY_MOBILE_DATA_ENABLE = "persist.radio.mobile.data";
+    protected static final boolean DUALTALK_SPPORT =
+            SystemProperties.getInt("ro.mtk_dt_support", 0) == 1;
+    protected ApnSetting mInitialAttachApnSetting;
+    protected Handler mWorkerHandler;
+    protected boolean mDataRoamingEnabled;
+    private static final String NO_SIM_VALUE = "N/A";
+    private String[] PROPERTY_ICCID = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    // M: [C2K][IRAT] Record initial attach APN for SVLTE, distinguish with
+    // original initial attach APN.
+    // TODO: move C2K logic to OP09 if it is not OM request.
+    protected static final String OPERATOR_NUMERIC_CTLTE = "46011";
+    protected static final String OPERATOR_NUMERIC_VODAFONE = "20404";
+    protected static final String OPERATOR_NUMERIC_HUTCHISON = "45403";
+
+    protected String mSvlteOperatorNumeric;
+    protected ApnSetting mSvlteIaApnSetting;
 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DctController.java b/src/java/com/android/internal/telephony/dataconnection/DctController.java
index c630cb6..1a6024a 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DctController.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DctController.java
@@ -560,24 +560,12 @@ public class DctController extends Handler {
         int priority = -1;
         int subId;
 
-        int activePhoneId = -1;
-        for (int i=0; i<mDcSwitchStateMachine.length; i++) {
-            if (!mDcSwitchAsyncChannel[i].isIdleSync()) {
-                activePhoneId = i;
-                break;
-            }
-        }
-
         for (RequestInfo requestInfo : mRequestInfos.values()) {
             logd("getTopPriorityRequestPhoneId requestInfo=" + requestInfo);
             if (requestInfo.priority > priority) {
                 priority = requestInfo.priority;
                 topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
                 retRequestInfo = requestInfo;
-            } else if (priority == requestInfo.priority) {
-                if (requestInfo.executedPhoneId == activePhoneId) {
-                   topSubId = requestInfo.request.networkCapabilities.getNetworkSpecifier();
-               }
             }
         }
         if (TextUtils.isEmpty(topSubId)) {
diff --git a/src/java/com/android/internal/telephony/gsm/CallFailCause.java b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
index 5861c4c..ebc7d53 100644
--- a/src/java/com/android/internal/telephony/gsm/CallFailCause.java
+++ b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
@@ -98,4 +98,33 @@ public interface CallFailCause {
     static final int EMERGENCY_PERM_FAILURE = 326;
 
     static final int ERROR_UNSPECIFIED = 0xffff;
+
+    // MTK
+
+    static final int NO_ROUTE_TO_DESTINATION = NO_ROUTE_TO_DESTINAON;
+    static final int NO_USER_RESPONDING = CALL_FAIL_NO_USER_RESPONDING;
+    static final int USER_ALERTING_NO_ANSWER = CALL_FAIL_NO_ANSWER_FROM_USER;
+    static final int PRE_EMPTION = PREEMPTION;
+    static final int DESTINATION_OUT_OF_ORDER = CALL_FAIL_DESTINATION_OUT_OF_ORDER;
+    static final int INVALID_NUMBER_FORMAT = INVALID_NUMBER;
+    static final int RESOURCE_UNAVAILABLE = RESOURCES_UNAVAILABLE_OR_UNSPECIFIED;
+    static final int INCOMING_CALL_BARRED_WITHIN_CUG = INCOMING_CALLS_BARRED_WITHIN_CUG;
+    static final int BEARER_NOT_AUTHORIZED = BEARER_CAPABILITY_NOT_AUTHORIZED;
+    static final int SERVICE_NOT_AVAILABLE = SERVICE_OPTION_NOT_AVAILABLE;
+    static final int BEARER_NOT_IMPLEMENT = BEARER_SERVICE_NOT_IMPLEMENTED;
+    static final int FACILITY_NOT_IMPLEMENT = REQUESTED_FACILITY_NOT_IMPLEMENTED;
+    static final int RESTRICTED_BEARER_AVAILABLE = ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE;
+    static final int OPTION_NOT_AVAILABLE = SERVICE_OR_OPTION_NOT_IMPLEMENTED;
+    static final int INVALID_TRANSACTION_ID_VALUE = INVALID_TRANSACTION_IDENTIFIER;
+    static final int INVALID_TRANSIT_NETWORK_SELECTION = INVALID_TRANSIT_NW_SELECTION;
+    static final int MESSAGE_TYPE_NON_EXISTENT = MESSAGE_TYPE_NON_IMPLEMENTED;
+    static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE = MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
+    static final int IE_NON_EXISTENT_OR_NOT_IMPLEMENTED = INFORMATION_ELEMENT_NON_EXISTENT;
+    static final int RECOVERY_ON_TIMER_EXPIRY = RECOVERY_ON_TIMER_EXPIRED;
+    static final int CM_MM_RR_CONNECTION_RELEASE = 2165;
+
+    /// M: IMS feature. @{
+    /* Normal call failed, need to dial as ECC */
+    static final int IMS_EMERGENCY_REREG = 380;
+    /// @}
 }
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index e2624da..183e445 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -1514,7 +1514,12 @@ public class GSMPhone extends PhoneBase {
             // Complete pending USSD
 
             if (isUssdRelease) {
-                found.onUssdRelease();
+                // MTK weirdness
+                if(ussdMessage != null) {
+                    found.onUssdFinished(ussdMessage, isUssdRequest);
+                } else {
+                    found.onUssdRelease();
+                }
             } else if (isUssdError) {
                 found.onUssdFinishedError();
             } else {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 995c64b..7669324 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -229,6 +229,11 @@ public class GsmServiceStateTracker extends ServiceStateTracker {
         mCi.setOnNITZTime(this, EVENT_NITZ_TIME, null);
         mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
 
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1")) {
+            // mCi.registerForImsDisable(this, EVENT_IMS_DISABLED_URC, null);  // completely unused
+            mCi.registerForImsRegistrationInfo(this, EVENT_IMS_REGISTRATION_INFO, null);
+        }
+
         // system setting property AIRPLANE_MODE_ON is set in Settings.
         int airplaneMode = Settings.Global.getInt(
                 phone.getContext().getContentResolver(),
@@ -278,6 +283,11 @@ public class GsmServiceStateTracker extends ServiceStateTracker {
         if (mIccRecords != null) {mIccRecords.unregisterForRecordsLoaded(this);}
         mCi.unSetOnRestrictedStateChanged(this);
         mCi.unSetOnNITZTime(this);
+        // xen0n: MTK forgot to unregister this
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1")) {
+            // mCi.unregisterForImsDisable(this);  // completely unused
+            mCi.unregisterForImsRegistrationInfo(this);
+        }
         mCr.unregisterContentObserver(mAutoTimeObserver);
         mCr.unregisterContentObserver(mAutoTimeZoneObserver);
         mPhone.getContext().unregisterReceiver(mIntentReceiver);
@@ -509,6 +519,31 @@ public class GsmServiceStateTracker extends ServiceStateTracker {
                 updateSpnDisplay();
                 break;
 
+            // MTK
+            // seems totally useless besides debug purposes... but let's debug it anyway
+            case EVENT_IMS_REGISTRATION_INFO:
+                // xen0n: don't pollute namespace with otherwise unused variables
+                int mImsRegInfo = -1;
+                int mImsExtInfo = -1;
+
+                log("handle EVENT_IMS_REGISTRATION_INFO");
+                ar = (AsyncResult) msg.obj;
+                /// M: Simulate IMS Registration @{
+                /*
+                if (SystemProperties.getInt("persist.ims.simulate", 0) == 1) {
+                    ((int[]) ar.result)[0] = (mImsRegistry ? 1 : 0);
+                    log("Override EVENT_IMS_REGISTRATION_INFO: new mImsRegInfo=" +
+                            ((int[]) ar.result)[0]);
+                }
+                */
+                /// @}
+                mImsRegInfo = ((int[]) ar.result)[0];  // xen0n
+                if (((int[]) ar.result)[1] > 0) {
+                    mImsExtInfo = ((int[]) ar.result)[1];
+                }
+                log("ImsRegistrationInfoResult [" + mImsRegInfo + ", " + mImsExtInfo + "]");
+                break;
+
             default:
                 super.handleMessage(msg);
             break;
@@ -1663,15 +1698,8 @@ public class GsmServiceStateTracker extends ServiceStateTracker {
      */
     private boolean isOperatorConsideredNonRoaming(ServiceState s) {
         String operatorNumeric = s.getOperatorNumeric();
-        String[] numericArray;
-        int subId = mPhone.getSubId();
-        if (subId >= 0) {
-            numericArray = SubscriptionManager.getResourcesForSubId(mPhone.getContext(),subId)
-                 .getStringArray(com.android.internal.R.array.config_operatorConsideredNonRoaming);
-        } else {
-            numericArray = mPhone.getContext().getResources().getStringArray(
+        String[] numericArray = mPhone.getContext().getResources().getStringArray(
                     com.android.internal.R.array.config_operatorConsideredNonRoaming);
-        }
 
         if (numericArray.length == 0 || operatorNumeric == null) {
             return false;
@@ -1687,16 +1715,8 @@ public class GsmServiceStateTracker extends ServiceStateTracker {
 
     private boolean isOperatorConsideredRoaming(ServiceState s) {
         String operatorNumeric = s.getOperatorNumeric();
-        String[] numericArray;
-        int subId = mPhone.getSubId();
-        if (subId >= 0) {
-            numericArray = SubscriptionManager.getResourcesForSubId(mPhone.getContext(),subId)
-                .getStringArray(
+        String[] numericArray = mPhone.getContext().getResources().getStringArray(
                     com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
-        } else {
-            numericArray = mPhone.getContext().getResources().getStringArray(
-                    com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
-        }
 
         if (numericArray.length == 0 || operatorNumeric == null) {
             return false;
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
index aab5987..2395995 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
@@ -616,4 +616,113 @@ class ImsPhoneCommandInterface extends BaseCommands implements CommandsInterface
     }
 
     public boolean needsOldRilFeature(String feature) { return false; }
+
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result) {
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+    }
+
+    public void getCOLR(Message response) {
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+    }
+
+    public void getCOLP(Message response) {
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+    }
+
+    public void profileDownload(String profile, Message response) {
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+    }
+
+    public void setStkSwitchMode(int mode) {
+    }
+
+    public void setBipPsType(int type) {
+    }
+    //UTK end
 }
diff --git a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 6feb272..c9c37e6 100644
--- a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -614,4 +614,113 @@ class SipCommandInterface extends BaseCommands implements CommandsInterface {
     }
 
     public boolean needsOldRilFeature(String feature) { return false; }
+
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result) {
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+    }
+
+    public void getCOLR(Message response) {
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+    }
+
+    public void getCOLP(Message response) {
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+    }
+
+    public void profileDownload(String profile, Message response) {
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+    }
+
+    public void setStkSwitchMode(int mode) {
+    }
+
+    public void setBipPsType(int type) {
+    }
+    //UTK end
 }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index b12b9f5..93019bf 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1804,4 +1804,139 @@ public final class SimulatedCommands extends BaseCommands
     }
 
     public boolean needsOldRilFeature(String feature) { return false; }
+
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result)  {
+        unimplemented(result);
+    }
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+        resultSuccess(response, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+        resultSuccess(response, null);
+    }
+
+    /* M: SS part */
+    public void getCOLR(Message response) {
+        unimplemented(response);
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+        unimplemented(response);
+    }
+
+    public void getCOLP(Message response) {
+        unimplemented(response);
+    }
+    /* M: SS part end */
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+            unimplemented(result);
+    }
+    /* M: SS part end */
+
+    /// M: CC010: Add RIL interface @{
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void hangupAll(Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void forceReleaseCall(int index, Message response) {
+        unimplemented(response);
+    }
+
+    public void setCallIndication(int mode, int callId, int seqNumber, Message response) {
+        unimplemented(response);
+    }
+    /// @}
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+        unimplemented(response);
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message response) {
+        unimplemented(response);
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        resultSuccess(response, null);
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    // UTK start
+    public void getUtkLocalInfo(Message response) {
+        unimplemented(response);
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+        unimplemented(response);
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        unimplemented(response);
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void profileDownload(String profile, Message response) {
+        resultSuccess(response, null);
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        resultSuccess(response, null);
+    }
+
+
+    @Override
+    public void setStkSwitchMode(int mode) {
+    }
+
+    @Override
+    public void setBipPsType(int type) {
+    }
+    //UTK end
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index 1886026..e194e91 100644
--- a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -33,6 +33,7 @@ import android.telephony.ServiceState;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 
+import com.android.internal.telephony.CommandException;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.IccCard;
 import com.android.internal.telephony.IccCardConstants;
@@ -50,6 +51,10 @@ import com.android.internal.telephony.uicc.IccCardStatus.CardState;
 import com.android.internal.telephony.uicc.IccCardStatus.PinState;
 import com.android.internal.telephony.uicc.UiccController;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
@@ -128,8 +133,10 @@ public class IccCardProxy extends Handler implements IccCard {
                 ci, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
         mUiccController = UiccController.getInstance();
         mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null);
+        mUiccController.registerForIccRecovery(this, EVENT_ICC_RECOVERY, null);  // MTK
         ci.registerForOn(this,EVENT_RADIO_ON, null);
         ci.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_UNAVAILABLE, null);
+        ci.registerForNotAvailable(this, EVENT_NOT_AVAILABLE, null);  // MTK
 
         resetProperties();
         setExternalState(State.NOT_READY, false);
@@ -140,9 +147,11 @@ public class IccCardProxy extends Handler implements IccCard {
             log("Disposing");
             //Cleanup icc references
             mUiccController.unregisterForIccChanged(this);
+            mUiccController.unregisterForIccRecovery(this);  // MTK
             mUiccController = null;
             mCi.unregisterForOn(this);
             mCi.unregisterForOffOrNotAvailable(this);
+            mCi.unregisterForNotAvailable(this);  // MTK
             mCdmaSSM.dispose(this);
         }
     }
@@ -232,7 +241,27 @@ public class IccCardProxy extends Handler implements IccCard {
                     return;
                 }
                 if (mInitialized) {
-                    updateIccAvailability();
+                    // MTK
+                    AsyncResult ar = (AsyncResult) msg.obj;
+                    int index = mPhoneId;
+
+                    if (ar != null && ar.result instanceof Integer) {
+                        index = ((Integer) ar.result).intValue();
+                        log("handleMessage (EVENT_ICC_CHANGED) , index = " + index);
+                    } else {
+                        log("handleMessage (EVENT_ICC_CHANGED), come from myself");
+                    }
+
+                    // SVLTE
+                    // MTK TODO
+                    /*
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && index == 100) {
+                        index = SvlteModeController.getCdmaSocketSlotId();
+                    }
+                    */
+                    if (index == mPhoneId) {
+                        updateIccAvailability();
+                    }
                 }
                 break;
             case EVENT_ICC_ABSENT:
@@ -281,6 +310,11 @@ public class IccCardProxy extends Handler implements IccCard {
                 broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
                 break;
             case EVENT_NETWORK_LOCKED:
+                // MTK
+                if (mUiccApplication == null) {
+                    loge("getIccStateReason: NETWORK_LOCKED but mUiccApplication is null!");
+                    return;
+                }
                 mPersoSubState = mUiccApplication.getPersoSubState();
                 mNetworkLockedRegistrants.notifyRegistrants((AsyncResult)msg.obj);
                 setExternalState(State.NETWORK_LOCKED);
@@ -317,6 +351,34 @@ public class IccCardProxy extends Handler implements IccCard {
                 onRecordsLoaded();
                 break;
 
+            // MTK
+            case EVENT_NOT_AVAILABLE:
+                log("handleMessage (EVENT_NOT_AVAILABLE)");
+                setExternalState(State.NOT_READY);
+                break;
+
+            case EVENT_ICC_RECOVERY: {
+                AsyncResult ar = (AsyncResult) msg.obj;
+                Integer index = (Integer) ar.result;
+                log("handleMessage (EVENT_ICC_RECOVERY) , index = " + index);
+                if (index == mPhoneId) {
+                    if (DBG) log("mRecoveryRegistrants notify");
+                    mRecoveryRegistrants.notifyRegistrants();
+                }
+                break;
+            }
+
+            case EVENT_ICC_FDN_CHANGED:
+                mFdnChangedRegistrants.notifyRegistrants();
+                break;
+
+            case EVENT_ICC_REFRESH:
+                log("EVENT_ICC_REFRESH");
+                if (mIccRecords != null) {
+                    mIccRecords.onRefresh(true, null);
+                }
+                break;
+
             default:
                 loge("Unhandled message with number: " + msg.what);
                 break;
@@ -430,6 +492,10 @@ public class IccCardProxy extends Handler implements IccCard {
             case APPSTATE_READY:
                 setExternalState(State.READY);
                 break;
+            // MTK
+            default:
+                setExternalState(State.UNKNOWN);
+                break;
         }
     }
 
@@ -441,6 +507,8 @@ public class IccCardProxy extends Handler implements IccCard {
             mUiccApplication.registerForReady(this, EVENT_APP_READY, null);
             mUiccApplication.registerForLocked(this, EVENT_ICC_LOCKED, null);
             mUiccApplication.registerForNetworkLocked(this, EVENT_NETWORK_LOCKED, null);
+            // MTK
+            mUiccApplication.registerForFdnChanged(this, EVENT_ICC_FDN_CHANGED, null);
         }
         if (mIccRecords != null) {
             mIccRecords.registerForImsiReady(this, EVENT_IMSI_READY, null);
@@ -454,6 +522,7 @@ public class IccCardProxy extends Handler implements IccCard {
         if (mUiccApplication != null) mUiccApplication.unregisterForReady(this);
         if (mUiccApplication != null) mUiccApplication.unregisterForLocked(this);
         if (mUiccApplication != null) mUiccApplication.unregisterForNetworkLocked(this);
+        if (mUiccApplication != null) mUiccApplication.unregisterForFdnChanged(this);  // MTK
         if (mIccRecords != null) mIccRecords.unregisterForImsiReady(this);
         if (mIccRecords != null) mIccRecords.unregisterForRecordsLoaded(this);
         if (mIccRecords != null) mIccRecords.unregisterForRecordsEvents(this);
@@ -576,6 +645,15 @@ public class IccCardProxy extends Handler implements IccCard {
     }
 
     private void setExternalState(State newState) {
+        // MTK
+        if (newState == State.PIN_REQUIRED && mUiccApplication != null) {
+            PinState pin1State = mUiccApplication.getPin1State();
+            if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
+                setExternalState(State.PERM_DISABLED);
+                return;
+            }
+        }
+
         setExternalState(newState, false);
     }
 
@@ -611,6 +689,23 @@ public class IccCardProxy extends Handler implements IccCard {
             case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
             case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
             case NETWORK_LOCKED: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+            // MTK TODO
+            /*
+            case NETWORK_LOCKED:
+                switch (mUiccApplication.getPersoSubState()) {
+                        case PERSOSUBSTATE_SIM_NETWORK:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                        case PERSOSUBSTATE_SIM_NETWORK_SUBSET:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                        case PERSOSUBSTATE_SIM_CORPORATE:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                        case PERSOSUBSTATE_SIM_SERVICE_PROVIDER:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                        case PERSOSUBSTATE_SIM_SIM:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                        default: return null;
+                }
+            */
             case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
             case CARD_IO_ERROR: return IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR;
             default: return null;
@@ -717,7 +812,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPin(pin, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPin, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -731,7 +829,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPuk(puk, newPin, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPuk, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -745,7 +846,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPin2(pin2, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPin2, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -759,7 +863,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPuk2(puk2, newPin2, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPuk2, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -823,7 +930,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.setIccLockEnabled(enabled, password, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccLockEnabled, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -837,7 +947,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.setIccFdnEnabled(enabled, password, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccFdnEnabled, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -851,7 +964,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.changeIccLockPassword(oldPassword, newPassword, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to changeIccLockPassword, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -865,7 +981,10 @@ public class IccCardProxy extends Handler implements IccCard {
             if (mUiccApplication != null) {
                 mUiccApplication.changeIccFdnPassword(oldPassword, newPassword, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to changeIccFdnPassword, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -894,10 +1013,32 @@ public class IccCardProxy extends Handler implements IccCard {
     @Override
     public boolean hasIccCard() {
         synchronized (mLock) {
+            // MTK
+            /*
             if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
                 return true;
             }
             return false;
+            */
+            boolean isSimInsert = false;
+
+            // To obtain correct status earily,
+            // we use system property value to detemine sim inserted state.
+            String iccId = null;
+            iccId = SystemProperties.get(PROPERTY_ICCID_SIM[mPhoneId]);
+
+            if (DBG) log("iccId = " + iccId);
+            if ((iccId != null) && !(iccId.equals("")) && !(iccId.equals(ICCID_STRING_FOR_NO_SIM))) {
+                isSimInsert = true;
+            }
+
+            if (!isSimInsert && mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                isSimInsert = true;
+            }
+
+            if (DBG) log("hasIccCard(): isSimInsert =  " + isSimInsert + " ,CardState = " + ((mUiccCard != null) ? mUiccCard.getCardState() : ""));
+
+            return isSimInsert;
         }
     }
 
@@ -909,11 +1050,11 @@ public class IccCardProxy extends Handler implements IccCard {
         return mIccRecords;
     }
     private void log(String s) {
-        Rlog.d(LOG_TAG, s);
+        Rlog.d(LOG_TAG, s /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     private void loge(String msg) {
-        Rlog.e(LOG_TAG, msg);
+        Rlog.e(LOG_TAG, msg /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
@@ -948,4 +1089,214 @@ public class IccCardProxy extends Handler implements IccCard {
 
         pw.flush();
     }
+
+    // MTK
+
+    private static final int EVENT_ICC_REFRESH = 12;
+
+    private static final int EVENT_ICC_RECOVERY = 100;
+    private static final int EVENT_ICC_FDN_CHANGED = 101;
+    private static final int EVENT_NOT_AVAILABLE = 102;
+
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
+    // private PersoSubState mNetworkLockState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
+
+
+    private static final String ICCID_STRING_FOR_NO_SIM = "N/A";
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    private static final String COMMON_SLOT_PROPERTY = "";
+    private static Intent sInternalIntent = null;
+
+    /**
+     * Refresh and load all of sim files if active phone is switched to svltephone.
+     */
+    public void updateIccRefresh() {
+        sendMessage(obtainMessage(EVENT_ICC_REFRESH));
+    }
+
+    @Override
+    public void supplyNetworkDepersonalization(String pin, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.supplyNetworkDepersonalization(pin, onComplete);
+            } else if (onComplete != null) {
+                Exception e = new RuntimeException("CommandsInterface is not set.");
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Query the SIM ME Lock type required to unlock.
+     *
+     * @return SIM ME Lock type
+     */
+    public PersoSubState getNetworkPersoType() {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                return mUiccApplication.getPersoSubState();
+            }
+            return PersoSubState.PERSOSUBSTATE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    @Override
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  " + category);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.queryIccNetworkLock(category, onComplete);
+            } else if (onComplete != null) {
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to queryIccNetworkLock, hasIccCard = " + hasIccCard());
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    @Override
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = " + category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.setIccNetworkLockEnabled(
+                    category, lockop, password, data_imsi, gid1, gid2, onComplete);
+            } else if (onComplete != null) {
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccNetworkLockEnabled, hasIccCard = " + hasIccCard());
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Used by SIM ME lock related enhancement feature(Modem SML change feature).
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent) {
+        if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
+        synchronized (mLock) {
+            mUiccController.repollIccStateForModemSmlChangeFeatrue(mPhoneId, needIntent);
+        }
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                              int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.exchangeSimIo(fileID, command, p1, p2, p3, pathID,
+                        data, pin2, onComplete);
+            }
+        }
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.iccGetAtr(onComplete);
+            }
+        }
+    }
+
+    public void openLogicalChannelWithSw(String AID, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.iccOpenChannelWithSw(AID, onComplete);
+            }
+        }
+    }
+
+    // retrun usim property or use uicccardapplication app type
+    public String getIccCardType() {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                return mUiccCard.getIccCardType();
+            }
+            return "";
+        }
+    }
+
+    // MTK-START
+    /**
+     * Request to get SVLTE UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType() {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                return mUiccCard.getSvlteCardType();
+            }
+            return 0;
+        }
+    }
+    // MTK-END
+
+    public void registerForRecovery(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+
+            mRecoveryRegistrants.add(r);
+
+            if (getState() == State.READY) {
+                r.notifyRegistrant();
+            }
+        }
+    }
+
+    public void unregisterForRecovery(Handler h) {
+        synchronized (mLock) {
+            mRecoveryRegistrants.remove(h);
+        }
+    }
+
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    @Override
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            synchronized (mLock) {
+                Registrant r = new Registrant(h, what, obj);
+
+                mFdnChangedRegistrants.add(r);
+
+                if (getIccFdnEnabled()) {
+                    r.notifyRegistrant();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccRecords.java b/src/java/com/android/internal/telephony/uicc/IccRecords.java
index 71673bc..8eba778 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRecords.java
@@ -601,6 +601,13 @@ public abstract class IccRecords extends Handler implements IccConstants {
 
     protected abstract void handleFileUpdate(int efid);
 
+    // xen0n
+    protected void handleFileUpdate(int[] efids) {
+        for (int efid : efids) {
+            handleFileUpdate(efid);
+        }
+    }
+
     protected void broadcastRefresh() {
     }
 
diff --git a/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java b/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
index c1d29f8..44d6809 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
@@ -27,14 +27,21 @@ public class IccRefreshResponse {
     public static final int REFRESH_RESULT_FILE_UPDATE = 0; /* Single file was updated */
     public static final int REFRESH_RESULT_INIT = 1;        /* The Icc has been initialized */
     public static final int REFRESH_RESULT_RESET = 2;       /* The Icc was reset */
+    // MTK
+    public static final int REFRESH_RESULT_APP_INIT = 3; /* UICC APP reset, for wifi calling */
+    public static final int REFRESH_INIT_FULL_FILE_UPDATED = 4;  /* SIM init and full file upload */
+    public static final int REFRESH_INIT_FILE_UPDATED = 5;  /* SIM init and single file updated */
 
     public int             refreshResult;      /* Sim Refresh result */
-    public int             efId;               /* EFID */
+    public int[]           efId;               /* EFID */
     public String          aid;                /* null terminated string, e.g.,
                                                   from 0xA0, 0x00 -> 0x41,
                                                   0x30, 0x30, 0x30 */
                                                /* Example: a0000000871002f310ffff89080000ff */
 
+    // MTK
+    public int             sessionId;          /* active channel id */
+
     @Override
     public String toString() {
         return "{" + refreshResult + ", " + aid +", " + efId + "}";
diff --git a/src/java/com/android/internal/telephony/uicc/SpnOverride.java b/src/java/com/android/internal/telephony/uicc/SpnOverride.java
index 3a01af6..19bb062 100644
--- a/src/java/com/android/internal/telephony/uicc/SpnOverride.java
+++ b/src/java/com/android/internal/telephony/uicc/SpnOverride.java
@@ -26,11 +26,23 @@ import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 import android.os.Environment;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 import android.util.Xml;
 
 import com.android.internal.util.XmlUtils;
 
+import java.util.ArrayList;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneConstants;
+import android.telephony.SubscriptionManager;
+import android.content.Context;
+
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 public class SpnOverride {
     private HashMap<String, String> mCarrierSpnMap;
 
@@ -42,6 +54,36 @@ public class SpnOverride {
     SpnOverride () {
         mCarrierSpnMap = new HashMap<String, String>();
         loadSpnOverrides();
+
+        // xen0n: initialize the static contents only once
+        // race conditions can be ignored as the init operations should be
+        // idempotent
+        // MTK-START
+        // MVNO-API
+        // EF_SPN
+        if (CarrierVirtualSpnMapByEfSpn == null) {
+            CarrierVirtualSpnMapByEfSpn = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfSpn();
+        }
+
+        // IMSI
+        if (CarrierVirtualSpnMapByImsi == null) {
+            this.CarrierVirtualSpnMapByImsi = new ArrayList();
+            this.loadVirtualSpnOverridesByImsi();
+        }
+
+        // EF_PNN
+        if (CarrierVirtualSpnMapByEfPnn == null) {
+            CarrierVirtualSpnMapByEfPnn = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfPnn();
+        }
+
+        // EF_GID1
+        if (CarrierVirtualSpnMapByEfGid1 == null) {
+            CarrierVirtualSpnMapByEfGid1 = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfGid1();
+        }
+        // MTK-END
     }
 
     boolean containsCarrier(String carrier) {
@@ -111,4 +153,428 @@ public class SpnOverride {
         }
     }
 
+    // MTK
+
+    // MTK-START
+    private static SpnOverride sInstance;
+    static final Object sInstSync = new Object();
+
+    // MVNO-API START
+    // EF_SPN
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfSpn;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efspn.xml";
+
+    // IMSI
+    private ArrayList CarrierVirtualSpnMapByImsi;
+    private static final String PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH = "etc/virtual-spn-conf-by-imsi.xml";
+
+    // EF_PNN
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfPnn;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efpnn.xml";
+
+    // EF_GID1
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfGid1;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efgid1.xml";
+
+    public class VirtualSpnByImsi {
+        public String pattern;
+        public String name;
+        public VirtualSpnByImsi(String pattern, String name) {
+            this.pattern = pattern;
+            this.name = name;
+        }
+    }
+    // MVNO-API END
+
+    public static SpnOverride getInstance() {
+        synchronized (sInstSync) {
+            if (sInstance == null) {
+                sInstance = new SpnOverride();
+            }
+        }
+        return sInstance;
+    }
+    // MTK-END
+
+    // MTK-START
+    // MVNO-API START
+    private static void loadVirtualSpnOverridesByEfSpn() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfSpn");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfSpn");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncspn = parser.getAttributeValue(null, "mccmncspn");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncspn = " + mccmncspn + ", name = " + spn);
+                CarrierVirtualSpnMapByEfSpn.put(mccmncspn, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efspn parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efspn parser " + e);
+        }
+    }
+
+    public String getSpnByEfSpn(String mccmnc, String spn) {
+        if (mccmnc == null || spn == null || mccmnc.isEmpty() || spn.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfSpn.get(mccmnc + spn);
+    }
+
+    private void loadVirtualSpnOverridesByImsi() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByImsi");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByImsi");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String imsipattern = parser.getAttributeValue(null, "imsipattern");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test imsipattern = " + imsipattern + ", name = " + spn);
+                this.CarrierVirtualSpnMapByImsi.add(new VirtualSpnByImsi(imsipattern, spn));
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-imsi parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-imsi parser " + e);
+        }
+    }
+
+    public String getSpnByImsi(String mccmnc, String imsi) {
+        if (mccmnc == null || imsi == null || mccmnc.isEmpty() || imsi.isEmpty())
+            return null;
+
+        VirtualSpnByImsi vsbi;
+        for (int i = 0; i < this.CarrierVirtualSpnMapByImsi.size(); i++) {
+            vsbi = (VirtualSpnByImsi) (this.CarrierVirtualSpnMapByImsi.get(i));
+            Rlog.w(LOG_TAG, "getSpnByImsi(): mccmnc = " + mccmnc + ", imsi = " +
+                    imsi + ", pattern = " + vsbi.pattern);
+
+            if (imsiMatches(vsbi.pattern, mccmnc + imsi) == true) {
+                return vsbi.name;
+            }
+        }
+        return null;
+    }
+
+    public String isOperatorMvnoForImsi(String mccmnc, String imsi) {
+        if (mccmnc == null || imsi == null || mccmnc.isEmpty() || imsi.isEmpty())
+            return null;
+
+        VirtualSpnByImsi vsbi;
+        String pattern;
+        for (int i = 0; i < this.CarrierVirtualSpnMapByImsi.size(); i++) {
+            vsbi = (VirtualSpnByImsi) (this.CarrierVirtualSpnMapByImsi.get(i));
+            Rlog.w(LOG_TAG, "isOperatorMvnoForImsi(): mccmnc = " + mccmnc +
+                    ", imsi = " + imsi + ", pattern = " + vsbi.pattern);
+
+            if (imsiMatches(vsbi.pattern, mccmnc + imsi) == true) {
+                return vsbi.pattern;
+            }
+        }
+        return null;
+    }
+
+   private boolean imsiMatches(String imsiDB, String imsiSIM) {
+        // Note: imsiDB value has digit number or 'x' character for seperating USIM information
+        // for MVNO operator. And then digit number is matched at same order and 'x' character
+        // could replace by any digit number.
+        // ex) if imsiDB inserted '310260x10xxxxxx' for GG Operator,
+        //     that means first 6 digits, 8th and 9th digit
+        //     should be set in USIM for GG Operator.
+        int len = imsiDB.length();
+        int idxCompare = 0;
+
+        Rlog.w(LOG_TAG, "mvno match imsi = " + imsiSIM + "pattern = " + imsiDB);
+        if (len <= 0) return false;
+        if (len > imsiSIM.length()) return false;
+
+        for (int idx = 0; idx < len; idx++) {
+            char c = imsiDB.charAt(idx);
+            if ((c == 'x') || (c == 'X') || (c == imsiSIM.charAt(idx))) {
+                continue;
+            } else {
+                return false;
+            }
+        }
+        return true;
+    }
+    private static void loadVirtualSpnOverridesByEfPnn() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfPnn");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfPnn");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncpnn = parser.getAttributeValue(null, "mccmncpnn");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncpnn = " + mccmncpnn + ", name = " + spn);
+                CarrierVirtualSpnMapByEfPnn.put(mccmncpnn, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efpnn parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efpnn parser " + e);
+        }
+    }
+
+    public String getSpnByEfPnn(String mccmnc, String pnn) {
+        if (mccmnc == null || pnn == null || mccmnc.isEmpty() || pnn.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfPnn.get(mccmnc + pnn);
+    }
+
+    private static void loadVirtualSpnOverridesByEfGid1() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfGid1");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfGid1");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncgid1 = parser.getAttributeValue(null, "mccmncgid1");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncgid1 = " + mccmncgid1 + ", name = " + spn);
+                CarrierVirtualSpnMapByEfGid1.put(mccmncgid1, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efgid1 parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efgid1 parser " + e);
+        }
+    }
+
+    public String getSpnByEfGid1(String mccmnc, String gid1) {
+        if (mccmnc == null || gid1 == null || mccmnc.isEmpty() || gid1.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfGid1.get(mccmnc + gid1);
+    }
+
+    public String lookupOperatorName(int subId, String numeric, boolean desireLongName, Context context) {
+        String operName = numeric;
+        Phone phone = null;
+        // MTK TODO
+        /*
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            if (subId == SubscriptionManager.LTE_DC_SUB_ID_1) {
+                phone = SvlteUtils.getSvltePhoneProxy(PhoneConstants.SIM_ID_1)
+                    .getLtePhone();
+            } else if (subId == SubscriptionManager.LTE_DC_SUB_ID_2) {
+                phone = SvlteUtils.getSvltePhoneProxy(PhoneConstants.SIM_ID_2)
+                    .getLtePhone();
+            } else {
+                phone = PhoneFactory.getPhone(SubscriptionManager.getPhoneId(subId));
+            }
+        } else {
+        */
+            phone = PhoneFactory.getPhone(SubscriptionManager.getPhoneId(subId));
+        // }
+
+        // MVNO-API
+        String mvnoOperName = null;
+
+        if (phone == null) {
+            Rlog.w(LOG_TAG, "lookupOperatorName getPhone null");
+            return operName;
+        }
+
+        // MTK TODO
+        /*
+        mvnoOperName = getSpnByEfSpn(numeric,
+                phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_SPN));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_SPN: " + mvnoOperName);
+        */
+
+        if (mvnoOperName == null) // determine by IMSI
+            mvnoOperName = getSpnByImsi(numeric, phone.getSubscriberId());
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by IMSI: " + mvnoOperName);
+
+        // MTK TODO
+        /*
+        if (mvnoOperName == null)
+            mvnoOperName = getSpnByEfPnn(numeric,
+                    phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_PNN));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_PNN: " + mvnoOperName);
+
+        if (mvnoOperName == null)
+            mvnoOperName = getSpnByEfGid1(numeric,
+                    phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_GID));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_GID1: " + mvnoOperName);
+        */
+
+        if (mvnoOperName != null)
+            operName = mvnoOperName;
+
+        boolean getFromResource = false;
+        String ctName = null;  // context.getText(com.mediatek.internal.R.string.ct_name).toString();
+        Rlog.d(LOG_TAG, "ctName:" + ctName);
+        if (ctName != null && ctName.equals(mvnoOperName)) {
+            Rlog.d(LOG_TAG, "Get from resource.");
+            getFromResource = true;
+            mvnoOperName = null;
+        }
+
+        if (mvnoOperName == null && desireLongName) { // MVNO-API
+            // ALFMS00040828 - add "46008"
+            /*
+            if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46000).toString();
+            } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46001).toString();
+            } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46003).toString();
+            } else if (numeric.equals("46601")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46601).toString();
+            } else if (numeric.equals("46692")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46692).toString();
+            } else if (numeric.equals("46697")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46697).toString();
+            } else if (numeric.equals("99998")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_99998).toString();
+            } else if (numeric.equals("99999")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_99999).toString();
+            } else {
+            */
+                // If can't found corresspoding operator in string resource, lookup from spn_conf.xml
+                if (containsCarrier(numeric)) {
+                    operName = getSpn(numeric);
+                } else {
+                    Rlog.w(LOG_TAG, "Can't find long operator name for " + numeric);
+                }
+            // }
+        }
+        else if (mvnoOperName == null && desireLongName == false) // MVNO-API
+        {
+            // ALFMS00040828 - add "46008"
+            /*
+            if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46000).toString();
+            } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46001).toString();
+            } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46003).toString();
+            } else if (numeric.equals("46601")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46601).toString();
+            } else if (numeric.equals("46692")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46692).toString();
+            } else if (numeric.equals("46697")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46697).toString();
+            } else if (numeric.equals("99997")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_99997).toString();
+            } else if (numeric.equals("99999")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_99999).toString();
+            } else {
+            */
+                Rlog.w(LOG_TAG, "Can't find short operator name for " + numeric);
+            // }
+        }
+
+        return operName;
+    }
+
+    public String lookupOperatorNameForDisplayName(int subId,
+            String numeric, boolean desireLongName, Context context) {
+        // xen0n: don't know why the original author duplicated ALL code of
+        // lookupOperatorName() with only the FIRST line modified...
+        return lookupOperatorName(subId, numeric, desireLongName, context);
+    }
+    // MVNO-API END
+
+    public boolean containsCarrierEx(String carrier) {
+        return containsCarrier(carrier);
+    }
+
+    public String getSpnEx(String carrier) {
+        return getSpn(carrier);
+    }
+    // MTK-END
+
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCard.java b/src/java/com/android/internal/telephony/uicc/UiccCard.java
index 00674f1..071a059 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCard.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCard.java
@@ -52,6 +52,8 @@ import android.view.WindowManager;
 
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.CommandsInterface.RadioState;
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.gsm.GSMPhone;
@@ -63,6 +65,10 @@ import com.android.internal.telephony.cdma.CDMALTEPhone;
 import com.android.internal.telephony.cdma.CDMAPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
 
+// import com.mediatek.internal.telephony.IccCardType.SvlteCardType;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+
 import android.os.SystemProperties;
 
 import com.android.internal.R;
@@ -147,42 +153,136 @@ public class UiccCard {
             mUiccApplications = null;
             mCarrierPrivilegeRules = null;
             mUICCConfig = null;
+
+            // MTK
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && mIsSvlte) {
+                mSvlteCi.unregisterForEusimReady(mHandler);
+                mCi.unregisterForCdmaCardType(mHandler);
+            }
         }
     }
 
     public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
+        update(c, ci, ics, true);
+    }
+
+    // with MTK extension
+    public void update(Context c, CommandsInterface ci, IccCardStatus ics, boolean isUpdateSimInfo) {
         synchronized (mLock) {
             CardState oldState = mCardState;
             mCardState = ics.mCardState;
             mUniversalPinState = ics.mUniversalPinState;
-            mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
-            mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+            // MTK SVLTE
+            // mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+            // mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
             mImsSubscriptionAppIndex = ics.mImsSubscriptionAppIndex;
             mContext = c;
             mCi = ci;
 
+            // MTK-START
+            // check the UiccCard type.
+            int targetIndex = -1;
+            log("update mIsSvlte=" + mIsSvlte);
+            if (mIsSvlte) {
+                IccCardApplicationStatus.AppType appType =
+                        IccCardApplicationStatus.AppType.APPTYPE_UNKNOWN;
+                for (int i = 0; i < ics.mApplications.length; i++) {
+                    if (ics.mApplications[i] != null &&
+                            (ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_CSIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_RUIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_SIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_USIM)) {
+                        appType = ics.mApplications[i].app_type;
+                        break;
+                    }
+                }
+                log("update appType=" + appType);
+                if (appType == IccCardApplicationStatus.AppType.APPTYPE_CSIM ||
+                    appType == IccCardApplicationStatus.AppType.APPTYPE_RUIM) {
+                    mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+                    targetIndex = mCdmaSubscriptionAppIndex;
+                    //Reset gsm index if to conflict with cdma index
+                    if (targetIndex == mGsmUmtsSubscriptionAppIndex) {
+                        mGsmUmtsSubscriptionAppIndex = -1;
+                        log("reset mGsmUmtsSubscriptionAppIndex to "
+                            + mGsmUmtsSubscriptionAppIndex);
+                    }
+                } else if (appType == IccCardApplicationStatus.AppType.APPTYPE_SIM
+                        || appType == IccCardApplicationStatus.AppType.APPTYPE_USIM) {
+                    mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+                    targetIndex = mGsmUmtsSubscriptionAppIndex;
+                    //Reset cdma index if to conflict with gsm index
+                    if (targetIndex == mCdmaSubscriptionAppIndex) {
+                        mCdmaSubscriptionAppIndex = -1;
+                        log("reset mCdmaSubscriptionAppIndex to "
+                            + mCdmaSubscriptionAppIndex);
+                    }
+                } else {
+                    loge("update, but appType: " + appType);
+                }
+            } else {
+                mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+                mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+            }
+
+            log("update targetIndex=" + targetIndex +
+                    "  mGsmUmtsSubscriptionAppIndex=" + mGsmUmtsSubscriptionAppIndex +
+                    "  mCdmaSubscriptionAppIndex=" + mCdmaSubscriptionAppIndex +
+                    "  mUiccApplications.length=" + mUiccApplications.length);
+            // MTK-END
+
             //update applications
             if (mUICCConfig == null)
                 mUICCConfig = new UICCConfig();
             if (DBG) log(ics.mApplications.length + " applications");
             for ( int i = 0; i < mUiccApplications.length; i++) {
+                // MTK-START
+                if (targetIndex != i && targetIndex >= 0) {
+                    continue;
+                }
+                log("mUiccApplications[i]=" + mUiccApplications[i]);
+                // MTK-END
                 if (mUiccApplications[i] == null) {
                     //Create newly added Applications
                     if (i < ics.mApplications.length) {
                         mUiccApplications[i] = new UiccCardApplication(this,
-                                ics.mApplications[i], mContext, mCi);
+                                ics.mApplications[i], mContext,
+                                (mIsSvlte && targetIndex == mGsmUmtsSubscriptionAppIndex) ? mSvlteCi : mCi);
+                        log("new mUiccApplications[" + i + "]");
                     }
                 } else if (i >= ics.mApplications.length) {
                     //Delete removed applications
-                    mUiccApplications[i].dispose();
-                    mUiccApplications[i] = null;
+                    // MTK
+                    if (mUiccApplications[i] != null) {
+                        mUiccApplications[i].dispose();
+                        mUiccApplications[i] = null;
+                        log("dispose mUiccApplications[" + i + "]");
+                    }
                 } else {
                     //Update the rest
-                    mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
+                    // MTK
+                    if (mUiccApplications[i] != null) {
+                        mUiccApplications[i].update(ics.mApplications[i], mContext,
+                                (mIsSvlte && targetIndex == mGsmUmtsSubscriptionAppIndex) ?  mSvlteCi : mCi);
+                        log("update mUiccApplications[" + i + "]");
+                    }
                 }
             }
 
-            createAndUpdateCatService();
+            // MTK
+            if (mIsSvlte) {
+                if (targetIndex == mGsmUmtsSubscriptionAppIndex) {
+                    createAndUpdateCatService(mSvlteCi);
+                } else {
+                    //no need to create catservice for csim and ruim.
+                }
+            } else {
+                createAndUpdateCatService(mCi);
+            }
 
             // Reload the carrier privilege rules if necessary.
             log("Before privilege rules: " + mCarrierPrivilegeRules + " : " + mCardState);
@@ -197,8 +297,9 @@ public class UiccCard {
 
             RadioState radioState = mCi.getRadioState();
             if (DBG) log("update: radioState=" + radioState + " mLastRadioState="
-                    + mLastRadioState);
+                    + mLastRadioState /* MTK */ + " isUpdateSimInfo= " + isUpdateSimInfo);
             // No notifications while radio is off or we just powering up
+            if (isUpdateSimInfo) {  // MTK
             if (radioState == RadioState.RADIO_ON && mLastRadioState == RadioState.RADIO_ON) {
                 if (oldState != CardState.CARDSTATE_ABSENT &&
                         mCardState == CardState.CARDSTATE_ABSENT) {
@@ -211,6 +312,7 @@ public class UiccCard {
                     mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED, null));
                 }
             }
+            }  // MTK
             if (mCi.needsOldRilFeature("simactivation")) {
                 if (mCardState == CardState.CARDSTATE_PRESENT) {
                     if (!mDefaultAppsActivated) {
@@ -228,13 +330,15 @@ public class UiccCard {
         }
     }
 
-    protected void createAndUpdateCatService() {
+    // MTK
+    // protected void createAndUpdateCatService() {
+    protected void createAndUpdateCatService(CommandsInterface ci) {
         if (mUiccApplications.length > 0 && mUiccApplications[0] != null) {
             // Initialize or Reinitialize CatService
             if (mCatService == null) {
-                mCatService = CatService.getInstance(mCi, mContext, this, mPhoneId);
+                mCatService = CatService.getInstance(ci /* mCi */, mContext, this, mPhoneId);
             } else {
-                ((CatService)mCatService).update(mCi, mContext, this);
+                ((CatService)mCatService).update(ci /* mCi */, mContext, this);
             }
         } else {
             if (mCatService != null) {
@@ -265,6 +369,13 @@ public class UiccCard {
                 checkIndex(mCdmaSubscriptionAppIndex, AppType.APPTYPE_RUIM, AppType.APPTYPE_CSIM);
         mImsSubscriptionAppIndex =
                 checkIndex(mImsSubscriptionAppIndex, AppType.APPTYPE_ISIM, null);
+
+        // MTK
+        if (DBG) {
+            log("sanitizeApplicationIndexes  GSM index= " + mGsmUmtsSubscriptionAppIndex +
+                    "  CDMA index = " + mCdmaSubscriptionAppIndex + "  IMS index = "
+                    + mImsSubscriptionAppIndex);
+        }
     }
 
     private int checkIndex(int index, AppType expectedAppType, AppType altExpectedAppType) {
@@ -278,6 +389,16 @@ public class UiccCard {
             return -1;
         }
 
+        // MTK-START
+        if (mUiccApplications[index] == null) {
+            loge("App index " + index + " is null since there are no applications");
+            return -1;
+        }
+
+        log("checkIndex mUiccApplications[" + index + "].getType()= "
+            + mUiccApplications[index].getType());
+        // MTK-END
+
         if (mUiccApplications[index].getType() != expectedAppType &&
             mUiccApplications[index].getType() != altExpectedAppType) {
             loge("App index " + index + " is invalid since it's not " +
@@ -488,6 +609,10 @@ public class UiccCard {
                 case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
                 case EVENT_SIM_IO_DONE:
                 case EVENT_SIM_GET_ATR_DONE:
+                // MTK-START
+                case EVENT_GET_ATR_DONE:
+                case EVENT_OPEN_CHANNEL_WITH_SW_DONE:
+                // MTK-END
                     AsyncResult ar = (AsyncResult)msg.obj;
                     if (ar.exception != null) {
                         loglocal("Exception: " + ar.exception);
@@ -499,6 +624,64 @@ public class UiccCard {
                 case EVENT_CARRIER_PRIVILIGES_LOADED:
                     onCarrierPriviligesLoadedMessage();
                     break;
+                // MTK-START
+                case EVENT_CDMA_CARD_IMSI_DONE:
+                    log("Handler EVENT_CDMA_CARD_IMSI_DONE mIsSvlte=" + mIsSvlte);
+                    if (mIsSvlte && mUiccApplications != null) {
+                        if (mGsmUmtsSubscriptionAppIndex >= 0
+                            && mUiccApplications[mGsmUmtsSubscriptionAppIndex] != null
+                            && mCdmaSubscriptionAppIndex >= 0
+                            && mUiccApplications[mCdmaSubscriptionAppIndex] != null) {
+                            mCsimRecords =
+                                mUiccApplications[mCdmaSubscriptionAppIndex].getIccRecords();
+                            mUsimRecords =
+                                mUiccApplications[mGsmUmtsSubscriptionAppIndex].getIccRecords();
+                            if ((mUsimRecords != null) || (mCsimRecords != null)) {
+                                if ((mUsimRecords.getIMSI() != null)
+                                    && (mUsimRecords.getIMSI() != mCdmaUsimImsi)
+                                    && (mCsimRecords.getIMSI() != null)
+                                    && (mCsimRecords.getIMSI() != mCdmaCsimImsi)) {
+                                    mCdmaUsimImsi = mUsimRecords.getIMSI();
+                                    mCdmaCsimImsi = mCsimRecords.getIMSI();
+                                    broadcastCdmaCardImsiIntent();
+                                }
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_CDMA_CARD_TYPE:
+                    if (DBG) {
+                        log("handleMessgage (EVENT_CDMA_CARD_TYPE)");
+                    }
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception == null) {
+                        int[] resultType = (int[]) ar.result;
+                        if (resultType != null) {
+                            loge("SvlteCardType: TODO!");
+                            /*
+                            mSvlteCardType = SvlteCardType.getCardTypeFromInt(resultType[0]);
+                            if (mSvlteCardType.isValidCardType()) {
+                                broadcastSvlteCardTypeChanged(mPhoneId, mSvlteCardType.getValue());
+                            } else {
+                                log("invalid cardType=" + resultType[0]);
+                            }
+                            */
+                        }
+                    }
+                    break;
+                case EVENT_C2K_WP_CARD_TYPE_READY:
+                    if (DBG) {
+                        log("handleMessgage (EVENT_C2K_WP_CARD_TYPE_READY)");
+                    }
+                    loge("SvlteCardType: TODO!");
+                    /*
+                    mSvlteCardType = SvlteCardType.transformCardTypeFromString(getIccCardType());
+                    if (mSvlteCardType.isValidCardType()) {
+                        broadcastSvlteCardTypeChanged(mPhoneId, mSvlteCardType.getValue());
+                    }
+                    */
+                    break;
+                 // MTK-END
                 default:
                     loge("Unknown Event " + msg.what);
             }
@@ -779,11 +962,11 @@ public class UiccCard {
     }
 
     private void log(String msg) {
-        Rlog.d(LOG_TAG, msg);
+        Rlog.d(LOG_TAG, msg /* MTK */  + " (phoneId " + mPhoneId + ")");
     }
 
     private void loge(String msg) {
-        Rlog.e(LOG_TAG, msg);
+        Rlog.e(LOG_TAG, msg /* MTK */  + " (phoneId " + mPhoneId + ")");
     }
 
     private void loglocal(String msg) {
@@ -854,4 +1037,259 @@ public class UiccCard {
         mLocalLog.dump(fd, pw, args);
         pw.flush();
     }
+
+    // MTK
+
+    private static final int EVENT_GET_ATR_DONE = 100;
+    private static final int EVENT_OPEN_CHANNEL_WITH_SW_DONE = 101;
+    private static final int EVENT_CDMA_CARD_IMSI_DONE = 102;
+    private static final int EVENT_CDMA_CARD_TYPE = 103;
+    private static final int EVENT_C2K_WP_CARD_TYPE_READY = 104;
+
+    static final String[] UICCCARD_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+
+    private String mIccType = null; /* Add for USIM detect */
+    private CommandsInterface mSvlteCi; /* Add for C2K SVLTE */
+    private boolean mIsSvlte = false;
+    private static final String[]  PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+
+    private IccRecords mUsimRecords = null;
+    private IccRecords mCsimRecords = null;
+    private String mCdmaCsimImsi = null;
+    private String mCdmaUsimImsi = null;
+    private boolean mCsimRigisterDone = false;
+    private boolean mUsimRigisterDone = false;
+
+    // private SvlteCardType mSvlteCardType = SvlteCardType.UNKNOW_CARD;
+
+    public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int phoneId, boolean isUpdateSiminfo) {
+        if (DBG) log("Creating simId " + phoneId + ",isUpdateSiminfo" + isUpdateSiminfo);
+        mCardState = ics.mCardState;
+        mPhoneId = phoneId;
+        update(c, ci, ics, isUpdateSiminfo);
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        mCi.iccIO(command, fileID, pathID, p1, p2, p3, data, pin2,
+              mHandler.obtainMessage(EVENT_SIM_IO_DONE, onComplete));
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        mCi.iccGetATR(mHandler.obtainMessage(EVENT_GET_ATR_DONE, onComplete));
+    }
+
+    public String getIccCardType() {
+        //int slot = -1;
+        //if (SubscriptionController.getInstance() != null) {
+        //    slot = SubscriptionController.getInstance().getSlotId(
+        //            SubscriptionController.getInstance().getSubIdUsingPhoneId(
+        //            mPhoneId));
+        //    mIccType = SystemProperties.get(UICCCARD_PROPERTY_RIL_UICC_TYPE[slot]);
+        //}
+        mIccType = SystemProperties.get(UICCCARD_PROPERTY_RIL_UICC_TYPE[mPhoneId]);
+        if (DBG) log("getIccCardType(): iccType = " + mIccType + ", slot " + mPhoneId);
+        return mIccType;
+    }
+
+    public String[] getFullIccCardType() {
+        return SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[mPhoneId]).split(",");
+    }
+
+    // MTK-START
+    /**
+     * Request to get SVLTE UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType() {
+        // MTK TODO
+        /*
+        if (DBG) {
+            log("getSvlteCardType(): mSvlteCardType = " + mSvlteCardType.getValue()
+                    + ", slot " + mPhoneId);
+        }
+        return mSvlteCardType.getValue();
+        */
+        loge("getSvlteCardType: TODO!");
+        return 0;
+    }
+
+    private void broadcastSvlteCardTypeChanged(int slotId, int cardType) {
+        Intent i = new Intent(TelephonyIntents.ACTION_SVLTE_CARD_TYPE);
+        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        i.putExtra(PhoneConstants.SLOT_KEY, slotId);
+        i.putExtra(TelephonyIntents.INTENT_KEY_SVLTE_CARD_TYPE, cardType);
+        log("Broadcasting intent ACTION_SVLTE_CARD_TYPE, slotId " +
+                slotId + ", cardType " + cardType);
+        ActivityManagerNative.broadcastStickyIntent(i, READ_PHONE_STATE,
+                UserHandle.USER_ALL);
+    }
+    // MTK-END
+
+    public void iccOpenChannelWithSw(String AID, Message onComplete) {
+        mCi.iccOpenChannelWithSw(AID,
+            mHandler.obtainMessage(EVENT_OPEN_CHANNEL_WITH_SW_DONE, onComplete));
+    }
+
+    //For C2K SVLTE
+    /**
+     * UiccCard for SVLTE.
+     * @param c  Context
+     * @param ci CommandsInterface
+     * @param ics IccCardStatus
+     * @param slotId Card slot id
+     * @param svlteCi CommandsInterface
+     */
+    public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int phoneId,
+        CommandsInterface svlteCi) {
+        if (DBG) {
+            log("Creating phoneId " + phoneId + ",svlteCi" + svlteCi);
+        }
+        // MTK-START
+        // MTK TODO
+        /*
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            mIsSvlte = true;
+            mSvlteCi = svlteCi;
+            UiccController.getInstance().registerForC2KWPCardTypeReady(mHandler,
+                EVENT_C2K_WP_CARD_TYPE_READY, null);
+            ci.registerForCdmaCardType(mHandler, EVENT_CDMA_CARD_TYPE, null);
+        }
+        */
+        // MTK-END
+        mCardState = ics.mCardState;
+        mPhoneId = phoneId;
+        update(c, ci, ics);
+    }
+    /**
+     * Set LTE flag.
+     * @param isSvlte svlte flag
+    */
+    /*
+    public void setSvlteFlag(boolean isSvlte) {
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            mIsSvlte = isSvlte;
+        } else {
+            log("setSvlteFlag Error");
+        }
+        log("setSvlteFlag mIsSvlte:" + mIsSvlte);
+    }
+    */
+    //Update LTE UiccApplication
+    /*public void update(Context c, CommandsInterface ci, IccCardStatus ics,
+        CommandsInterface svlteCi) {
+        log("update svlteCi");
+        mSvlteCi = svlteCi;
+        update(c, ci, ics);
+    }*/
+    /*
+    private void configModemRemoteSimAccess() {
+        String cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[0]);
+        Rlog.d(LOG_TAG, "configModemRemoteSimAccess cardType=" + cardType);
+        String appType[] = cardType.split(",");
+        int type = 0;
+        for (int i = 0; i < appType.length; i++) {
+            if ("USIM".equals(appType[i]) || "SIM".equals(appType[i])) {
+                Rlog.d(LOG_TAG, "UiccCard cardType: contain USIM/SIM");
+                type |= 0x01;
+                continue;
+            } else if ("CSIM".equals(appType[i]) || "RUIM".equals(appType[i])) {
+                Rlog.d(LOG_TAG, "UiccCard cardType: contain CSIM/RUIM");
+                type |= 0x02;
+                continue;
+            }
+        }
+        switch (type) {
+            case 0:
+                // no card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            case 1:
+                // GSM only card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            case 2:
+                // UIM only card
+                mCi.configModemStatus(1, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(1, 1, null);
+                }
+                break;
+            case 3:
+                // LTE card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            default:
+                break;
+            }
+    }
+    */
+
+    /**
+    * This funtion is to register for card imsi done.
+    * @param index int uicc card index
+    */
+    public void registerCdmaCardImsiDone(int index) {
+        log("registerCdmaCardImsiDone: index =" + index
+            + " mCdmaSubscriptionAppIndex=" + mCdmaSubscriptionAppIndex
+            + " mGsmUmtsSubscriptionAppIndex=" + mGsmUmtsSubscriptionAppIndex);
+        if ((!mCsimRigisterDone) && (index != UiccController.INDEX_SVLTE)) {
+            if (mCdmaSubscriptionAppIndex >= 0
+                && mUiccApplications[mCdmaSubscriptionAppIndex] != null) {
+                mCsimRecords = mUiccApplications[mCdmaSubscriptionAppIndex].getIccRecords();
+                if (mCsimRecords != null) {
+                    mCsimRecords.registerForImsiReady(mHandler, EVENT_CDMA_CARD_IMSI_DONE, null);
+                    mCsimRigisterDone = true;
+                    log("registerCdmaCardImsiDone: index != UiccController.INDEX_SVLTE");
+                }
+            }
+        } else if ((!mUsimRigisterDone) && (index == UiccController.INDEX_SVLTE)) {
+            if (mGsmUmtsSubscriptionAppIndex >= 0
+                && mUiccApplications[mGsmUmtsSubscriptionAppIndex] != null) {
+                mUsimRecords = mUiccApplications[mGsmUmtsSubscriptionAppIndex].getIccRecords();
+                if (mUsimRecords != null) {
+                    mUsimRecords.registerForImsiReady(mHandler, EVENT_CDMA_CARD_IMSI_DONE, null);
+                    mUsimRigisterDone = true;
+                    log("registerCdmaCardImsiDone: index == UiccController.INDEX_SVLTE");
+                }
+            }
+        }
+    }
+
+    private void broadcastCdmaCardImsiIntent() {
+        // MTK TODO
+        /*
+        Intent intent = new Intent(TelephonyIntents.ACTION_CDMA_CARD_IMSI);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_CDMA_CARD_CSIM_IMSI, mCdmaCsimImsi);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_CDMA_CARD_USIM_IMSI, mCdmaUsimImsi);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_SVLTE_MODE_SLOT_ID,
+            SvlteModeController.getActiveSvlteModeSlotId());
+        log("Broadcasting intent broadcastCdmaCardImsiIntent mCdmaCsimImsi=" + mCdmaCsimImsi
+            + " mCdmaUsimImsi=" + mCdmaUsimImsi + " getActiveSvlteModeSlotId() = " +
+            SvlteModeController.getActiveSvlteModeSlotId());
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+        */
+    }
+    // MTK-END
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index f38167e..6a5b942 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -22,9 +22,11 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.TelephonyPluginDelegate;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
@@ -108,9 +110,12 @@ public class UiccCardApplication {
         mContext = c;
         mCi = ci;
 
+        // MTK
+        mPhoneId = mUiccCard.getPhoneId();
+
         mIccFh = createIccFileHandler(as.app_type);
         mIccRecords = createIccRecords(as.app_type, mContext, mCi);
-        if (mAppState == AppState.APPSTATE_READY) {
+        if (mAppState == AppState.APPSTATE_READY /* MTK */ && mAppType != AppType.APPTYPE_ISIM) {
             queryFdn();
             queryPin1State();
         }
@@ -156,7 +161,7 @@ public class UiccCardApplication {
                 if (DBG) log(oldAppType + " changed state: " + oldAppState + " -> " + mAppState);
                 // If the app state turns to APPSTATE_READY, then query FDN status,
                 //as it might have failed in earlier attempt.
-                if (mAppState == AppState.APPSTATE_READY) {
+                if (mAppState == AppState.APPSTATE_READY /* MTK */ && mAppType != AppType.APPTYPE_ISIM) {
                     queryFdn();
                     queryPin1State();
                 }
@@ -179,6 +184,8 @@ public class UiccCardApplication {
     }
 
     private IccRecords createIccRecords(AppType type, Context c, CommandsInterface ci) {
+        if (DBG) log("createIccRecords, AppType = " + type);  // MTK
+
         if (type == AppType.APPTYPE_USIM || type == AppType.APPTYPE_SIM) {
             return TelephonyPluginDelegate.getInstance().makeSIMRecords(this, c, ci);
         } else if (type == AppType.APPTYPE_RUIM || type == AppType.APPTYPE_CSIM){
@@ -252,11 +259,13 @@ public class UiccCardApplication {
     private void onChangeFdnDone(AsyncResult ar) {
         synchronized (mLock) {
             int attemptsRemaining = -1;
+            boolean bNotifyFdnChanged = false;  // MTK
 
             if (ar.exception == null) {
                 mIccFdnEnabled = mDesiredFdnEnabled;
                 if (DBG) log("EVENT_CHANGE_FACILITY_FDN_DONE: " +
                         "mIccFdnEnabled=" + mIccFdnEnabled);
+                bNotifyFdnChanged = true;  // MTK
             } else {
                 attemptsRemaining = parsePinPukErrorResult(ar);
                 loge("Error change facility fdn with exception " + ar.exception);
@@ -265,6 +274,11 @@ public class UiccCardApplication {
             response.arg1 = attemptsRemaining;
             AsyncResult.forMessage(response).exception = ar.exception;
             response.sendToTarget();
+            // MTK
+            if (bNotifyFdnChanged) {
+                log("notifyFdnChangedRegistrants");
+                notifyFdnChangedRegistrants();
+            }
         }
     }
 
@@ -354,13 +368,16 @@ public class UiccCardApplication {
     private int parsePinPukErrorResult(AsyncResult ar) {
         int[] result = (int[]) ar.result;
         if (result == null) {
-            return -1;
+            // xen0n refactored
+            // return -1;
+            return SystemProperties.getInt(PROPERTY_PIN2_RETRY[getSlotId()], -1);
         } else {
             int length = result.length;
             int attemptsRemaining = -1;
             if (length > 0) {
                 attemptsRemaining = result[0];
             }
+            
             log("parsePinPukErrorResult: attemptsRemaining=" + attemptsRemaining);
             return attemptsRemaining;
         }
@@ -414,6 +431,59 @@ public class UiccCardApplication {
                     if (DBG) log("handleMessage (EVENT_RADIO_UNAVAILABLE)");
                     mAppState = AppState.APPSTATE_UNKNOWN;
                     break;
+                // MTK-START
+                // [ALPS01827777]--- START ---
+                // Need to query lock setting since it might be changed when
+                // entering PUK to change PIN.
+                case EVENT_PUK1_CHANGE_PIN1_DONE:
+                    log("EVENT_PUK1_CHANGE_PIN1_DONE");
+                    int attemptsRemainingPuk = -1;
+                    ar = (AsyncResult) msg.obj;
+                    if ((ar.exception != null) && (ar.result != null)) {
+                        attemptsRemainingPuk = parsePinPukErrorResult(ar);
+                    }
+                    Message responsePuk = (Message) ar.userObj;
+                    AsyncResult.forMessage(responsePuk).exception = ar.exception;
+                    responsePuk.arg1 = attemptsRemainingPuk;
+                    responsePuk.sendToTarget();
+                    queryPin1State();
+                    break;
+                case EVENT_PUK2_CHANGE_PIN2_DONE:
+                    int attemptsRemainingPuk2 = -1;
+                    ar = (AsyncResult) msg.obj;
+                    if ((ar.exception != null) && (ar.result != null)) {
+                        attemptsRemainingPuk2 = parsePinPukErrorResult(ar);
+                    }
+                    Message responsePuk2 = (Message) ar.userObj;
+                    AsyncResult.forMessage(responsePuk2).exception = ar.exception;
+                    responsePuk2.arg1 = attemptsRemainingPuk2;
+                    responsePuk2.sendToTarget();
+                    queryFdn();
+                    break;
+                // [ALPS01827777]--- END ---
+                case EVENT_QUERY_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_QUERY_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error query network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage((Message) ar.userObj, ar.result, ar.exception);
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
+                case EVENT_CHANGE_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_CHANGE_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error change network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                                        = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
+                // MTK-END
                 default:
                     loge("Unknown Event " + msg.what);
             }
@@ -588,6 +658,8 @@ public class UiccCardApplication {
                 break;
 
             case APPTYPE_USIM:
+            // MTK
+            case APPTYPE_ISIM:
                 authContext = AUTH_CONTEXT_EAP_AKA;
                 break;
 
@@ -698,7 +770,7 @@ public class UiccCardApplication {
     public void supplyPuk (String puk, String newPin, Message onComplete) {
         synchronized (mLock) {
         mCi.supplyIccPukForApp(puk, newPin, mAid,
-                mHandler.obtainMessage(EVENT_PIN1_PUK1_DONE, onComplete));
+                mHandler.obtainMessage(/* MTK */ EVENT_PUK1_CHANGE_PIN1_DONE /* EVENT_PIN1_PUK1_DONE */, onComplete));
         }
     }
 
@@ -712,7 +784,7 @@ public class UiccCardApplication {
     public void supplyPuk2 (String puk2, String newPin2, Message onComplete) {
         synchronized (mLock) {
             mCi.supplyIccPuk2ForApp(puk2, newPin2, mAid,
-                    mHandler.obtainMessage(EVENT_PIN2_PUK2_DONE, onComplete));
+                    mHandler.obtainMessage(/* MTK */ EVENT_PUK2_CHANGE_PIN2_DONE /* EVENT_PIN2_PUK2_DONE */, onComplete));
         }
     }
 
@@ -761,6 +833,17 @@ public class UiccCardApplication {
      *         false if ICC fdn service not available
      */
     public boolean getIccFdnAvailable() {
+        // MTK TODO
+        /*
+        if (mIccRecords == null) {
+            if (DBG) log("isFdnExist mIccRecords == null");
+            return false;
+        }
+
+        Phone.IccServiceStatus iccSerStatus = mIccRecords.getSIMServiceStatus(Phone.IccService.FDN);
+        if (DBG) log("getIccFdnAvailable status: iccSerStatus");
+        return (iccSerStatus == Phone.IccServiceStatus.ACTIVATED);
+        */
         return mIccFdnAvailable;
     }
 
@@ -891,11 +974,11 @@ public class UiccCardApplication {
     }
 
     private void log(String msg) {
-        Rlog.d(LOG_TAG, msg);
+        Rlog.d(LOG_TAG, msg /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     private void loge(String msg) {
-        Rlog.e(LOG_TAG, msg);
+        Rlog.e(LOG_TAG, msg /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
@@ -934,4 +1017,131 @@ public class UiccCardApplication {
         }
         pw.flush();
     }
+
+    // MTK
+
+    private int mPhoneId;
+
+    private static final int EVENT_QUERY_NETWORK_LOCK_DONE = 101;
+    private static final int EVENT_CHANGE_NETWORK_LOCK_DONE = 102;
+    private static final int EVENT_RADIO_NOTAVAILABLE = 103;
+    // [ALPS01827777]--- START ---
+    private static final int EVENT_PUK1_CHANGE_PIN1_DONE = 104;
+    private static final int EVENT_PUK2_CHANGE_PIN2_DONE = 105;
+    // [ALPS01827777]--- END ---
+
+
+    // [02772] start
+    static final String[] UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+    protected String mIccType = null; /* Add for USIM detect */
+    // [02772] end
+
+    private static final String PROPERTY_PIN1_RETRY[] = {
+        "gsm.sim.retry.pin1",
+        "gsm.sim.retry.pin1.2",
+        "gsm.sim.retry.pin1.3",
+        "gsm.sim.retry.pin1.4",
+    };
+
+    private static final String PROPERTY_PIN2_RETRY[] = {
+        "gsm.sim.retry.pin2",
+        "gsm.sim.retry.pin2.2",
+        "gsm.sim.retry.pin2.3",
+        "gsm.sim.retry.pin2.4",
+    };
+
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
+    public void supplyNetworkDepersonalization (String pin, Message onComplete) {
+        synchronized (mLock) {
+            if (DBG) log("supplyNetworkDepersonalization");
+            mCi.supplyNetworkDepersonalization(pin, onComplete);
+        }
+    }
+
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mFdnChangedRegistrants.add(r);
+        }
+    }
+
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
+
+    public int getSlotId() {
+        return mPhoneId;
+    }
+
+    private void notifyFdnChangedRegistrants() {
+        if (mDestroyed) {
+            return;
+        }
+
+        mFdnChangedRegistrants.notifyRegistrants();
+    }
+
+    public String getIccCardType() {
+         if (mIccType == null || mIccType.equals("")) {
+            mIccType = SystemProperties.get(UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE[mPhoneId]);
+         }
+
+        log("getIccCardType(): mIccType = " + mIccType);
+        return mIccType;
+    }
+
+    //MTK-START [mtk80601][111215][ALPS00093395]
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  " + category);
+
+        switch(category) {
+            case CommandsInterface.CAT_NETWOEK:
+            case CommandsInterface.CAT_NETOWRK_SUBSET:
+            case CommandsInterface.CAT_CORPORATE:
+            case CommandsInterface.CAT_SERVICE_PROVIDER:
+            case CommandsInterface.CAT_SIM:
+                mCi.queryNetworkLock(category, mHandler.obtainMessage(EVENT_QUERY_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "queryIccNetworkLock unknown category = " + category);
+                break;
+        }
+   }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = " + category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+
+        switch(lockop) {
+            case CommandsInterface.OP_REMOVE:
+            case CommandsInterface.OP_ADD:
+            case CommandsInterface.OP_LOCK:
+            case CommandsInterface.OP_PERMANENT_UNLOCK:
+            case CommandsInterface.OP_UNLOCK:
+                mCi.setNetworkLock(category, lockop, password, data_imsi, gid1, gid2, mHandler.obtainMessage(EVENT_CHANGE_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "SetIccNetworkEnabled unknown operation" + lockop);
+                break;
+        }
+    }
+    // MTK-END
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 153a1b0..5dbbcd3 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -30,6 +30,8 @@ import android.text.format.Time;
 import android.telephony.ServiceState;
 
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
@@ -415,4 +417,160 @@ public class UiccController extends Handler {
             pw.println("  " + mCardLogs.get(i));
         }
     }
+
+    // MTK
+
+    protected static final int EVENT_RADIO_AVAILABLE = 100;
+    protected static final int EVENT_VIRTUAL_SIM_ON = 101;
+    protected static final int EVENT_VIRTUAL_SIM_OFF = 102;
+    protected static final int EVENT_SIM_MISSING = 103;
+    protected static final int EVENT_QUERY_SIM_MISSING_STATUS = 104;
+    protected static final int EVENT_SIM_RECOVERY = 105;
+    protected static final int EVENT_GET_ICC_STATUS_DONE_FOR_SIM_MISSING = 106;
+    protected static final int EVENT_GET_ICC_STATUS_DONE_FOR_SIM_RECOVERY = 107;
+    protected static final int EVENT_QUERY_ICCID_DONE_FOR_HOT_SWAP = 108;
+    protected static final int EVENT_SIM_PLUG_OUT = 109;
+    protected static final int EVENT_SIM_PLUG_IN = 110;
+    protected static final int EVENT_HOTSWAP_GET_ICC_STATUS_DONE = 111;
+    protected static final int EVENT_QUERY_SIM_STATUS_FOR_PLUG_IN = 112;
+    protected static final int EVENT_QUERY_SIM_MISSING = 113;
+    protected static final int EVENT_INVALID_SIM_DETECTED = 114;
+    protected static final int EVENT_REPOLL_SML_STATE = 115;
+    protected static final int EVENT_COMMON_SLOT_NO_CHANGED = 116;
+    protected static final int EVENT_CDMA_CARD_TYPE = 117;
+    protected static final int EVENT_EUSIM_READY = 118;
+
+    //Multi-application
+    // FIXME: Remove them when IccCardProxyEx is removed
+    protected static final int EVENT_TURN_ON_ISIM_APPLICATION_DONE = 200;
+    protected static final int EVENT_GET_ICC_APPLICATION_STATUS = 201;
+    protected static final int EVENT_APPLICATION_SESSION_CHANGED = 202;
+
+    private static final int SML_FEATURE_NO_NEED_BROADCAST_INTENT = 0;
+    private static final int SML_FEATURE_NEED_BROADCAST_INTENT = 1;
+
+    /* SIM inserted status constants */
+    private static final int STATUS_NO_SIM_INSERTED = 0x00;
+    private static final int STATUS_SIM1_INSERTED = 0x01;
+    private static final int STATUS_SIM2_INSERTED = 0x02;
+    private static final int STATUS_SIM3_INSERTED = 0x04;
+    private static final int STATUS_SIM4_INSERTED = 0x08;
+
+    private static final String ACTION_RESET_MODEM = "android.intent.action.sim.ACTION_RESET_MODEM";
+    private static final String PROPERTY_3G_SIM = "persist.radio.simswitch";
+
+    
+    public static final int CARD_TYPE_NONE = 0;
+    public static final int CARD_TYPE_SIM  = 1;
+    public static final int CARD_TYPE_USIM = 2;
+    public static final int CARD_TYPE_RUIM = 4;
+    public static final int CARD_TYPE_CSIM = 8;
+
+    private boolean mIsHotSwap = false;
+    private boolean mClearMsisdn = false;
+    private IccCardConstants.CardType mCdmaCardType = IccCardConstants.CardType.UNKNOW_CARD;
+
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    //Multi-application
+    private int[] mIsimSessionId = new int[TelephonyManager.getDefault().getPhoneCount()];
+    private RegistrantList mApplicationChangedRegistrants = new RegistrantList();
+
+    /*
+    private int[] UICCCONTROLLER_STRING_NOTIFICATION_SIM_MISSING = {
+        com.mediatek.internal.R.string.sim_missing_slot1,
+        com.mediatek.internal.R.string.sim_missing_slot2,
+        com.mediatek.internal.R.string.sim_missing_slot3,
+        com.mediatek.internal.R.string.sim_missing_slot4
+    };
+
+    private int[] UICCCONTROLLER_STRING_NOTIFICATION_VIRTUAL_SIM_ON = {
+        com.mediatek.internal.R.string.virtual_sim_on_slot1,
+        com.mediatek.internal.R.string.virtual_sim_on_slot2,
+        com.mediatek.internal.R.string.virtual_sim_on_slot3,
+        com.mediatek.internal.R.string.virtual_sim_on_slot4
+    };
+    */
+
+    private static final String COMMON_SLOT_PROPERTY = "ro.mtk_sim_hot_swap_common_slot";
+
+    private CommandsInterface mSvlteCi;
+    public static final int INDEX_SVLTE = 100;
+    private int mSvlteIndex = -1;
+    private int mNotifyIccCount = 0;
+    private static final String[]  PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+    private static final String  PROPERTY_CONFIG_EMDSTATUS_SEND = "ril.cdma.emdstatus.send";
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET = "gsm.ril.cardtypeset";
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET_2 = "gsm.ril.cardtypeset.2";
+    private static final String  PROPERTY_NET_CDMA_MDMSTAT = "net.cdma.mdmstat";
+    private static final String  PROPERTY_ICCID_C2K = "ril.iccid.sim1_c2k";
+    private static final int INITIAL_RETRY_INTERVAL_MSEC = 200;
+    private int mRetryCounter = 0;
+
+    private int[] mC2KWPCardtype = new int[TelephonyManager.getDefault().getPhoneCount()];
+
+    private RegistrantList mC2KWPCardTypeReadyRegistrants = new RegistrantList();
+    // int mOldSvlteSlotId = SvlteModeController.getActualSvlteModeSlotId();
+    boolean mSetRadioDone = false;
+    boolean mSetTrm = false;
+    boolean mRilInit = false;
+    boolean mSwitchCardtype = false;
+
+    private String mOperatorSpec;
+    private static final String OPERATOR_OM = "OM";
+    private static final String OPERATOR_OP09 = "OP09";
+    Phone[] sProxyPhones = null;
+
+    // MTK-START
+    public int getIccApplicationChannel(int slotId, int family) {
+        synchronized (mLock) {
+            int index = 0;
+            switch (family) {
+                case UiccController.APP_FAM_IMS:
+                    // FIXME: error handling for invaild slotId?
+                    index = mIsimSessionId[slotId];
+                    // Workaround: to avoid get sim status has open isim channel but java layer
+                    // haven't update channel id
+                    if (index == 0) {
+                        index = (getUiccCardApplication(slotId, family) != null) ? 1 : 0;
+                    }
+                    break;
+                default:
+                    if (DBG) log("unknown application");
+                    break;
+            }
+            return index;
+        }
+    }
+    // MTK-END
+
+    //Notifies when card status changes
+    public void registerForIccRecovery(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mRecoveryRegistrants.add(r);
+            //Notify registrant right after registering, so that it will get the latest ICC status,
+            //otherwise which may not happen until there is an actual change in ICC status.
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForIccRecovery(Handler h) {
+        synchronized (mLock) {
+            mRecoveryRegistrants.remove(h);
+        }
+    }
+
+    //Modem SML change feature.
+    public void repollIccStateForModemSmlChangeFeatrue(int slotId, boolean needIntent) {
+        if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
+        int arg1 = needIntent == true ? SML_FEATURE_NEED_BROADCAST_INTENT : SML_FEATURE_NO_NEED_BROADCAST_INTENT;
+        //Use arg1 to determine the intent is needed or not
+        //Use object to indicated slotId
+        mCis[slotId].getIccCardStatus(obtainMessage(EVENT_REPOLL_SML_STATE, arg1, 0, slotId));
+    }
 }
diff --git a/src/java/com/mediatek/internal/telephony/AirplaneRequestHandler.java b/src/java/com/mediatek/internal/telephony/AirplaneRequestHandler.java
new file mode 100644
index 0000000..88bcf7b
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/AirplaneRequestHandler.java
@@ -0,0 +1,311 @@
+package com.mediatek.internal.telephony;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.Message;
+import android.os.UserHandle;
+import android.telephony.Rlog;
+import android.net.ConnectivityManager;
+
+import com.android.internal.telephony.CommandsInterface.RadioState;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+/**
+ * This class fix the bug turn on/off flightmode frenquently.
+ */
+public class AirplaneRequestHandler extends Handler {
+    private static final String LOG_TAG = "AirplaneRequestHandler";
+    private Context mContext;
+    private Boolean mPendingAirplaneModeRequest;
+    private int mPhoneCount;
+    private boolean mNeedIgnoreMessageForChangeDone;
+    private boolean mForceSwitch;
+    private static final int EVENT_LTE_RADIO_CHANGE_FOR_OFF = 100;
+    private static final int EVENT_CDMA_RADIO_CHANGE_FOR_OFF = 101;
+    private static final int EVENT_GSM_RADIO_CHANGE_FOR_OFF = 102;
+    private static final int EVENT_LTE_RADIO_CHANGE_FOR_AVALIABLE = 103;
+    private static final int EVENT_CDMA_RADIO_CHANGE_FOR_AVALIABLE = 104;
+    private static final int EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE = 105;
+    private static final String INTENT_ACTION_AIRPLANE_CHANGE_DONE =
+            "com.mediatek.intent.action.AIRPLANE_CHANGE_DONE";
+    private static final String EXTRA_AIRPLANE_MODE = "airplaneMode";
+
+    private static AtomicBoolean sInSwitching = new AtomicBoolean(false);
+
+    protected boolean allowSwitching() {
+        if (sInSwitching.get()  && !mForceSwitch) {
+            return false;
+        }
+        return true;
+    }
+
+    protected void pendingAirplaneModeRequest(boolean enabled) {
+        mPendingAirplaneModeRequest = new Boolean(enabled);
+    }
+    /**
+     * The Airplane mode change request handler.
+     * @param context the context
+     */
+    public AirplaneRequestHandler(Context context) {
+        mContext = context;
+    }
+
+    protected void monitorAirplaneChangeDone(boolean power, int phoneCount) {
+        mNeedIgnoreMessageForChangeDone = false;
+        log("monitorAirplaneChangeDone, power = " + power
+            + " mNeedIgnoreMessageForChangeDone = " + mNeedIgnoreMessageForChangeDone);
+        sInSwitching.set(true);
+        mPhoneCount = phoneCount;
+        int phoneId = 0;
+        for (int i = 0; i < phoneCount; i++) {
+            phoneId = i;
+            if (power) {
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    if (phoneId == SvlteModeController.getActiveSvlteModeSlotId()) {
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_LTE_RADIO_CHANGE_FOR_AVALIABLE, null);
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getNLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_CDMA_RADIO_CHANGE_FOR_AVALIABLE, null);
+                    } else {
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE, null);
+                    }
+                } else */ {
+                    ((PhoneBase) (((PhoneProxy) (PhoneFactory.getPhone(phoneId))).getActivePhone())
+                            ).mCi.registerForRadioStateChanged(this,
+                            EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE , null);
+                }
+            } else {
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    if (phoneId == SvlteModeController.getActiveSvlteModeSlotId()) {
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_LTE_RADIO_CHANGE_FOR_OFF, null);
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getNLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_CDMA_RADIO_CHANGE_FOR_OFF, null);
+                    } else {
+                        ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.registerForRadioStateChanged(this,
+                                EVENT_GSM_RADIO_CHANGE_FOR_OFF, null);
+                    }
+                } else */ {
+                    ((PhoneBase) (((PhoneProxy) (PhoneFactory.getPhone(phoneId))).getActivePhone())
+                            ).mCi.registerForRadioStateChanged(this, EVENT_GSM_RADIO_CHANGE_FOR_OFF
+                            , null);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        ///M: Add for wifi only device. @{
+        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
+                Context.CONNECTIVITY_SERVICE);
+        boolean isWifiOnly = !cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
+        ///  @}
+        switch (msg.what) {
+        case EVENT_CDMA_RADIO_CHANGE_FOR_OFF:
+        case EVENT_LTE_RADIO_CHANGE_FOR_OFF:
+        case EVENT_GSM_RADIO_CHANGE_FOR_OFF:
+            if (!mNeedIgnoreMessageForChangeDone) {
+                if (msg.what == EVENT_CDMA_RADIO_CHANGE_FOR_OFF) {
+                    log("handle EVENT_CDMA_RADIO_CHANGE_FOR_OFF");
+                } else if (msg.what == EVENT_LTE_RADIO_CHANGE_FOR_OFF) {
+                    log("handle EVENT_LTE_RADIO_CHANGE_FOR_OFF");
+                } else if (msg.what == EVENT_GSM_RADIO_CHANGE_FOR_OFF) {
+                    log("handle EVENT_GSM_RADIO_CHANGE_FOR_OFF");
+                }
+                for (int i = 0; i < mPhoneCount; i++) {
+                    int phoneId = i;
+                    ///M: Add for wifi only device, don't judge radio off. @{
+                    if (isWifiOnly) {
+                        log("wifi-only, don't judge radio off");
+                        break;
+                    }
+                    ///  @}
+                    if (!isRadioOff(phoneId)) {
+                        log("radio state change, radio not off, phoneId = "
+                                + phoneId);
+                        return;
+                    }
+                }
+                log("All radio off");
+                sInSwitching.set(false);
+                unMonitorAirplaneChangeDone(true);
+                checkPendingRequest();
+            }
+            break;
+        case EVENT_LTE_RADIO_CHANGE_FOR_AVALIABLE:
+        case EVENT_CDMA_RADIO_CHANGE_FOR_AVALIABLE:
+        case EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE:
+            if (!mNeedIgnoreMessageForChangeDone) {
+                if (msg.what == EVENT_LTE_RADIO_CHANGE_FOR_AVALIABLE) {
+                    log("handle EVENT_LTE_RADIO_CHANGE_FOR_AVALIABLE");
+                } else if (msg.what == EVENT_CDMA_RADIO_CHANGE_FOR_AVALIABLE) {
+                    log("handle EVENT_CDMA_RADIO_CHANGE_FOR_AVALIABLE");
+                } else if (msg.what == EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE) {
+                    log("handle EVENT_GSM_RADIO_CHANGE_FOR_AVALIABLE");
+                }
+                for (int i = 0; i < mPhoneCount; i++) {
+                    int phoneId = i;
+                    ///M: Add for wifi only device, don't judge radio avaliable. @{
+                    if (isWifiOnly) {
+                        log("wifi-only, don't judge radio avaliable");
+                        break;
+                    }
+                    ///  @}
+                    if (!isRadioAvaliable(phoneId)) {
+                        log("radio state change, radio not avaliable, phoneId = "
+                                + phoneId);
+                        return;
+                    }
+                }
+                log("All radio avaliable");
+                sInSwitching.set(false);
+                unMonitorAirplaneChangeDone(false);
+                checkPendingRequest();
+            }
+            break;
+
+          default:
+            break;
+        }
+    }
+
+    private boolean isRadioAvaliable(int phoneId) {
+        // MTK TODO
+        /*
+        if (phoneId == SvlteModeController.getActiveSvlteModeSlotId()) {
+            log("phoneId = " + phoneId + " , in svlte mode "
+                    + " , lte radio state = "
+                    + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getLtePhone().mCi.getRadioState()
+                    + " , cdma radio state = "
+                    + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getNLtePhone().mCi.getRadioState());
+            return ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                    .getLtePhone().mCi.getRadioState() != RadioState.RADIO_UNAVAILABLE
+                    && ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getNLtePhone().mCi.getRadioState() != RadioState.RADIO_UNAVAILABLE;
+        } else */ {
+            // MTK TODO
+            /*
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                log("phoneId = " + phoneId + " , in csfb mode, lte radio state = "
+                        + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.getRadioState());
+                return ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                        .getLtePhone().mCi.getRadioState() != RadioState.RADIO_UNAVAILABLE;
+            } else */ {
+                log("phoneId = " + phoneId);
+                return ((PhoneBase) (((PhoneProxy) (PhoneFactory.getPhone(phoneId))).
+                            getActivePhone())).mCi.getRadioState() != RadioState.RADIO_UNAVAILABLE;
+            }
+        }
+    }
+
+    private boolean isRadioOff(int phoneId) {
+        // MTK TODO
+        /*
+        if (phoneId == SvlteModeController.getActiveSvlteModeSlotId()) {
+            log("phoneId = " + phoneId + " , in svlte mode "
+                    + " , lte radio state = "
+                    + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getLtePhone().mCi.getRadioState()
+                    + " , cdma radio state = "
+                    + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getNLtePhone().mCi.getRadioState());
+            return ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                    .getLtePhone().mCi.getRadioState() == RadioState.RADIO_OFF
+                    && ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getNLtePhone().mCi.getRadioState() == RadioState.RADIO_OFF;
+        } else */ {
+            // MTK TODO
+            /*
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                log("phoneId = " + phoneId + ", in csfb mode, lte radio state = "
+                        + ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                                .getLtePhone().mCi.getRadioState());
+                return ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                        .getLtePhone().mCi.getRadioState() == RadioState.RADIO_OFF;
+            } else */ {
+                log("phoneId = " + phoneId);
+                return ((PhoneBase) (((PhoneProxy) (PhoneFactory.getPhone(phoneId))).
+                            getActivePhone())).mCi.getRadioState() == RadioState.RADIO_OFF;
+            }
+        }
+    }
+
+    private void checkPendingRequest() {
+        log("checkPendingRequest, mPendingAirplaneModeRequest = " + mPendingAirplaneModeRequest);
+        if (mPendingAirplaneModeRequest != null) {
+            Boolean pendingAirplaneModeRequest = mPendingAirplaneModeRequest;
+            mPendingAirplaneModeRequest = null;
+            RadioManager.getInstance().notifyAirplaneModeChange(
+                    pendingAirplaneModeRequest.booleanValue());
+        }
+    }
+
+    protected void unMonitorAirplaneChangeDone(boolean airplaneMode) {
+        mNeedIgnoreMessageForChangeDone = true;
+        Intent intent = new Intent(INTENT_ACTION_AIRPLANE_CHANGE_DONE);
+        intent.putExtra(EXTRA_AIRPLANE_MODE, airplaneMode);
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+        int phoneId = 0;
+        for (int i = 0; i < mPhoneCount; i++) {
+            phoneId = i;
+            // MTK TODO
+            /*
+            if (phoneId == SvlteModeController.getActiveSvlteModeSlotId()) {
+                ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                        .getLtePhone().mCi.unregisterForRadioStateChanged(this);
+                ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                        .getNLtePhone().mCi
+                        .unregisterForRadioStateChanged(this);
+                log("unMonitorAirplaneChangeDone, for svlte phone,  phoneId = " + phoneId);
+            } else {
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    ((SvltePhoneProxy) PhoneFactory.getPhone(phoneId))
+                            .getLtePhone().mCi.unregisterForRadioStateChanged(this);
+                    log("unMonitorAirplaneChangeDone, for csfb phone,  phoneId = " + phoneId);
+                } else {
+                    ((PhoneBase) (((PhoneProxy) (PhoneFactory.getPhone(phoneId))).getActivePhone())
+                            ).mCi.unregisterForRadioStateChanged(this);
+                    log("unMonitorAirplaneChangeDone, for gsm phone,  phoneId = " + phoneId);
+                }
+            }
+            */
+
+        }
+    }
+
+    /**
+     * Set Whether force allow airplane mode change.
+     * @return true or false
+     */
+    public void setForceSwitch(boolean forceSwitch) {
+        mForceSwitch = forceSwitch;
+        log("setForceSwitch, forceSwitch =" + forceSwitch);
+    }
+
+    private static void log(String s) {
+        Rlog.d(LOG_TAG, "[RadioManager] " + s);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/ConferenceCallMessageHandler.java b/src/java/com/mediatek/internal/telephony/ConferenceCallMessageHandler.java
new file mode 100755
index 0000000..4ed6bb2
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ConferenceCallMessageHandler.java
@@ -0,0 +1,347 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.util.Log;
+
+import org.xml.sax.Attributes;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.DefaultHandler;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+* This class is used to parse IMS conference call user information.
+*/
+public class ConferenceCallMessageHandler extends DefaultHandler {
+    private static final String TAG = "ConferenceCallMessageHandler";
+    private List<User> mUsers;
+    private User mUser;
+    private int mMaxUserCount;
+    private String mPreTag;
+    private String mTempVal;
+    private int mCallId = -1;
+    private boolean mDuringEndPointTag = false;
+    private int mIndex = 0;
+
+    /*
+    * Define in RFC 4575
+    *
+    */
+    public static final String STATUS_PENDING = "pending";
+    public static final String STATUS_DIALING_OUT = "dialing-out";
+    public static final String STATUS_DIALING_IN = "dialing-in";
+    public static final String STATUS_ALERTING = "alerting";
+    public static final String STATUS_ON_HOLD = "on-hold";
+    public static final String STATUS_CONNECTED = "connected";
+    public static final String STATUS_DISCONNECTING = "disconnecting";
+    public static final String STATUS_DISCONNECTED = "disconnected";
+    public static final String STATUS_MUTED_VIA_FOCUS = "muted-via-focus";
+    public static final String STATUS_CONNECT_FAIL = "connect-fail";
+
+    /**
+    * This class is used to store IMS conference call user information.
+    *
+    */
+    public class User {
+        private String mEndPoint;
+        private String mEntity;
+        private String mDisplayText;
+        private String mStatus = STATUS_DISCONNECTED;     //Default is "disconnected"
+        private String mSipTelUri;
+        private int    mIndex;
+        private int    mConnectionIndex = -1;
+
+        /**
+        * To set endpoint entity value, it is usually phone number in tel uri or sip uri format.
+        *
+        * @param entity entity value
+        */
+        void setEndPoint(String endPoint) {
+            mEndPoint = endPoint;
+        }
+
+        /**
+        * To set user entity value, it is usually phone number in tel uri or sip uri format.
+        *
+        * @param entity entity value
+        */
+        void setEntity(String entity) {
+            mEntity = entity;
+        }
+
+        /**
+        * To set sip uri and/or tel uri value.
+        *
+        * @param uri sip uri and/or tel uri value
+        */
+        void setSipTelUri(String uri) {
+            mSipTelUri = uri;
+        }
+
+        /**
+        * To set the display text value.
+        *
+        * @param displayText displayText value
+        */
+        void setDisplayText(String displayText) {
+            mDisplayText = displayText;
+        }
+
+        /**
+        * To set status of conf. call participant
+        * Refer to {@link #STATUS_CONNECTED}, {@link #STATUS_DISCONNECTED} or
+        * {@link #STATUS_ON_HOLD}.
+        *
+        * @param displayText displayText value
+        */
+        void setStatus(String status) {
+            mStatus = status;
+        }
+
+        /**
+        * To set sequential index for each conf. call participant.
+        * It will be used during SRVCC for call id reassignment.
+        *
+        * @param index index value
+        */
+        void setIndex(int index) {
+            mIndex = index;
+        }
+
+        /**
+        * To set connection index.
+        *
+        * @param index connection index value
+        */
+        public void setConnectionIndex(int index) {
+            mConnectionIndex = index;
+        }
+
+        /**
+        * To retrieve endpoint entity value, it is usually phone number
+        * in tel uri or sip uri format.
+        *
+        * @return entity value
+        */
+        public String getEndPoint() {
+            return mEndPoint;
+        }
+
+        /**
+        * To retrieve user entity value, it is usually phone number in tel uri or
+        * sip uri format.
+        *
+        * @return entity value
+        */
+        public String getEntity() {
+            return mEntity;
+        }
+
+        /**
+        * To retrieve sip uri and/or tel uri value.
+        *
+        * @return sip uri and/or tel uri value
+        */
+        public String getSipTelUri() {
+            return mSipTelUri;
+        }
+
+        /**
+        * To retrieve display text.
+        *
+        * @return display text value
+        */
+        public String getDisplayText() {
+            return mDisplayText;
+        }
+
+        /**
+        * To retrieve status of conf. call participant
+        * Refer to {@link #STATUS_CONNECTED}, {@link #STATUS_DISCONNECTED} or
+        * {@link #STATUS_ON_HOLD}
+        *
+        * @return participant status
+        */
+        public String getStatus() {
+            return mStatus;
+        }
+
+        /**
+        * To retrieve sequential index.
+        *
+        * @return sequential index
+        */
+        public int getIndex() {
+            return mIndex;
+        }
+
+        /**
+        * To retrieve connection index.
+        *
+        * @return connection index
+        */
+        public int getConnectionIndex() {
+            return mConnectionIndex;
+        }
+    } /* End of User class */
+
+    /**
+    * To retrieve all conf. call participants.
+    *
+    * @return all conf. call participants
+    */
+    public List<User> getUsers() {
+        return mUsers;
+    }
+
+    /**
+    * To set the maximum count of participants.
+    *
+    * @param maxUserCount the maximum count of participants
+    */
+    private void setMaxUserCount(String maxUserCount) {
+        mMaxUserCount = Integer.parseInt(maxUserCount);
+    }
+
+    /**
+    * To retrive the maximum count of participants.
+    *
+    * @return the maximum count of participants
+    */
+    public int getMaxUserCount() {
+        return mMaxUserCount;
+    }
+
+    /**
+    * To set call id.
+    *
+    * @param callId The call id
+    */
+    public void setCallId(int callId) {
+        mCallId = callId;
+    }
+
+    /**
+    * To retrieve call id.
+    *
+    * @return call id
+    */
+    public int getCallId() {
+        return mCallId;
+    }
+
+    /**
+    * To start parse xml document.
+    * @throws SAXException if something wrong
+    */
+    @Override
+    public void startDocument() throws SAXException {
+        mUsers = new ArrayList<User>();
+    }
+
+    /**
+    * Notification for receiving character.
+    *
+    * @param ch character array
+    * @param start the start index
+    * @param length the length of character
+    * @throws SAXException if something wrong
+    */
+    @Override
+    public void characters(char[] ch, int start, int length) throws SAXException {
+        mTempVal = new String(ch, start, length);
+    }
+
+    /**
+    * Notification for start element.
+    *
+    * @param uri URI value
+    * @param localName local name
+    * @param qName tag name
+    * @param attributes attribute values
+    * @throws SAXException if something wrong
+    */
+    @Override
+    public void startElement(String uri, String localName, String qName,
+            Attributes attributes) throws SAXException {
+        if (qName.equalsIgnoreCase("user")) {
+            mIndex++;
+            mUser = new User();
+            mUser.setIndex(mIndex);
+            mUser.setEntity(attributes.getValue("", "entity"));
+            Log.d(TAG, "user - entity: " + mUser.getEntity());
+        } else if (qName.equalsIgnoreCase("endpoint")) {
+            mUser.setEndPoint(attributes.getValue("", "entity"));
+            mDuringEndPointTag = true;
+            Log.d(TAG, "endpoint - entity: " + mUser.getEndPoint());
+        }
+        mPreTag = localName;
+    }
+
+    /**
+    * Notification for end element.
+    *
+    * @param uri URI value
+    * @param localName local name
+    * @param qName tag name
+    * @throws SAXException if something wrong
+    */
+    @Override
+    public void endElement(String uri, String localName, String qName)
+            throws SAXException {
+        if (qName.equalsIgnoreCase("user") && mUsers != null) {
+            mUsers.add(mUser);
+            mUser = null;
+        } else if (qName.equalsIgnoreCase("endpoint") && mUser != null) {
+            mDuringEndPointTag = false;
+        } else if (qName.equalsIgnoreCase("display-text") && (mUser != null) &&
+                   !mDuringEndPointTag) {
+            mUser.setDisplayText(mTempVal);
+            Log.d(TAG, "user - DisplayText: " + mUser.getDisplayText());
+        } else if (qName.equalsIgnoreCase("maximum-user-count")) {
+            setMaxUserCount(mTempVal);
+            Log.d(TAG, "MaxUserCount: " + getMaxUserCount());
+        } else if (qName.equalsIgnoreCase("status") && (mUser != null)) {
+            mUser.setStatus(mTempVal);
+            Log.d(TAG, "Status: " + mUser.getStatus());
+        }
+        mPreTag = null;
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
new file mode 100755
index 0000000..2ee8f03
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
@@ -0,0 +1,19 @@
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable FemtoCellInfo;
diff --git a/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
new file mode 100755
index 0000000..173f1f2
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * {@hide}
+ */
+public class FemtoCellInfo implements Parcelable {
+    /* This CSG is Not in EFACSGL nor in EFOCSGL */
+    public static final int CSG_ICON_TYPE_NOT_ALLOWED = 0;
+
+    /* This CSG is in Allowed CSG List (EFACSGL) */
+    public static final int CSG_ICON_TYPE_ALLOWED = 1;
+
+    /* This CSG is in Operator CSG List (EFOCSGL) */
+    public static final int CSG_ICON_TYPE_OPERATOR = 2;
+
+    /* This CSG is in Operator CSGs. However, it is unauthorized, meaning that UE's registration has been rejected by cause #25.*/
+    public static final int CSG_ICON_TYPE_OPERATOR_UNAUTHORIZED = 3;
+
+    private int csgId;
+    private int csgIconType; /* FemtoCellInfo.CSG_ICON_TYPE_xxx */
+    private String homeNodeBName;
+    private String operatorNumeric; /* ex: "46000" */
+    private String operatorAlphaLong; /* ex: "China Mobile" */
+    private int rat = 0; /* ServiceState.RIL_RADIO_TECHNOLOGY_xxx */
+
+/**
+ * Get registered CSG Id
+ * @internal
+ */
+    public int getCsgId() {
+        return csgId;
+    }
+
+/**
+ * Get registered CSG Icon Type
+ * @internal
+ */
+    public int getCsgIconType() {
+        return csgIconType;
+    }
+
+/**
+ * Get Home NodeB Name(if exist)
+ * @internal
+ */
+    public String getHomeNodeBName() {
+        return homeNodeBName;
+    }
+
+/**
+ * Get registered CSG Rat information
+ */
+    public int getCsgRat() {
+        return rat;
+    }
+
+/**
+ * Get registered operator numeric code
+ */
+    public String getOperatorNumeric() {
+        return operatorNumeric;
+    }
+
+/**
+ * Get registered operator alphanumeric long name
+ * @internal
+ */
+    public String getOperatorAlphaLong() {
+        return operatorAlphaLong;
+    }
+
+    public FemtoCellInfo(int csgId, int csgIconType, String homeNodeBName, String operatorNumeric, String operatorAlphaLong, int rat) {
+        this.csgId = csgId;
+        this.csgIconType = csgIconType;
+        this.homeNodeBName = homeNodeBName;
+        this.operatorNumeric = operatorNumeric;
+        this.operatorAlphaLong = operatorAlphaLong;
+        this.rat = rat;
+    }
+
+    public String toString() {
+        return "FemtoCellInfo " + csgId
+                + "/" + csgIconType
+                + "/" + homeNodeBName
+                + "/" + operatorNumeric
+                + "/" + operatorAlphaLong
+                + "/" + rat;
+    }
+
+    /**
+     * Parcelable interface implemented below.
+     * This is a simple effort to make FemtoCellInfo parcelable rather than
+     * trying to make the conventional containing object (AsyncResult),
+     * implement parcelable.
+     */
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * Method to serialize a FemtoCellInfo object.
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(csgId);
+        dest.writeInt(csgIconType);
+        dest.writeString(homeNodeBName);
+        dest.writeString(operatorNumeric);
+        dest.writeString(operatorAlphaLong);
+        dest.writeInt(rat);
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * Method to deserialize a FemtoCellInfo object, or an array thereof.
+     */
+    public static final Creator<FemtoCellInfo> CREATOR =
+        new Creator<FemtoCellInfo>() {
+            public FemtoCellInfo createFromParcel(Parcel in) {
+                FemtoCellInfo femtoCellInfo = new FemtoCellInfo(
+                        in.readInt(), /*csgId*/
+                        in.readInt(), /*csgIconType*/
+                        in.readString(), /*homeNodeBName*/
+                        in.readString(), /*operatorNumeric*/
+                        in.readString(), /*operatorAlphaLong*/
+                        in.readInt()); /*rat*/
+                return femtoCellInfo;
+            }
+
+            public FemtoCellInfo[] newArray(int size) {
+                return new FemtoCellInfo[size];
+            }
+        };
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/IRadioPower.java b/src/java/com/mediatek/internal/telephony/IRadioPower.java
new file mode 100644
index 0000000..7d6e2ac
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/IRadioPower.java
@@ -0,0 +1,42 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+public interface IRadioPower {
+    public void notifyRadioPowerChange(boolean power, int phoneId);
+}
\ No newline at end of file
diff --git a/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
new file mode 100755
index 0000000..c5ceca5
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
@@ -0,0 +1,311 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+
+
+public class ModemSwitchHandler {
+    private static final String LOG_TAG = "PHONE";
+
+    /** @internal */
+    public static final int MD_TYPE_UNKNOWN = 0;
+    /** @internal */
+    public static final int MD_TYPE_WG      = 3;
+    /** @internal */
+    public static final int MD_TYPE_TG      = 4;
+    /** @internal */
+    public static final int MD_TYPE_LWG     = 5;
+    /** @internal */
+    public static final int MD_TYPE_LTG     = 6;
+    /** @internal */
+    public static final int MD_TYPE_FDD     = 100;
+    /** @internal */
+    public static final int MD_TYPE_TDD     = 101;
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+
+    private static int sCurrentModemType = getActiveModemType();
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static Context sContext = null;
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    //C2K world phone
+    private static Phone[] sSvlteLtePhone = new Phone[PROJECT_SIM_NUM];
+    private static CommandsInterface[] sSvlteLteCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    public ModemSwitchHandler() {
+        logd("Constructor invoked");
+        logd("Init modem type: " + sCurrentModemType);
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            //C2K world phone - start
+            sSvlteLtePhone[i] = null;
+            sSvlteLteCi[i] = null;
+            /*
+            if (WorldPhoneUtil.isCdmaLteDcSupport() &&
+                    sProxyPhones[i] instanceof SvltePhoneProxy) {
+                logd("Phone " + i + " is SVLTE case so get lte phone directly");
+                sSvlteLtePhone[i] = ((SvltePhoneProxy) sProxyPhones[i]).getLtePhone();
+                sSvlteLteCi[i] = ((PhoneBase) sSvlteLtePhone[i]).mCi;
+            }
+            */
+            //C2K world phone - end
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+        }
+        if (PhoneFactory.getDefaultPhone() != null) {
+            sContext = PhoneFactory.getDefaultPhone().getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(int modemType) {
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        CommandsInterface ci = null;
+        logd("protocolSim: " + protocolSim);
+        if (protocolSim >= PhoneConstants.SIM_ID_1 && protocolSim <= PhoneConstants.SIM_ID_4) {
+            //C2K world phone - start
+            ci = getActiveCi(protocolSim);
+            if (ci != null) {
+                switchModem(ci, modemType);
+                //switchModem(sCi[protocolSim], modemType);
+            }
+            //C2K world phone - end
+        } else {
+            //C2K world phone - start
+            ci = getActiveCi(PhoneConstants.SIM_ID_1);
+            if (ci != null) {
+                switchModem(ci, modemType);
+                //switchModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+            }
+            //C2K world phone - end
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type with desinated RIL instance
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(CommandsInterface ci, int modemType) {
+        logd("[switchModem]");
+        if (modemType == sCurrentModemType) {
+            if (modemType == MD_TYPE_WG) {
+                logd("Already in WG modem");
+            } else if (modemType == MD_TYPE_TG) {
+                logd("Already in TG modem");
+            } else if (modemType == MD_TYPE_LWG) {
+                logd("Already in FDD CSFB modem");
+            } else if (modemType == MD_TYPE_LTG) {
+                logd("Already in TDD CSFB modem");
+            }
+            return;
+        }
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not switch modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(9, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(10, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(11, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(12, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+            return;
+        }
+        // Update sCurrentModemType variable & set ril.active.md system property
+        setActiveModemType(modemType);
+
+        // Broadcast modem switch notification
+        logd("Broadcast intent ACTION_MD_TYPE_CHANGE");
+        Intent intent = new Intent(TelephonyIntents.ACTION_MD_TYPE_CHANGE);
+        intent.putExtra(TelephonyIntents.EXTRA_MD_TYPE, modemType);
+        sContext.sendBroadcast(intent);
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(int modemType) {
+        int majorSim = WorldPhoneUtil.getMajorSim();
+        CommandsInterface ci = null;
+        if (majorSim >= PhoneConstants.SIM_ID_1 && majorSim <= PhoneConstants.SIM_ID_4) {
+            //C2K world phone - start
+            ci = getActiveCi(majorSim);
+            if (ci != null) {
+                reloadModem(ci, modemType);
+                //reloadModem(sCi[majorSim], modemType);
+            }
+            //C2K world phone - end
+        } else {
+            //C2K world phone - start
+            ci = getActiveCi(PhoneConstants.SIM_ID_1);
+            if (ci != null) {
+                reloadModem(ci, modemType);
+                //reloadModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+            }
+            //C2K world phone - end
+        }
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin with desinated RIL instance
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(CommandsInterface ci, int modemType) {
+        logd("[reloadModem]");
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not reload modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(14, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(15, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(16, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(17, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+        }
+    }
+
+    /**
+     * Returns current modem type
+     * @internal
+     * @return 0 : modem type is unknown
+     *         3 : switch to WG(MD_TYPE_WG)
+     *         4 : switch to TG(MD_TYPE_TG)
+     *         5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *         6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static int getActiveModemType() {
+        sCurrentModemType = Integer.valueOf(
+                SystemProperties.get(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(MD_TYPE_UNKNOWN)));
+
+        return sCurrentModemType;
+    }
+
+    public static void setActiveModemType(int modemType) {
+        SystemProperties.set(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(modemType));
+        sCurrentModemType = modemType;
+        logd("[setActiveModemType] " + modemToString(sCurrentModemType));
+    }
+
+    public static String modemToString(int modemType) {
+        String modemString;
+        if (modemType == MD_TYPE_WG) {
+            modemString = "WG";
+        } else if (modemType == MD_TYPE_TG) {
+            modemString = "TG";
+        } else if (modemType == MD_TYPE_LWG) {
+            modemString = "FDD CSFB";
+        } else if (modemType == MD_TYPE_LTG) {
+            modemString = "TDD CSFB";
+        } else if (modemType == MD_TYPE_UNKNOWN) {
+            modemString = "UNKNOWN";
+        } else {
+            modemString = "Invalid modem type";
+        }
+
+        return modemString;
+    }
+
+    private static CommandsInterface getActiveCi(int slotId) {
+        int radioTechModeForWp = WorldPhoneUtil.getRadioTechModeForWp();
+        logd("[getActiveCi]: slotId" + slotId +
+                " radioTechModeForWp=" + radioTechModeForWp);
+
+        if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+            // MTK TODO
+            /*
+            if (sProxyPhones[slotId] instanceof SvltePhoneProxy) {
+                logd("[getActiveCi]: return sSvlteLteCi");
+                return sSvlteLteCi[slotId];
+            } else {
+                logd("[getActiveCi]: return sCi");
+                return sCi[slotId];
+            }
+            */
+            logd("[getActiveCi]: xen0n: CDMA support TODO!");
+            return sCi[slotId];
+        } else {
+            logd("[getActiveCi]: return sCi");
+            return sCi[slotId];
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[MSH]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
new file mode 100755
index 0000000..b604df8
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
@@ -0,0 +1,57 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+/**
+ * Used to indicate that the NetworkInfo object is parcelable to aidl.
+ * This is a simple effort to make NetworkInfo parcelable rather than
+ * trying to make the conventional containing object (AsyncResult),
+ * implement parcelable.  This functionality is needed for the
+ * NetworkQueryService to fix 1128695
+ */
+parcelable NetworkInfoWithAcT;
diff --git a/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
new file mode 100755
index 0000000..12d848e
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
@@ -0,0 +1,201 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Entry of preferred network list in UICC card. ex: EF_PLMNSEL
+ * {@hide}
+ * @internal
+ */
+public class NetworkInfoWithAcT implements Parcelable {
+
+    String operatorAlphaName;
+    String operatorNumeric;
+
+    int nAct;
+    int nPriority; // priority is the index of the plmn in the list.
+
+
+/**
+ * Get Operator alpha name ex: Vodafone
+ * @internal
+ */
+    public String
+    getOperatorAlphaName() {
+        return operatorAlphaName;
+    }
+
+/**
+ * Get member Operator PLMN ID ex: 53001
+ * @internal
+ */
+    public String
+    getOperatorNumeric() {
+        return operatorNumeric;
+    }
+
+/**
+ * Get access techonolgy of the PLMN. It's a bitmap value.  <bit3, bit2,bit1,bit0>  =>  < E-UTRAN_Act ,UTRAN_Act,GSM_Compact_Act ,Gsm_Act >
+ * @internal
+ */
+    public int
+    getAccessTechnology() {
+        return nAct;
+    }
+
+/**
+ * Get priority, index of the PLMN in the list
+ * @internal
+ */
+    public int
+    getPriority() {
+        return nPriority;
+    }
+
+/**
+ * Set Operator alpha name ex: Vodafone
+ *
+ * @internal
+ */
+    public void
+    setOperatorAlphaName(String operatorAlphaName) {
+        this.operatorAlphaName = operatorAlphaName;
+    }
+
+/**
+ * Set member Operator PLMN ID ex: 53001
+ * @internal
+ */
+    public void
+    setOperatorNumeric(String operatorNumeric) {
+        this.operatorNumeric = operatorNumeric;
+    }
+
+/**
+ * Set access techonolgy of the PLMN. It's a bitmap value.  <bit3, bit2,bit1,bit0>  =>  < E-UTRAN_Act ,UTRAN_Act,GSM_Compact_Act ,Gsm_Act >
+ *
+ * @internal
+ */
+    public void
+    setAccessTechnology(int nAct) {
+        this.nAct = nAct;
+    }
+
+/**
+ * Set priority, index of the PLMN in the list
+ * @internal
+ */
+    public void
+    setPriority(int nIndex) {
+        this.nPriority = nIndex;
+    }
+
+    public NetworkInfoWithAcT(String operatorAlphaLong,
+                String operatorNumeric,
+                int nAct,
+                int nPriority) {
+
+        this.operatorAlphaName = operatorAlphaLong;
+        this.operatorNumeric = operatorNumeric;
+        this.nAct = nAct;
+        this.nPriority = nPriority;
+    }
+
+    public String toString() {
+        return "NetworkInfoWithAcT " + operatorAlphaName
+                + "/" + operatorNumeric
+                + "/" + nAct
+                + "/" + nPriority;
+    }
+
+    /**
+     * Parcelable interface implemented below.
+     * This is a simple effort to make NetworkInfo parcelable rather than
+     * trying to make the conventional containing object (AsyncResult),
+     * implement parcelable.  This functionality is needed for the
+     * NetworkQueryService to fix 1128695.
+     */
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * Method to serialize a NetworkInfo object.
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(operatorAlphaName);
+        dest.writeString(operatorNumeric);
+        dest.writeInt(nAct);
+        dest.writeInt(nPriority);
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * Method to deserialize a NetworkInfo object, or an array thereof.
+     */
+    public static final Creator<NetworkInfoWithAcT> CREATOR =
+        new Creator<NetworkInfoWithAcT>() {
+            public NetworkInfoWithAcT createFromParcel(Parcel in) {
+                NetworkInfoWithAcT netInfoWithAct = new NetworkInfoWithAcT(
+                        in.readString(), /*operatorAlphaLong*/
+                        in.readString(), /*operatorNumeric*/
+                        in.readInt(), /*operatorNumeric*/
+                        in.readInt()); /*state*/
+                return netInfoWithAct;
+            }
+
+            public NetworkInfoWithAcT[] newArray(int size) {
+                return new NetworkInfoWithAcT[size];
+            }
+        };
+}
diff --git a/src/java/com/mediatek/internal/telephony/NetworkManager.java b/src/java/com/mediatek/internal/telephony/NetworkManager.java
new file mode 100755
index 0000000..8609f55
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkManager.java
@@ -0,0 +1,101 @@
+
+package com.mediatek.internal.telephony;
+
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+import android.content.Context;
+
+import com.android.internal.telephony.CommandsInterface;
+
+public class NetworkManager extends Handler  {
+    static final String LOG_TAG = "GSM";
+    private static NetworkManager sNetworkManager;
+    private Context mContext;
+    private CommandsInterface[] mCi;
+    private int mPhoneCount;
+
+    protected static final int EVENT_GET_AVAILABLE_NW = 1;
+
+    public static NetworkManager init(Context context, int phoneCount, CommandsInterface[] ci) {
+        synchronized (NetworkManager.class) {
+            if (sNetworkManager == null) {
+                sNetworkManager = new NetworkManager(context, phoneCount, ci);
+            }
+            return sNetworkManager;
+        }
+    }
+
+    public static NetworkManager getInstance() {
+        return sNetworkManager;
+    }
+
+    private NetworkManager(Context context , int phoneCount, CommandsInterface[] ci) {
+
+        log("Initialize NetworkManager under airplane mode phoneCount= " + phoneCount);
+
+        mContext = context;
+        mCi = ci;
+        mPhoneCount = phoneCount;
+    }
+
+    /**
+       * To scan all available networks. i.e. PLMN list
+       * @param Message for on complete
+       * @param simId Indicate which sim(slot) to query
+       * @internal
+       */
+    public void getAvailableNetworks(long subId, Message response) {
+    /*
+        int activeSim = -1;
+        for (int i=0; i<PhoneConstants.GEMINI_SIM_NUM;++i) {
+            if (!mGeminiDataMgr.isGprsDetached(i)) {
+                activeSim = i;
+                break;
+            }
+        }
+
+        Rlog.d(LOG_TAG, "getAvailableNetworksGemini activeSIM="+activeSim);
+
+        if (activeSim == -1 || activeSim == simId ||
+                PhoneFactory.isDualTalkMode()) {
+            getPhonebyId(simId).getAvailableNetworks(response);
+        } else {
+            PhoneBase phoneBase = getPhoneBase(activeSim);
+            if (phoneBase instanceof GSMPhone) {
+                Rlog.d(LOG_TAG, "activeSim: "  + activeSim + ", simId: " + simId);
+                mActiveApnTypes = getActiveApnTypesGemini(activeSim);
+                mGeminiDataMgr.cleanupAllConnection(activeSim);
+            }
+            mGettingAvailableNetwork = true;
+            Message msg = obtainMessage(EVENT_GET_AVAILABLE_NW);
+            msg.arg1 = activeSim;
+            msg.arg2 = simId;
+            msg.obj = response;
+            mGeminiDataMgr.registerForDetached(activeSim, this, EVENT_GPRS_DETACHED, msg);
+        }
+        */
+        return;
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        switch (msg.what) {
+            case EVENT_GET_AVAILABLE_NW:
+                synchronized (this) {
+
+                }
+                break;
+
+            default:
+                log("Unhandled message with number: " + msg.what);
+                break;
+        }
+    }
+
+    private static void log(String s) {
+        Log.d(LOG_TAG, "[NetworkManager] " + s);
+    }
+}
+
+
diff --git a/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java b/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
new file mode 100644
index 0000000..93098a8
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
@@ -0,0 +1,619 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.SystemProperties;
+
+import android.telephony.RadioAccessFamily;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.uicc.UiccController;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
+/**
+ * Utility for capability switch.
+ *
+ */
+public class RadioCapabilitySwitchUtil {
+    private static final String LOG_TAG = "GSM";
+
+    public static final int SIM_OP_INFO_UNKNOWN = 0;
+    public static final int SIM_OP_INFO_OVERSEA = 1;
+    public static final int SIM_OP_INFO_OP01 = 2;
+    public static final int SIM_OP_INFO_OP02 = 3;
+
+    public static final int SIM_TYPE_SIM = 0;
+    public static final int SIM_TYPE_USIM = 1;
+    public static final int SIM_TYPE_OTHER = 2;
+
+    // sync to ril_oem.h for dsda
+    public static final int SIM_SWITCH_MODE_SINGLE_TALK_MDSYS       = 1;
+    public static final int SIM_SWITCH_MODE_SINGLE_TALK_MDSYS_LITE  = 2;
+    public static final int SIM_SWITCH_MODE_DUAL_TALK               = 3;
+    public static final int SIM_SWITCH_MODE_DUAL_TALK_SWAP          = 4;
+
+    public static final String MAIN_SIM_PROP = "persist.radio.simswitch.iccid";
+    private static final String PROPERTY_ICCID = "ril.iccid.sim";
+    // OP01 SIMs
+    private static final String[] PLMN_TABLE_TYPE1 = {
+        "46000", "46002", "46007", "46008", "45412", "45413",
+        // Lab test IMSI
+        "00101", "00211", "00321", "00431", "00541", "00651",
+        "00761", "00871", "00902", "01012", "01122", "01232",
+        "46004", "46602", "50270", "46003", "46011"
+    };
+
+    // non-OP01 SIMs
+    private static final String[] PLMN_TABLE_TYPE3 = {
+        "46001", "46006", "46009", "45407",
+        "46005", "45502"
+    };
+
+    // OP02 case
+    private static final String NO_SIM_VALUE = "N/A";
+    public static final String CN_MCC = "460";
+    private static final String[] PROPERTY_SIM_ICCID = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4"
+    };
+    public static final int SHOW_DIALOG = 0;
+    public static final int NOT_SHOW_DIALOG = 1;
+    public static final int IMSI_NOT_READY_OR_SIM_LOCKED = 2;
+    public static final int ICCID_ERROR = 3;
+
+
+    /** sim switch decision based on sim info/status**/
+    public static final int DO_SWITCH = 0;
+    public static final int NOT_SWITCH = 1;
+    public static final int NOT_SWITCH_SIM_INFO_NOT_READY = 2;
+    /**
+     * Update current main protocol ICCID.
+     *
+     * @param mProxyPhones Phone array for all phones
+     */
+    public static void updateIccid(Phone[] mProxyPhones) {
+        boolean bIsMajorPhone = false;
+        for (int i = 0; i < mProxyPhones.length; i++) {
+            bIsMajorPhone = false;
+            if (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1) {
+                if ((mProxyPhones[i].getRadioAccessFamily() & RadioAccessFamily.RAF_LTE)
+                        == RadioAccessFamily.RAF_LTE) {
+                    bIsMajorPhone = true;
+                }
+            } else {
+                if ((mProxyPhones[i].getRadioAccessFamily() & RadioAccessFamily.RAF_UMTS)
+                        == RadioAccessFamily.RAF_UMTS) {
+                    bIsMajorPhone = true;
+                }
+            }
+            if (bIsMajorPhone) {
+                String currIccId = SystemProperties.get(PROPERTY_ICCID + (i + 1));
+                SystemProperties.set(MAIN_SIM_PROP, currIccId);
+                logd("updateIccid " + currIccId);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Get all SIMs operator and type.
+     *
+     * @param simOpInfo SIM operator info
+     * @param simType SIM type
+     */
+    public static boolean getSimInfo(int[] simOpInfo, int[] simType, int insertedStatus) {
+        String[] strMnc = new String[simOpInfo.length];
+        String[] strSimType = new String[simOpInfo.length];
+        String propStr;
+
+        for (int i = 0; i < simOpInfo.length; i++) {
+            if (i == 0) {
+                propStr = "gsm.ril.uicctype";
+            } else {
+                propStr = "gsm.ril.uicctype." + (i + 1);
+            }
+            strSimType[i] = SystemProperties.get(propStr, "");
+            if (strSimType[i].equals("SIM")) {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_SIM;
+            } else if (strSimType[i].equals("USIM")) {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_USIM;
+            } else {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_OTHER;
+            }
+            logd("SimType[" + i + "]= " + strSimType[i] + ", simType[" + i + "]=" + simType[i]);
+            strMnc[i] = TelephonyManager.getTelephonyProperty(i, "gsm.sim.operator.imsi", "");
+            if (strMnc[i].length() >= 5) {
+                strMnc[i] = strMnc[i].substring(0, 5);
+            }
+            logd("strMnc[" + i + "] from gsm.sim.operator.imsi:" + strMnc[i]);
+            if (strMnc[i].equals("")) {
+                if (i == 0) {
+                    propStr = "gsm.sim.ril.mcc.mnc";
+                } else {
+                    propStr = "gsm.sim.ril.mcc.mnc." + (i + 1);
+                }
+                strMnc[i] = SystemProperties.get(propStr, "");
+                logd("strMnc[" + i + "] from ril.mcc.mnc:" + strMnc[i]);
+            }
+            logd("insertedStatus:" + insertedStatus);
+            if ((insertedStatus >= 0) && (((1 << i) & insertedStatus) > 0)) {
+                if (strMnc[i].equals("")) {
+                    logd("SIM is inserted but no imsi");
+                    return false;
+                }
+                if (strMnc[i].equals("sim_lock")) {
+                    logd("SIM is lock, wait pin unlock");
+                    return false;
+                }
+            }
+            for (String mccmnc : PLMN_TABLE_TYPE1) {
+                if (strMnc[i].equals(mccmnc)) {
+                    simOpInfo[i] = SIM_OP_INFO_OP01;
+                    break;
+                }
+            }
+            if (simOpInfo[i] == SIM_OP_INFO_UNKNOWN) {
+                for (String mccmnc : PLMN_TABLE_TYPE3) {
+                    if (strMnc[i].equals(mccmnc)) {
+                        simOpInfo[i] = SIM_OP_INFO_OP02;
+                        break;
+                    }
+                }
+            }
+            if (simOpInfo[i] == SIM_OP_INFO_UNKNOWN) {
+                if (!strMnc[i].equals("")) {
+                    simOpInfo[i] = SIM_OP_INFO_OVERSEA;
+                }
+            }
+            logd("strMnc[" + i + "]= " + strMnc[i] + ", simOpInfo[" + i + "]=" + simOpInfo[i]);
+        }
+        logd("getSimInfo(simOpInfo): " + Arrays.toString(simOpInfo));
+        logd("getSimInfo(simType): " + Arrays.toString(simType));
+        return true;
+    }
+
+    /**
+     * Check if need to switch capability.
+     *
+     * @param mProxyPhones Phone array for all phones
+     * @param rats new capability for phones
+     * @return DO_SWITCH : keep do setCapability
+     * @       NOT_SWITCH : don't switch and stay current capability setting
+     * @       NOT_SWITCH_SIM_INFO_NOT_READY : don't swith due to sim status/info is not ready (no imsi or sim is locked)
+     */
+    public static int isNeedSwitchInOpPackage(Phone[] mProxyPhones, RadioAccessFamily[] rats) {
+        String operatorSpec = SystemProperties.get("ro.operator.optr", "");
+        int[] simOpInfo = new int[mProxyPhones.length];
+        int[] simType = new int[mProxyPhones.length];
+
+        int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+        int insertedSimCount = 0;
+        int insertedStatus = 0;
+        String[] currIccId = new String[phoneCount];
+
+        logd("Operator Spec:" + operatorSpec);
+        if (SystemProperties.getBoolean("ro.mtk_disable_cap_switch", false) == true) {
+            logd("mtk_disable_cap_switch is true");
+            return NOT_SWITCH;
+        } else if (operatorSpec.equals("OP01")) {
+            // handle later
+        } else {
+            // OM package, default enable
+            return DO_SWITCH;
+        }
+
+        /** Goal: get insertedStatus for getSimInfo();**/
+        for (int i = 0; i < phoneCount ; i++) {
+            currIccId[i] = SystemProperties.get(PROPERTY_SIM_ICCID[i]);
+            if (currIccId[i] == null || "".equals(currIccId[i])) {
+                logd("error: iccid not found, not switch, return NOT_SWITCH_SIM_INFO_NOT_READY");
+                return NOT_SWITCH_SIM_INFO_NOT_READY;
+            }
+            if (!NO_SIM_VALUE.equals(currIccId[i])) {
+                ++insertedSimCount;
+                insertedStatus = insertedStatus | (1 << i);
+            }
+        }
+        if ((false == getSimInfo(simOpInfo, simType, insertedStatus)) &&
+                (insertedSimCount != 1)) {
+            return NOT_SWITCH_SIM_INFO_NOT_READY;
+        }
+
+        // find target phone ID
+        int targetPhoneId;
+        for (targetPhoneId = 0; targetPhoneId < rats.length; targetPhoneId++) {
+            if (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1) {
+                if ((rats[targetPhoneId].getRadioAccessFamily() & RadioAccessFamily.RAF_LTE)
+                        == RadioAccessFamily.RAF_LTE) {
+                    break;
+                }
+            } else {
+                if ((rats[targetPhoneId].getRadioAccessFamily() & RadioAccessFamily.RAF_UMTS)
+                        == RadioAccessFamily.RAF_UMTS) {
+                    break;
+                }
+            }
+        }
+        if (operatorSpec.equals("OP01")) {
+            return checkOp01(targetPhoneId, simOpInfo, simType) ? DO_SWITCH : NOT_SWITCH;
+        } else {
+            return DO_SWITCH;
+        }
+    }
+
+    /**
+     * Check if any higher priority SIM exists.
+     *
+     * @param curId current phone ID uses main capability
+     * @param op01Usim array to indicate if op01 USIM
+     * @param op01Sim array to indicate if op01 SIM
+     * @param overseaUsim array to indicate if oversea USIM
+     * @param overseaSim array to indicate if oversea SIM
+     * @return higher priority SIM ID
+     */
+    public static int getHigherPrioritySimForOp01(int curId, boolean[] op01Usim, boolean[] op01Sim
+            , boolean[] overseaUsim, boolean[] overseaSim) {
+        int targetSim = -1;
+        int phoneNum = op01Usim.length;
+
+        if (op01Usim[curId] == true) {
+            return curId;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (op01Usim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || op01Sim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (op01Sim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || overseaUsim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (overseaUsim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || overseaSim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (overseaSim[i] == true) {
+                targetSim = i;
+            }
+        }
+        return targetSim;
+    }
+
+    private static boolean checkOp01(int targetPhoneId, int[] simOpInfo, int[] simType) {
+        int curPhoneId = Integer.valueOf(
+                SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1")) - 1;
+
+        logd("checkOp01 : curPhoneId: " + curPhoneId);
+        if (simOpInfo[targetPhoneId] == SIM_OP_INFO_OP01) {
+            if (simType[targetPhoneId] == SIM_TYPE_SIM) {
+                if ((simOpInfo[curPhoneId] == SIM_OP_INFO_OP01)
+                    && simType[curPhoneId] != SIM_TYPE_SIM) {
+                    logd("checkOp01 : case 1,2; stay in current phone");
+                    return false;
+                } else {
+                    // case 3: op01-SIM + op01-SIM
+                    // case 4: op01-SIM + others
+                    logd("checkOp01 : case 3,4");
+                    return true;
+                }
+            } else { // USIM, ISIM...
+                // case 1: op01-USIM + op01-USIM
+                // case 2: op01-USIM + others
+                logd("checkOp01 : case 1,2");
+                return true;
+            }
+        } else if (simOpInfo[targetPhoneId] == SIM_OP_INFO_OVERSEA) {
+            if (simOpInfo[curPhoneId] == SIM_OP_INFO_OP01) {
+                logd("checkOp01 : case 1,2,3,4; stay in current phone");
+                return false;
+            } else if (simType[targetPhoneId] == SIM_TYPE_SIM) {
+                if ((simOpInfo[curPhoneId] == SIM_OP_INFO_OVERSEA)
+                    && simType[curPhoneId] != SIM_TYPE_SIM) {
+                    logd("checkOp01 : case 5,6; stay in current phone");
+                    return false;
+                } else {
+                    // case 7: non-China SIM + non-China SIM
+                    // case 8: non-China SIM + others
+                    logd("checkOp01 : case 7,8");
+                    return true;
+                }
+            } else { // USIM, ISIM...
+                // case 5: non-China USIM + non-China USIM
+                // case 6: non-China USIM + others
+                logd("checkOp01 : case 5,6");
+                return true;
+            }
+        } else {
+            if (simOpInfo[targetPhoneId] == SIM_OP_INFO_UNKNOWN) {
+                logd("checkOp01 : case 10, target IMSI not ready");
+                int insertedStatus = 0;
+                int phoneNum = simOpInfo.length;
+                String[] currIccId = new String[phoneNum];
+                for (int i = 0; i < phoneNum; i++) {
+                    currIccId[i] = SystemProperties.get(PROPERTY_ICCID + (i + 1));
+                    if (!NO_SIM_VALUE.equals(currIccId[i])) {
+                        insertedStatus = insertedStatus | (1 << i);
+                    }
+                }
+                if (insertedStatus <= 2) {
+                    logd("checkOp01 : case 10, single SIM case, switch!");
+                    return true;
+                }
+            }
+            if (SystemProperties.get("ro.mtk_world_phone_policy").equals("1")) {
+                if ((simOpInfo[curPhoneId] != SIM_OP_INFO_OP01) &&
+                        (simOpInfo[curPhoneId] != SIM_OP_INFO_OVERSEA)) {
+                    logd("checkOp01 : case 11, op01-B, switch it!");
+                    return true;
+                }
+            }
+            // case 9: non-op01 USIM/SIM + non-op01 USIM/SIM
+            logd("checkOp01 : case 9");
+            return false;
+        }
+    }
+
+    /**
+     * Get main capability phone ID.
+     *
+     * @return Phone ID with main capability
+     */
+    public static int getMainCapabilityPhoneId() {
+        int phoneId = 0;
+        if (SystemProperties.getBoolean("ro.mtk_dt_support", false) == true) {
+            int swapMode = SystemProperties.getInt("persist.ril.simswitch.swapmode", 3);
+            if (swapMode == SIM_SWITCH_MODE_DUAL_TALK) {
+                phoneId = 0;
+            } else if (swapMode == SIM_SWITCH_MODE_DUAL_TALK_SWAP) {
+                phoneId = 1;
+            }
+        } else {
+            phoneId = SystemProperties.getInt(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, 1) - 1;
+        }
+        // MTK TODO
+        /*
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            if (phoneId == PhoneConstants.SIM_ID_1) {
+                if (SvlteUtils.getSvltePhoneProxy(phoneId).getActivePhone().
+                    getPhoneName()== "CDMA") {
+                    // for svlte project, we need re-mapping slot 0 to DC phone
+                    phoneId = SubscriptionManager.LTE_DC_PHONE_ID_1;
+                }
+            }
+            if (phoneId == PhoneConstants.SIM_ID_2) {
+                if (SvlteUtils.getSvltePhoneProxy(phoneId).getActivePhone().
+                    getPhoneName()== "CDMA") {
+                    // for svlte project, we need re-mapping slot 1 to DC phone
+                    phoneId = SubscriptionManager.LTE_DC_PHONE_ID_2;
+                }
+            }
+        }
+        */
+        Log.d(LOG_TAG, "[RadioCapSwitchUtil] getMainCapabilityPhoneId " + phoneId);
+        return phoneId;
+    }
+
+    private static void logd(String s) {
+        Log.d(LOG_TAG, "[RadioCapSwitchUtil] " + s);
+    }
+
+    public static boolean isSimContainsCdmaApp(int simId) {
+        // MTK TODO
+        /*
+        int[] cardType = new int[TelephonyManager.getDefault().getPhoneCount()];
+        cardType = UiccController.getInstance().getC2KWPCardType();
+        Log.d(LOG_TAG, "[RadioCapSwitchUtil][getCardType]: SIM" + simId + " type: " + cardType[simId]);
+        if ((cardType[simId] & UiccController.CARD_TYPE_RUIM) > 0
+                || (cardType[simId] & UiccController.CARD_TYPE_CSIM) > 0) {
+            return true;
+        }
+        */
+        return false;
+    }
+
+    /**
+     * Check SIM type and operator type to decide displaying dialog or not.
+     *
+     * @return SHOW_DIALOG: show dialog
+     *             NOT_SHOW_DIALOG: don't show dialog
+     *             IMSI_NOT_READY_OR_SIM_LOCKED: IMSI not ready or sim locked. Wait
+     *             ACTION_SIM_STATE_CHANGED to check isNeedShowSimDialog() again
+     *             ICCID_ERROR: read ICCID error. Wait ACTION_SIM_STATE_CHANGED
+     *              to check isNeedShowSimDialog() again
+     */
+    public static int isNeedShowSimDialog() {
+        if (SystemProperties.getBoolean("ro.mtk_disable_cap_switch", false) == true) {
+            logd("mtk_disable_cap_switch is true");
+            return SHOW_DIALOG;
+        }
+
+        logd("isNeedShowSimDialog start");
+        int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+        int[] simOpInfo = new int[phoneCount];
+        int[] simType = new int[phoneCount];
+        String[] currIccId = new String[phoneCount];
+        int insertedSimCount = 0;
+        int insertedStatus = 0;
+        int op02CardCount = 0;
+        ArrayList<Integer> usimIndexList = new ArrayList<Integer>();
+        ArrayList<Integer> simIndexList = new ArrayList<Integer>();
+        ArrayList<Integer> op02IndexList = new ArrayList<Integer>();
+        ArrayList<Integer> otherIndexList = new ArrayList<Integer>();
+
+        for (int i = 0; i < phoneCount; i++) {
+            currIccId[i] = SystemProperties.get(PROPERTY_SIM_ICCID[i]);
+            logd("currIccid[" + i + "] : " + currIccId[i]);
+            if (currIccId[i] == null || "".equals(currIccId[i])) {
+                Log.e(LOG_TAG, "iccid not found, wait for next sim state change");
+                return ICCID_ERROR;
+            }
+            if (!NO_SIM_VALUE.equals(currIccId[i])) {
+                insertedSimCount++;
+                insertedStatus = insertedStatus | (1 << i);
+            }
+        }
+
+        if (insertedSimCount < 2) {
+            logd("isNeedShowSimDialog: insert sim count < 2, do not show dialog");
+            return NOT_SHOW_DIALOG;
+        }
+
+        if (getSimInfo(simOpInfo, simType, insertedStatus) == false) {
+            Log.e(LOG_TAG, "Can't get SIM information");
+            return IMSI_NOT_READY_OR_SIM_LOCKED;
+        }
+        for (int i = 0; i < phoneCount; i++) {
+            // check SIM type
+            if (SIM_TYPE_USIM == simType[i]) {
+                usimIndexList.add(i);
+            } else if (SIM_TYPE_SIM == simType[i]) {
+                simIndexList.add(i);
+            }
+
+            // check SIM operator
+            if (SIM_OP_INFO_OP02 == simOpInfo[i]) {
+                op02IndexList.add(i);
+            } else {
+                otherIndexList.add(i);
+            }
+        }
+        logd("usimIndexList size = " + usimIndexList.size());
+        logd("op02IndexList size = " + op02IndexList.size());
+
+        if (usimIndexList.size() >= 2) {
+            // check OP02USIM count
+            for (int i = 0; i < usimIndexList.size(); i++) {
+                if (op02IndexList.contains(usimIndexList.get(i))) {
+                    op02CardCount++;
+                }
+            }
+
+            if (op02CardCount == 1) {
+                logd("One OP02Usim inserted, not show dialog");
+                return NOT_SHOW_DIALOG;
+            }
+        } else if (usimIndexList.size() == 1) {
+            logd("One Usim inserted, not show dialog");
+            return NOT_SHOW_DIALOG;
+        } else {
+            // usimIndexList.size() = 0 (all SIM cards)
+            // check OP02SIM count
+            for (int i = 0; i < simIndexList.size(); i++) {
+                if (op02IndexList.contains(simIndexList.get(i))) {
+                    op02CardCount++;
+                }
+            }
+
+            if (op02CardCount == 1) {
+                logd("One non-OP02 Usim inserted, not show dialog");
+                return NOT_SHOW_DIALOG;
+            }
+        }
+        logd("Show dialog");
+        return SHOW_DIALOG;
+    }
+
+    public static boolean isAnySimLocked(int phoneNum) {
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+           logd("isAnySimLocked always returns false in C2K");
+           return false;
+        }
+
+        // iccid property is not equal to N/A and imsi property is empty => sim locked
+        String[] mnc = new String[phoneNum];
+        String[] iccid = new String[phoneNum];
+        String propStr;
+        for (int i=0; i<phoneNum; i++) {
+            iccid[i] = SystemProperties.get(PROPERTY_SIM_ICCID[i]);
+            // only get mcc,mnc when SIM inserted
+            if (!iccid[i].equals(NO_SIM_VALUE)) {
+                mnc[i] = TelephonyManager.getTelephonyProperty(i, "gsm.sim.operator.imsi", "");
+                if (mnc[i].length() >= 5) {
+                    mnc[i] = mnc[i].substring(0, 5);
+                }
+                if (mnc[i].equals("")) {
+                    if (i == 0) {
+                        propStr = "gsm.sim.ril.mcc.mnc";
+                    } else {
+                        propStr = "gsm.sim.ril.mcc.mnc." + (i + 1);
+                    }
+                    mnc[i] = SystemProperties.get(propStr, "");
+                    logd("mnc[" + i + "] from ril.mcc.mnc:" + mnc[i]);
+                }
+            }
+            logd("i = " + i + " from gsm.sim.operator.imsi:" + mnc[i] + " ,iccid = " + iccid[i]);
+            if (!iccid[i].equals(NO_SIM_VALUE) && (mnc[i].equals("") ||
+                    mnc[i].equals("sim_lock"))) {
+                return true;
+            } else {
+                // SIM does not locked
+                logd("clear mcc.mnc:" + i);
+                if (i == 0) {
+                    propStr = "gsm.sim.ril.mcc.mnc";
+                } else {
+                    propStr = "gsm.sim.ril.mcc.mnc." + (i + 1);
+                }
+                SystemProperties.set(propStr, "");
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/RadioManager.java b/src/java/com/mediatek/internal/telephony/RadioManager.java
new file mode 100644
index 0000000..11d59b4
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/RadioManager.java
@@ -0,0 +1,1195 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.Handler;
+import android.os.Message;
+import android.os.AsyncResult;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.BroadcastReceiver;
+import android.content.SharedPreferences;
+import android.content.Context;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.telephony.Rlog;
+import android.net.ConnectivityManager;
+
+import com.android.ims.ImsManager;
+import com.android.ims.ImsConfig;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.uicc.UiccController;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.Map.Entry;
+
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteRatController;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccUtils;
+import com.mediatek.internal.telephony.IRadioPower;
+
+public class RadioManager extends Handler  {
+
+    static final String LOG_TAG = "RadioManager";
+    private static final String PREF_CATEGORY_RADIO_STATUS = "RADIO_STATUS";
+    private static RadioManager sRadioManager;
+
+    protected static final int MODE_PHONE1_ONLY = 1;
+    private static final int MODE_PHONE2_ONLY = 2;
+    private static final int MODE_PHONE3_ONLY = 4;
+    private static final int MODE_PHONE4_ONLY = 8;
+
+    protected static final int INVALID_PHONE_ID = -1;
+
+    private static final int SIM_NOT_INITIALIZED = -1;
+    protected static final int NO_SIM_INSERTED = 0;
+    protected static final int SIM_INSERTED = 1;
+
+    private static final boolean ICC_READ_NOT_READY = false;
+    private static final boolean ICC_READ_READY = true;
+
+    protected static final int INITIAL_RETRY_INTERVAL_MSEC = 200;
+
+    protected static final boolean RADIO_POWER_OFF = false;
+    protected static final boolean RADIO_POWER_ON = true;
+
+    protected static final boolean MODEM_POWER_OFF = false;
+    protected static final boolean MODEM_POWER_ON = true;
+
+    protected static final boolean AIRPLANE_MODE_OFF = false;
+    protected static final boolean AIRPLANE_MODE_ON = true;
+    protected boolean mAirplaneMode = AIRPLANE_MODE_OFF;
+
+    private static final boolean WIFI_ONLY_MODE_OFF = false;
+    private static final boolean WIFI_ONLY_MODE_ON = true;
+    private boolean mWifiOnlyMode = WIFI_ONLY_MODE_OFF;
+    private static final String ACTION_WIFI_ONLY_MODE_CHANGED =
+        "android.intent.action.ACTION_WIFI_ONLY_MODE";
+
+    protected static final String STRING_NO_SIM_INSERTED = "N/A";
+
+    protected static final String PROPERTY_SILENT_REBOOT_MD1 = "gsm.ril.eboot";
+    protected static final String PROPERTY_SILENT_REBOOT_MD2 = "gsm.ril.eboot.2";
+
+    private static final String IS_NOT_SILENT_REBOOT = "0";
+    protected static final String IS_SILENT_REBOOT = "1";
+    private static final String REGISTRANTS_WITH_NO_NAME = "NO_NAME";
+
+    public static final String ACTION_FORCE_SET_RADIO_POWER =
+        "com.mediatek.internal.telephony.RadioManager.intent.action.FORCE_SET_RADIO_POWER";
+
+    protected int[] mSimInsertedStatus;
+    private Context mContext;
+    private int[] mInitializeWaitCounter;
+    private CommandsInterface[] mCi;
+    protected static SharedPreferences sIccidPreference;
+    protected int mPhoneCount;
+    protected int mBitmapForPhoneCount;
+    //For checking if ECC call is on-going to bypass turning off radio
+    protected boolean mIsEccCall;
+    private int mSimModeSetting;
+
+    // Record ipo shutdown request for those phone which in radio not available state,
+    // should send ipo shutdown request again when radio state is available
+    private boolean bIsQueueIpoShutdown;
+
+    // Is in IPO shutdown, needs to block all radio power on request
+    // ex. ECC do not recognize IPO shutdown, so it will force set radio power on after its timeout
+    // in this scenario, modem will power-on wrongly: airplane on -> ecc call -> ipo shutdown
+    // -> ecc trigger airplane off -> ecc timeout -> force set radio power on
+    private boolean bIsInIpoShutdown;
+
+    // MTK TODO
+    // private ImsSwitchController mImsSwitchController = null;
+
+    static protected ConcurrentHashMap<IRadioPower, String> mNotifyRadioPowerChange
+            = new ConcurrentHashMap<IRadioPower, String>();
+
+    protected static String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    protected static String[] PROPERTY_RADIO_OFF = {
+        "ril.ipo.radiooff",
+        "ril.ipo.radiooff.2",
+    };
+
+    /** events id definition */
+    private static final int EVENT_RADIO_AVAILABLE = 1;
+    private static final int EVENT_VIRTUAL_SIM_ON = 2;
+
+    public static RadioManager init(Context context, int phoneCount, CommandsInterface[] ci) {
+        synchronized (RadioManager.class) {
+            if (sRadioManager == null) {
+                //For SVLTE/SRLTE Radio/Modem power control, 2015/06/29
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    sRadioManager =  new SvlteRadioManager(context, phoneCount, ci);
+                } else {
+                */
+                    sRadioManager =  new RadioManager(context, phoneCount, ci);
+                // }
+            }
+            return sRadioManager;
+        }
+    }
+
+    ///M: [SVLTE] Add for the airplane mode frequently switch issue.@{
+    private AirplaneRequestHandler mAirplaneRequestHandler;
+    /// @}
+    /**
+     * @internal
+     */
+    public static RadioManager getInstance() {
+        synchronized (RadioManager.class) {
+            return sRadioManager;
+        }
+    }
+
+    protected RadioManager(Context context , int phoneCount, CommandsInterface[] ci) {
+
+        int airplaneMode = Settings.Global.getInt(context.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 0);
+        int wifionlyMode = ImsManager.getWfcMode(context);
+
+        log("Initialize RadioManager under airplane mode:" + airplaneMode +
+            " wifi only mode:" + wifionlyMode);
+
+        mSimInsertedStatus = new int[phoneCount];
+        for (int i = 0; i < phoneCount; i++) {
+            mSimInsertedStatus[i] = SIM_NOT_INITIALIZED;
+        }
+        mInitializeWaitCounter = new int[phoneCount];
+        for (int i = 0; i < phoneCount; i++) {
+            mInitializeWaitCounter[i] = 0;
+        }
+
+        mContext = context;
+        mAirplaneMode = ((airplaneMode == 0) ? AIRPLANE_MODE_OFF : AIRPLANE_MODE_ON);
+
+        mWifiOnlyMode = (ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY == wifionlyMode);
+
+        mCi = ci;
+        mPhoneCount = phoneCount;
+        mBitmapForPhoneCount = convertPhoneCountIntoBitmap(phoneCount);
+        sIccidPreference = mContext.getSharedPreferences(PREF_CATEGORY_RADIO_STATUS, 0);
+        // MTK TODO
+        // mSimModeSetting = Settings.System.getInt(context.getContentResolver(),
+        //                       Settings.System.MSIM_MODE_SETTING, mBitmapForPhoneCount);
+        mSimModeSetting = mBitmapForPhoneCount;
+        // MTK TODO
+        // mImsSwitchController = new ImsSwitchController(mContext, mPhoneCount, mCi);
+
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            log("Not BSP Package, register intent!!!");
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+            filter.addAction(ACTION_FORCE_SET_RADIO_POWER);
+            filter.addAction(ACTION_WIFI_ONLY_MODE_CHANGED);
+            mContext.registerReceiver(mIntentReceiver, filter);
+
+            // For virtual SIM
+            for (int i = 0; i < phoneCount; i++) {
+                Integer index = new Integer(i);
+                mCi[i].registerForVirtualSimOn(this, EVENT_VIRTUAL_SIM_ON, index);
+                mCi[i].registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
+            }
+
+        }
+        ///M: [SVLTE]Add for the airplane mode frequently switch issue.@{
+        mAirplaneRequestHandler = new AirplaneRequestHandler(mContext);
+        ///@}
+    }
+
+    private int convertPhoneCountIntoBitmap(int phoneCount) {
+        int ret = 0;
+        for (int i = 0; i < phoneCount; i++) {
+            ret += MODE_PHONE1_ONLY << i;
+        }
+        log("Convert phoneCount " + phoneCount + " into bitmap " + ret);
+        return ret;
+    }
+
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+
+           log("BroadcastReceiver: " + intent.getAction());
+
+            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                onReceiveSimStateChangedIntent(intent);
+            } else if (intent.getAction().equals(ACTION_FORCE_SET_RADIO_POWER)) {
+                onReceiveForceSetRadioPowerIntent(intent);
+            } else if (intent.getAction().equals(ACTION_WIFI_ONLY_MODE_CHANGED)) {
+                onReceiveWifiOnlyModeStateChangedIntent(intent);
+            }
+        }
+    };
+
+    protected void onReceiveSimStateChangedIntent(Intent intent) {
+        String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+
+        // TODO: phone_key now is equals to slot_key, change in the future
+        int phoneId = intent.getIntExtra(PhoneConstants.PHONE_KEY, INVALID_PHONE_ID);
+
+        if (!isValidPhoneId(phoneId)) {
+            log("INTENT:Invalid phone id:" + phoneId + ", do nothing!");
+            return;
+        }
+
+        log("INTENT:SIM_STATE_CHANGED: " + intent.getAction() + ", sim status: " + simStatus + ", phoneId: " + phoneId);
+
+        boolean desiredRadioPower = RADIO_POWER_ON;
+
+        if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(simStatus)
+            || IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(simStatus)
+            || IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(simStatus)) {
+            mSimInsertedStatus[phoneId] = SIM_INSERTED;
+            log("Phone[" + phoneId + "]: " + simStatusToString(SIM_INSERTED));
+
+            // if we receive ready, but can't get iccid, we do nothing
+            String iccid = readIccIdUsingPhoneId(phoneId);
+            if (STRING_NO_SIM_INSERTED.equals(iccid)) {
+                log("Phone " + phoneId + ":SIM ready but ICCID not ready, do nothing");
+                return;
+            }
+
+            desiredRadioPower = RADIO_POWER_ON;
+            if (mAirplaneMode == AIRPLANE_MODE_OFF) {
+                log("Set Radio Power due to SIM_STATE_CHANGED, power: " + desiredRadioPower + ", phoneId: " + phoneId);
+                setRadioPower(desiredRadioPower, phoneId);
+            }
+        }
+
+        else if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)) {
+            mSimInsertedStatus[phoneId] = NO_SIM_INSERTED;
+            log("Phone[" + phoneId + "]: " + simStatusToString(NO_SIM_INSERTED));
+            desiredRadioPower = RADIO_POWER_OFF;
+            if (mAirplaneMode == AIRPLANE_MODE_OFF) {
+                log("Set Radio Power due to SIM_STATE_CHANGED, power: " + desiredRadioPower + ", phoneId: " + phoneId);
+                setRadioPower(desiredRadioPower, phoneId);
+            }
+        }
+    }
+
+   /**
+     * enter or leave wifi only mode
+     *
+     */
+    public void onReceiveWifiOnlyModeStateChangedIntent(Intent intent) {
+
+        boolean enabled = intent.getBooleanExtra("state", false);
+        log("mReceiver: ACTION_WIFI_ONLY_MODE_CHANGED, enabled = " + enabled);
+
+        // we expect wifi only mode is on-> off or off->on
+        if (enabled == mWifiOnlyMode) {
+            log("enabled = " + enabled + ", mWifiOnlyMode = "+ mWifiOnlyMode +
+                "is not expected (the same)");
+            return;
+        }
+
+        mWifiOnlyMode = enabled;
+        if (mAirplaneMode == AIRPLANE_MODE_OFF) {
+            boolean radioPower = enabled ? RADIO_POWER_OFF : RADIO_POWER_ON;
+            for (int i = 0; i < mPhoneCount; i++) {
+                setRadioPower(radioPower, i);
+            }
+        }
+    }
+
+    private void onReceiveForceSetRadioPowerIntent(Intent intent) {
+        int phoneId = 0;
+        int mode = -1;  // MTK TODO: intent.getIntExtra(Intent.EXTRA_MSIM_MODE, -1);
+        log("force set radio power, mode: " + mode);
+        if (mode == -1) {
+            log("Invalid mode, MSIM_MODE intent has no extra value");
+            return;
+        }
+        for (phoneId = 0; phoneId < mPhoneCount; phoneId++) {
+            boolean singlePhonePower =
+                ((mode & (MODE_PHONE1_ONLY << phoneId)) == 0) ? RADIO_POWER_OFF : RADIO_POWER_ON;
+            if (RADIO_POWER_ON == singlePhonePower) {
+                forceSetRadioPower(true, phoneId);
+            }
+        }
+    }
+
+    protected boolean isValidPhoneId(int phoneId) {
+        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    protected String simStatusToString(int simStatus) {
+        String result = null;
+        switch(simStatus) {
+            case SIM_NOT_INITIALIZED:
+                result = "SIM HAVE NOT INITIALIZED";
+                break;
+            case SIM_INSERTED:
+                result = "SIM DETECTED";
+                break;
+            case NO_SIM_INSERTED:
+                result = "NO SIM DETECTED";
+                break;
+            }
+        return result;
+    }
+
+    /**
+     * Modify mAirplaneMode and set modem power
+     * @param enabled 0: normal mode
+     *                1: airplane mode
+     * @internal
+     */
+    public void notifyAirplaneModeChange(boolean enabled) {
+        ///M: Add for the airplane mode frequently switch issue.@{
+        if (!mAirplaneRequestHandler.allowSwitching()) {
+            log("airplane mode switching, not allow switch now ");
+            mAirplaneRequestHandler.pendingAirplaneModeRequest(enabled);
+            return;
+        }
+        /// @}
+
+        // we expect airplane mode is on-> off or off->on
+        if (enabled == mAirplaneMode) {
+            log("enabled = " + enabled + ", mAirplaneMode = " + mAirplaneMode + "is not expected (the same)");
+            return;
+        }
+
+        mAirplaneMode = enabled;
+        log("Airplane mode changed:" + enabled);
+        SystemProperties.set("persist.radio.airplane.mode.on", enabled ? "true" : "false");
+
+        if (isFlightModePowerOffModemEnabled() && !isUnderCryptKeeper()) {
+            log("Airplane mode changed: turn on/off all modem");
+            boolean modemPower = enabled ? MODEM_POWER_OFF : MODEM_POWER_ON;
+            setSilentRebootPropertyForAllModem(IS_SILENT_REBOOT);
+            setModemPower(modemPower, mBitmapForPhoneCount);
+            ///M: Add for the airplane mode frequently switch issue.@{
+            mAirplaneRequestHandler.monitorAirplaneChangeDone(modemPower,
+                    mPhoneCount);
+            /// @}
+        } else if (isMSimModeSupport()) {
+            log("Airplane mode changed: turn on/off all radio");
+            boolean radioPower = enabled ? RADIO_POWER_OFF : RADIO_POWER_ON;
+            for (int i = 0; i < mPhoneCount; i++) {
+                setRadioPower(radioPower, i);
+            }
+            ///M: Add for the airplane mode frequently switch issue.@{
+            mAirplaneRequestHandler.monitorAirplaneChangeDone(radioPower,
+                    mPhoneCount);
+            /// @}
+        }
+    }
+
+    /*
+     *A special paragraph, not to trun off modem power under cryptkeeper
+     */
+    protected boolean isUnderCryptKeeper() {
+        if (SystemProperties.get("ro.crypto.state").equals("encrypted")
+            && SystemProperties.get("vold.decrypt").equals("trigger_restart_min_framework")) {
+            log("[Special Case] Under CryptKeeper, Not to turn on/off modem");
+            return true;
+        }
+        log("[Special Case] Not Under CryptKeeper");
+        return false;
+    }
+
+    public void setSilentRebootPropertyForAllModem(String isSilentReboot) {
+        TelephonyManager.MultiSimVariants config = TelephonyManager.getDefault().getMultiSimConfiguration();
+        switch(config) {
+            case DSDS:
+                log("set eboot under DSDS");
+                SystemProperties.set(PROPERTY_SILENT_REBOOT_MD1, isSilentReboot);
+                break;
+            case DSDA:
+                log("set eboot under DSDA");
+                SystemProperties.set(PROPERTY_SILENT_REBOOT_MD1, isSilentReboot);
+                SystemProperties.set(PROPERTY_SILENT_REBOOT_MD2, isSilentReboot);
+                break;
+            case TSTS:
+                log("set eboot under TSTS");
+                SystemProperties.set(PROPERTY_SILENT_REBOOT_MD1, isSilentReboot);
+                break;
+            default:
+                log("set eboot under SS");
+                SystemProperties.set(PROPERTY_SILENT_REBOOT_MD1, isSilentReboot);
+                break;
+        }
+    }
+
+    /*
+     * Called From GSMSST, if boot up under airplane mode, power-off modem
+     */
+    public void notifyRadioAvailable(int phoneId) {
+        log("Phone " + phoneId + " notifies radio available");
+        if (mAirplaneMode == AIRPLANE_MODE_ON && isFlightModePowerOffModemEnabled() && !isUnderCryptKeeper()) {
+            log("Power off modem because boot up under airplane mode");
+            setModemPower(MODEM_POWER_OFF, MODE_PHONE1_ONLY << phoneId);
+        }
+    }
+
+    public void notifyIpoShutDown() {
+        log("notify IPO shutdown!");
+        bIsInIpoShutdown = true;
+
+        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
+            // record IpoShutdown if there is any phone of radio state is not avaible,
+            // then do ipo shutdown after radio available
+            log("mCi[" + i + "].getRadioState().isAvailable(): " +
+                mCi[i].getRadioState().isAvailable());
+            if (!mCi[i].getRadioState().isAvailable()) {
+                bIsQueueIpoShutdown = true;
+            }
+        }
+
+        // it may fail on the phone which radio state is not available
+        setModemPower(MODEM_POWER_OFF, mBitmapForPhoneCount);
+    }
+
+    public void notifyIpoPreBoot() {
+        log("IPO preboot!");
+        bIsInIpoShutdown = false;
+        bIsQueueIpoShutdown = false;
+        setSilentRebootPropertyForAllModem(IS_NOT_SILENT_REBOOT);
+        setModemPower(MODEM_POWER_ON, mBitmapForPhoneCount);
+    }
+
+    /**
+     * Set modem power on/off according to DSDS or DSDA.
+     *
+     * @param power desired power of modem
+     * @param phoneId a bit map of phones you want to set
+     *              1: phone 1 only
+     *              2: phone 2 only
+     *              3: phone 1 and phone 2
+     */
+    public void setModemPower(boolean power, int phoneBitMap) {
+        log("Set Modem Power according to bitmap, Power:" + power + ", PhoneBitMap:" + phoneBitMap);
+        TelephonyManager.MultiSimVariants config = TelephonyManager.getDefault().getMultiSimConfiguration();
+
+        int phoneId = 0;
+        switch(config) {
+            case DSDS:
+                phoneId = findMainCapabilityPhoneId();
+                log("Set Modem Power under DSDS mode, Power:" + power + ", phoneId:" + phoneId);
+                mCi[phoneId].setModemPower(power, null);
+                if (power == MODEM_POWER_OFF) {
+                    for (int i = 0; i < mPhoneCount; i++) {
+                        resetSimInsertedStatus(i);
+                    }
+                }
+                break;
+
+            case DSDA:
+                for (int i = 0; i < mPhoneCount; i++) {
+                    phoneId = i;
+                    if ((phoneBitMap & (MODE_PHONE1_ONLY << i)) != 0) {
+                        log("Set Modem Power under DSDA mode, Power:" + power + ", phoneId:" + phoneId);
+                        mCi[phoneId].setModemPower(power, null);
+                        if (power == MODEM_POWER_OFF) {
+                            resetSimInsertedStatus(phoneId);
+                        }
+                    }
+                }
+                break;
+
+            case TSTS:
+                phoneId = findMainCapabilityPhoneId();
+                log("Set Modem Power under TSTS mode, Power:" + power + ", phoneId:" + phoneId);
+                mCi[phoneId].setModemPower(power, null);
+                if (power == MODEM_POWER_OFF) {
+                    for (int i = 0; i < mPhoneCount; i++) {
+                        resetSimInsertedStatus(i);
+                    }
+                }
+                break;
+
+            default:
+                phoneId = PhoneFactory.getDefaultPhone().getPhoneId();
+                log("Set Modem Power under SS mode:" + power + ", phoneId:" + phoneId);
+                mCi[phoneId].setModemPower(power, null);
+                break;
+        }
+    }
+
+    protected int findMainCapabilityPhoneId() {
+        int result = 0;
+        int switchStatus = Integer.valueOf(
+                SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1"));
+        result = switchStatus - 1;
+        if (result < 0 || result >= mPhoneCount) {
+            return 0;
+        } else {
+            return result;
+        }
+    }
+
+    /**
+     * Radio power Runnable for power on/off retry.
+     */
+    protected class RadioPowerRunnable implements Runnable {
+        boolean retryPower;
+        int retryPhoneId;
+        public  RadioPowerRunnable(boolean power, int phoneId) {
+            retryPower = power;
+            retryPhoneId = phoneId;
+        }
+        @Override
+        public void run() {
+            setRadioPower(retryPower, retryPhoneId);
+        }
+    }
+
+    /*
+     * MTK flow to control radio power
+     */
+    public void setRadioPower(boolean power, int phoneId) {
+        log("setRadioPower, power=" + power + "  phoneId=" + phoneId);
+
+        if (isFlightModePowerOffModemEnabled() && mAirplaneMode == AIRPLANE_MODE_ON) {
+            log("Set Radio Power under airplane mode, ignore");
+            return;
+        }
+
+        ///M:There is no modem on wifi-only device @{
+        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
+                Context.CONNECTIVITY_SERVICE);
+        if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE) == false) {
+            log("wifi-only device, so return");
+            return;
+        }
+        ///  @}
+
+        if (isModemPowerOff(phoneId)) {
+            log("modem for phone " + phoneId + " off, do not set radio again");
+            return;
+        }
+
+        /**
+        * We want iccid ready berfore we check if SIM is once manually turned-offedd
+        * So we check ICCID repeatedly every 300 ms
+        */
+        if (!isIccIdReady(phoneId)) {
+            log("RILD initialize not completed, wait for " + INITIAL_RETRY_INTERVAL_MSEC + "ms");
+            RadioPowerRunnable setRadioPowerRunnable = new RadioPowerRunnable(power, phoneId);
+            postDelayed(setRadioPowerRunnable, INITIAL_RETRY_INTERVAL_MSEC);
+            return;
+        }
+
+        setSimInsertedStatus(phoneId);
+
+        boolean radioPower = power;
+        String iccId = readIccIdUsingPhoneId(phoneId);
+        //adjust radio power according to ICCID
+        if (sIccidPreference.contains(iccId)) {
+            log("Adjust radio to off because once manually turned off, iccid: " + iccId + " , phone: " + phoneId);
+            radioPower = RADIO_POWER_OFF;
+        }
+
+        if (mWifiOnlyMode == WIFI_ONLY_MODE_ON && mIsEccCall == false) {
+            log("setradiopower but wifi only, turn off");
+            radioPower = RADIO_POWER_OFF;
+        }
+
+        boolean isCTACase = checkForCTACase();
+
+        if (getSimInsertedStatus(phoneId) == NO_SIM_INSERTED) {
+            if (isCTACase == true) {
+                int capabilityPhoneId = findMainCapabilityPhoneId();
+                log("No SIM inserted, force to turn on 3G/4G phone " +
+                    capabilityPhoneId + " radio if no any sim radio is enabled!");
+                PhoneFactory.getPhone(capabilityPhoneId).setRadioPower(RADIO_POWER_ON);
+                for (int i = 0; i < mPhoneCount; i++) {
+                    if (i != capabilityPhoneId) {
+                        PhoneFactory.getPhone(i).setRadioPower(RADIO_POWER_OFF);
+                    }
+                }
+
+            } else if (true == mIsEccCall) {
+                log("ECC call Radio Power, power: " + radioPower + ", phoneId: " + phoneId);
+                PhoneFactory.getPhone(phoneId).setRadioPower(radioPower);
+            } else {
+                log("No SIM inserted, turn Radio off!");
+                radioPower = RADIO_POWER_OFF;
+                PhoneFactory.getPhone(phoneId).setRadioPower(radioPower);
+            }
+        } else {
+            log("Trigger set Radio Power, power: " + radioPower + ", phoneId: " + phoneId);
+            // We must refresh sim setting during boot up or if we adjust power according to ICCID
+            refreshSimSetting(radioPower, phoneId);
+            PhoneFactory.getPhone(phoneId).setRadioPower(radioPower);
+        }
+    }
+
+    // For C2K SVLTE @{
+    protected int getSimInsertedStatus(int phoneId) {
+        return mSimInsertedStatus[phoneId];
+    }
+
+    // @}
+
+    protected void setSimInsertedStatus(int phoneId) {
+        String iccId = readIccIdUsingPhoneId(phoneId);
+        if (STRING_NO_SIM_INSERTED.equals(iccId)) {
+            mSimInsertedStatus[phoneId] = NO_SIM_INSERTED;
+        } else {
+            mSimInsertedStatus[phoneId] = SIM_INSERTED;
+        }
+    }
+
+    protected boolean isIccIdReady(int phoneId) {
+        String iccId = readIccIdUsingPhoneId(phoneId);
+        boolean ret = ICC_READ_NOT_READY;
+        if (iccId == null || "".equals(iccId)) {
+            log("ICC read not ready for phone:" + phoneId);
+            ret = ICC_READ_NOT_READY;
+        } else {
+            log("ICC read ready, iccid[" + phoneId + "]: " + iccId);
+            ret = ICC_READ_READY;
+        }
+        return ret;
+    }
+
+    protected String readIccIdUsingPhoneId(int phoneId) {
+        String ret = SystemProperties.get(PROPERTY_ICCID_SIM[phoneId]);
+        log("ICCID for phone " + phoneId + " is " + ret);
+        return ret;
+    }
+
+    /**
+     * Use to check current is CTA case or not.
+     * @return ture is CTA case
+     */
+    public boolean checkForCTACase() {
+        boolean isCTACase = true;
+        log("Check For CTA case!");
+        if (mAirplaneMode == AIRPLANE_MODE_OFF && mWifiOnlyMode != WIFI_ONLY_MODE_ON){
+            for (int i = 0; i < mPhoneCount; i++) {
+                log("Check For CTA case: mSimInsertedStatus[" + i + "]:"  + mSimInsertedStatus[i]);
+                if (mSimInsertedStatus[i] == SIM_INSERTED || mSimInsertedStatus[i] == SIM_NOT_INITIALIZED) {
+                    isCTACase = false;
+                }
+            }
+        } else {
+            isCTACase = false;
+        }
+
+        if ((false == isCTACase) && (false == mIsEccCall)) {
+            turnOffCTARadioIfNecessary();
+        }
+        log("CTA case: " + isCTACase);
+        return isCTACase;
+    }
+
+    /*
+     * We need to turn off Phone's radio if no SIM inserted (radio on because CTA) after we leave CTA case
+     */
+    private void turnOffCTARadioIfNecessary() {
+        for (int i = 0; i < mPhoneCount; i++) {
+            if (mSimInsertedStatus[i] == NO_SIM_INSERTED) {
+                if (isModemPowerOff(i)) {
+                    log("modem off, not to handle CTA");
+                    return;
+                } else {
+                    log("turn off phone " + i + " radio because we are no longer in CTA mode");
+                    PhoneFactory.getPhone(i).setRadioPower(RADIO_POWER_OFF);
+                }
+            }
+        }
+    }
+
+    /*
+     * Refresh MSIM Settings only when:
+     * We auto turn off a SIM card once manually turned off
+     */
+    protected void refreshSimSetting(boolean radioPower, int phoneId) {
+        // MTK TODO
+        // int simMode = Settings.System.getInt(mContext.getContentResolver(),
+        //                   Settings.System.MSIM_MODE_SETTING, mBitmapForPhoneCount);
+        int simMode = mBitmapForPhoneCount;
+        int oldMode = simMode;
+
+        if (radioPower == RADIO_POWER_OFF) {
+            simMode &= ~(MODE_PHONE1_ONLY << phoneId);
+        } else {
+            simMode |= (MODE_PHONE1_ONLY << phoneId);
+        }
+
+        if (simMode != oldMode) {
+            log("Refresh MSIM mode setting to " + simMode + " from " + oldMode);
+            // MTK TODO
+            /*
+            Settings.System.putInt(mContext.getContentResolver(),
+                Settings.System.MSIM_MODE_SETTING, simMode);
+            */
+        }
+    }
+
+    /**
+     * Wait ICCID ready when force set radio power.
+     */
+    protected class ForceSetRadioPowerRunnable implements Runnable {
+        boolean mRetryPower;
+        int mRetryPhoneId;
+        public  ForceSetRadioPowerRunnable(boolean power, int phoneId) {
+            mRetryPower = power;
+            mRetryPhoneId = phoneId;
+        }
+        @Override
+        public void run() {
+            forceSetRadioPower(mRetryPower, mRetryPhoneId);
+        }
+    }
+
+    /**
+     * force turn on radio and remove iccid for preference to prevent being turned off again
+     * 1. For ECC call
+     */
+    public void forceSetRadioPower(boolean power, int phoneId) {
+        log("force set radio power for phone" + phoneId + " ,power: " + power);
+
+        if (isFlightModePowerOffModemEnabled() && mAirplaneMode == AIRPLANE_MODE_ON) {
+            log("Force Set Radio Power under airplane mode, ignore");
+            return;
+        }
+
+        if (bIsInIpoShutdown) {
+            log("Force Set Radio Power under ipo shutdown, ignore");
+            return;
+        }
+
+        /**
+        * We want iccid ready berfore we check if SIM is once manually turned-offedd
+        * So we check ICCID repeatedly every 300 ms
+        */
+        if (!isIccIdReady(phoneId)) {
+            log("force set radio power, read iccid not ready, wait for" +
+                INITIAL_RETRY_INTERVAL_MSEC + "ms");
+            ForceSetRadioPowerRunnable forceSetRadioPowerRunnable =
+                new ForceSetRadioPowerRunnable(power, phoneId);
+            postDelayed(forceSetRadioPowerRunnable,
+                INITIAL_RETRY_INTERVAL_MSEC);
+            return;
+        }
+
+        boolean radioPower = power;
+        refreshIccIdPreference(radioPower, readIccIdUsingPhoneId(phoneId));
+        PhoneFactory.getPhone(phoneId).setRadioPower(power);
+    }
+
+    /**
+     * Force turn on radio and remove iccid for preference to prevent being turned off again
+     * For CT ECC call
+     * @param power for on/off radio power
+     * @param phoneId for phone ID
+     * @param isEccOn for if ECC call on-going
+     */
+    public void forceSetRadioPower(boolean power, int phoneId, boolean isEccOn) {
+        log("force set radio power isEccOn: " + isEccOn);
+        mIsEccCall = isEccOn;
+        forceSetRadioPower(power, phoneId);
+    }
+
+    /*
+     * wait ICCID ready when SIM mode change
+     */
+    private class SimModeChangeRunnable implements Runnable {
+        boolean mPower;
+        int mPhoneId;
+        public SimModeChangeRunnable(boolean power, int phoneId) {
+            mPower = power;
+            mPhoneId = phoneId;
+        }
+        @Override
+        public void run() {
+            notifySimModeChange(mPower, mPhoneId);
+        }
+    }
+
+    /**
+     * Refresh ICCID preference due to toggling on SIM management except for below cases:
+     * 1. SIM Mode Feature not defined
+     * 2. Under Airplane Mode (PhoneGlobals will call GSMPhone.setRadioPower after receving airplane mode change)
+     * @param power power on -> remove preference
+     *               power off -> add to preference
+     */
+    public void notifySimModeChange(boolean power, int phoneId) {
+        log("SIM mode changed, power: " + power + ", phoneId" + phoneId);
+        if (!isMSimModeSupport() || mAirplaneMode == AIRPLANE_MODE_ON) {
+            log("Airplane mode on or MSIM Mode option is closed, do nothing!");
+            return;
+        } else {
+            if (!isIccIdReady(phoneId)) {
+                log("sim mode read iccid not ready, wait for "
+                    + INITIAL_RETRY_INTERVAL_MSEC + "ms");
+                SimModeChangeRunnable notifySimModeChangeRunnable
+                    = new SimModeChangeRunnable(power, phoneId);
+                postDelayed(notifySimModeChangeRunnable, INITIAL_RETRY_INTERVAL_MSEC);
+                return;
+            }
+            //once ICCIDs are ready, then set the radio power
+            if (STRING_NO_SIM_INSERTED.equals(readIccIdUsingPhoneId(phoneId))) {
+                power = RADIO_POWER_OFF;
+                log("phoneId " + phoneId + " sim not insert, set  power  to " + power);
+            }
+            refreshIccIdPreference(power, readIccIdUsingPhoneId(phoneId));
+            log("Set Radio Power due to SIM mode change, power: " + power + ", phoneId: " + phoneId);
+            setPhoneRadioPower(power, phoneId);
+        }
+    }
+
+    protected void setPhoneRadioPower(boolean power, int phoneId) {
+        PhoneFactory.getPhone(phoneId).setRadioPower(power);
+    }
+
+
+    /**
+     * Wait ICCID ready when MSIM modem change.
+     * @Deprecated
+     */
+    protected class MSimModeChangeRunnable implements Runnable {
+        int mRetryMode;
+        public  MSimModeChangeRunnable(int mode) {
+            mRetryMode = mode;
+        }
+        @Override
+        public void run() {
+            notifyMSimModeChange(mRetryMode);
+        }
+    }
+
+    /**
+     * Refresh ICCID preference due to toggling on SIM management except for below cases:
+     * 1. SIM Mode Feature not defined
+     * 2. Under Airplane Mode (PhoneGlobals will call GSMPhone.setRadioPower after receving airplane mode change)
+     * @param power power on -> remove preference
+     *               power off -> add to preference
+     * @internal
+     * @Deprecated
+     */
+    public void notifyMSimModeChange(int mode) {
+        log("MSIM mode changed, mode: " + mode);
+        if (mode == -1) {
+            log("Invalid mode, MSIM_MODE intent has no extra value");
+            return;
+        }
+        if (!isMSimModeSupport() || mAirplaneMode == AIRPLANE_MODE_ON) {
+            log("Airplane mode on or MSIM Mode option is closed, do nothing!");
+            return;
+        } else {
+            //all ICCCIDs need be ready berfore set radio power
+            int phoneId = 0;
+            boolean iccIdReady = true;
+            for (phoneId = 0; phoneId < mPhoneCount; phoneId++) {
+                if (!isIccIdReady(phoneId)) {
+                    iccIdReady = false;
+                    break;
+                }
+            }
+            if (!iccIdReady) {
+                log("msim mode read iccid not ready, wait for "
+                    + INITIAL_RETRY_INTERVAL_MSEC + "ms");
+                MSimModeChangeRunnable notifyMSimModeChangeRunnable
+                    = new MSimModeChangeRunnable(mode);
+                postDelayed(notifyMSimModeChangeRunnable, INITIAL_RETRY_INTERVAL_MSEC);
+                return;
+            }
+            //once ICCIDs are ready, then set the radio power
+            for (phoneId = 0; phoneId < mPhoneCount; phoneId++) {
+                boolean singlePhonePower = ((mode & (MODE_PHONE1_ONLY << phoneId)) == 0) ? RADIO_POWER_OFF : RADIO_POWER_ON;
+                if (STRING_NO_SIM_INSERTED.equals(readIccIdUsingPhoneId(phoneId))) {
+                    singlePhonePower = RADIO_POWER_OFF;
+                    log("phoneId " + phoneId + " sim not insert, set  power  to " + singlePhonePower);
+                }
+                refreshIccIdPreference(singlePhonePower, readIccIdUsingPhoneId(phoneId));
+                log("Set Radio Power due to MSIM mode change, power: " + singlePhonePower
+                        + ", phoneId: " + phoneId);
+                setPhoneRadioPower(singlePhonePower, phoneId);
+            }
+        }
+    }
+
+    protected void refreshIccIdPreference(boolean power, String iccid) {
+        log("refresh iccid preference");
+        SharedPreferences.Editor editor = sIccidPreference.edit();
+        if (power == RADIO_POWER_OFF && !STRING_NO_SIM_INSERTED.equals(iccid)) {
+            putIccIdToPreference(editor, iccid);
+        } else {
+            removeIccIdFromPreference(editor, iccid);
+        }
+        editor.commit();
+    }
+
+    private void putIccIdToPreference(SharedPreferences.Editor editor, String iccid) {
+        if (iccid != null) {
+            log("Add radio off SIM: " + iccid);
+            editor.putInt(iccid, 0);
+         }
+    }
+
+    private void removeIccIdFromPreference(SharedPreferences.Editor editor, String iccid) {
+        if (iccid != null) {
+            log("Remove radio off SIM: " + iccid);
+            editor.remove(iccid);
+        }
+    }
+
+    /*
+     * Some Request or AT command must made before EFUN
+     * 1. Prevent waiting for response
+     * 2. Send commands as the same channel as EFUN or CFUN
+     */
+    public static void sendRequestBeforeSetRadioPower(boolean power, int phoneId) {
+        log("Send request before EFUN, power:" + power + " phoneId:" + phoneId);
+
+        notifyRadioPowerChange(power, phoneId);
+    }
+
+    /**
+     * MTK Power on feature
+     * 1. Radio off a card from SIM Management
+     * 2. Flight power off modem
+     * @internal
+     */
+    public static boolean isPowerOnFeatureAllClosed() {
+        boolean ret = true;
+        if (isFlightModePowerOffModemEnabled()) {
+            ret = false;
+        } else if (isRadioOffPowerOffModemEnabled()) {
+            ret = false;
+        } else if (isMSimModeSupport()) {
+            ret = false;
+        }
+        return ret;
+    }
+
+    public static boolean isRadioOffPowerOffModemEnabled() {
+        return SystemProperties.get("ro.mtk_radiooff_power_off_md").equals("1");
+    }
+
+    public static boolean isFlightModePowerOffModemEnabled() {
+        if (SystemProperties.get("ril.testmode").equals("1")) {
+            return SystemProperties.get("ril.test.poweroffmd").equals("1");
+        } else {
+            return SystemProperties.get("ro.mtk_flight_mode_power_off_md").equals("1") ||
+                   SystemProperties.get("gsm.sim.ril.testsim").equals("1") ||
+                   SystemProperties.get("gsm.sim.ril.testsim.2").equals("1") ||
+                   SystemProperties.get("gsm.sim.ril.testsim.3").equals("1") ||
+                   SystemProperties.get("gsm.sim.ril.testsim.4").equals("1");
+        }
+    }
+
+    /**
+     *  Check if modem is already power off.
+     **/
+    public static boolean isModemPowerOff(int phoneId) {
+        return RadioManager.getInstance().isModemOff(phoneId);
+    }
+
+    public static boolean isMSimModeSupport() {
+        // TODO: adds logic
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    private void setAirplaneMode(boolean enabled) {
+        log("set mAirplaneMode as:" + enabled);
+        mAirplaneMode = enabled;
+    }
+
+    private boolean getAirplaneMode() {
+        return mAirplaneMode;
+    }
+
+
+    protected void resetSimInsertedStatus(int phoneId) {
+        log("reset Sim InsertedStatus for Phone:" + phoneId);
+        mSimInsertedStatus[phoneId] = SIM_NOT_INITIALIZED;
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        int[] ints;
+        String[] strings;
+        Message message;
+        int phoneIdForMsg = getCiIndex(msg);
+
+        log("handleMessage msg.what: " + eventIdtoString(msg.what));
+        switch (msg.what) {
+            case EVENT_RADIO_AVAILABLE:
+                if (bIsQueueIpoShutdown) {
+                    log("bIsQueueIpoShutdown is true");
+                    bIsQueueIpoShutdown = false;
+                }
+                break;
+            case EVENT_VIRTUAL_SIM_ON:
+                forceSetRadioPower(RADIO_POWER_ON, phoneIdForMsg);
+                break;
+            default:
+                super.handleMessage(msg);
+                break;
+        }
+    }
+
+    private String eventIdtoString(int what) {
+        String str = null;
+        switch (what) {
+            case EVENT_RADIO_AVAILABLE:
+                str = "EVENT_RADIO_AVAILABLE";
+                break;
+            case EVENT_VIRTUAL_SIM_ON:
+                str = "EVENT_VIRTUAL_SIM_ON";
+                break;
+            default:
+                break;
+        }
+        return str;
+    }
+
+    private int getCiIndex(Message msg) {
+        AsyncResult ar;
+        Integer index = new Integer(PhoneConstants.DEFAULT_CARD_INDEX);
+
+        /*
+         * The events can be come in two ways. By explicitly sending it using
+         * sendMessage, in this case the user object passed is msg.obj and from
+         * the CommandsInterface, in this case the user object is msg.obj.userObj
+         */
+        if (msg != null) {
+            if (msg.obj != null && msg.obj instanceof Integer) {
+                index = (Integer) msg.obj;
+            } else if (msg.obj != null && msg.obj instanceof AsyncResult) {
+                ar = (AsyncResult) msg.obj;
+                if (ar.userObj != null && ar.userObj instanceof Integer) {
+                    index = (Integer) ar.userObj;
+                }
+            }
+        }
+        return index.intValue();
+    }
+
+    protected boolean isModemOff(int phoneId) {
+        boolean powerOff = false;
+        TelephonyManager.MultiSimVariants config
+            = TelephonyManager.getDefault().getMultiSimConfiguration();
+        switch(config) {
+            case DSDS:
+                powerOff = SystemProperties.get("ril.ipo.radiooff").equals("1");
+                break;
+            case DSDA:
+                switch (phoneId) {
+                    case 0: //phone 1
+                        powerOff = SystemProperties.get("ril.ipo.radiooff").equals("1");
+                        break;
+                    case 1: //phone 2
+                        powerOff = SystemProperties.get("ril.ipo.radiooff.2").equals("1");
+                        break;
+                    default:
+                        powerOff = true;
+                        break;
+                }
+                break;
+            case TSTS:
+                //TODO: check 3 SIM case
+                powerOff = SystemProperties.get("ril.ipo.radiooff").equals("1");
+                break;
+            default:
+                 powerOff = SystemProperties.get("ril.ipo.radiooff").equals("1");
+                break;
+        }
+        return powerOff;
+    }
+
+     public static synchronized void registerForRadioPowerChange(String name, IRadioPower iRadioPower) {
+        if (name == null) {
+            name = REGISTRANTS_WITH_NO_NAME;
+        }
+        log(name + " registerForRadioPowerChange");
+        mNotifyRadioPowerChange.put(iRadioPower, name);
+    }
+
+    public static synchronized void unregisterForRadioPowerChange(IRadioPower iRadioPower) {
+        log(mNotifyRadioPowerChange.get(iRadioPower) + " unregisterForRadioPowerChange");
+        mNotifyRadioPowerChange.remove(iRadioPower);
+    }
+
+    private static synchronized void notifyRadioPowerChange(boolean power, int phoneId) {
+        for (Entry<IRadioPower, String> e : mNotifyRadioPowerChange.entrySet()) {
+            log("notifyRadioPowerChange: user:" + e.getValue());
+            IRadioPower iRadioPower = e.getKey();
+            iRadioPower.notifyRadioPowerChange(power, phoneId);
+        }
+    }
+
+    private static void log(String s) {
+        Rlog.d(LOG_TAG, "[RadioManager] " + s);
+    }
+
+    public boolean isAllowAirplaneModeChange() {
+        return mAirplaneRequestHandler.allowSwitching();
+    }
+
+    /**
+     * Set Whether force allow airplane mode change.
+     * @return true or false
+     */
+    public void forceAllowAirplaneModeChange(boolean forceSwitch) {
+        mAirplaneRequestHandler.setForceSwitch(forceSwitch);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/SrvccCallContext.java b/src/java/com/mediatek/internal/telephony/SrvccCallContext.java
new file mode 100755
index 0000000..e0145d8
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/SrvccCallContext.java
@@ -0,0 +1,330 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.internal.telephony;
+
+/**
+ * To pass IMS call context to CS modem.
+ * {@hide}
+ */
+public class SrvccCallContext {
+    /* Between 1 and 7 */
+    private int mCallId;
+
+    /*
+       0: voice call
+       1: video call
+       2: emergency call
+       3: voice conference call
+       other values are reserved for future extend
+     */
+    private int mCallMode;
+
+    /*
+       0: MO call
+       1: MT call
+     */
+    private int mCallDirection;
+
+    /*
+       0: Early
+       1: Early with media (already attached speech in Alerting state)
+       2: Active
+       3: On Hold
+     */
+    private int mCallState;
+
+    /*
+       0x0000: unspecified
+       0x0001: police
+       0x0002: ambulance
+       0x0004: fire brigade
+       0x0008: marine guard
+       0x0010: mountain rescue
+       0x0020: gas
+       0x0040: animal
+       0x0080: physician
+       0x0100: poison
+       0xFFFF: not emergency call
+     */
+    private int mEccCategory;
+
+
+
+    /*
+      1: URI format
+      2: BCD format
+    */
+    private int mNumberType;
+
+    private String mNumber;
+
+    private String mName;
+
+    /*
+      <CLI validity>: integer type. This parameter can provide details why <number>
+      does not contain a calling party BCD number (refer 3GPP TS 24.008 [8] subclause
+      10.5.4.30). The parameter is not present for MO call
+      types.
+      0 CLI valid
+      1 CLI has been withheld by the originator (refer 3GPP TS 24.008 [8] table 10.5.135a/
+        3GPP TS 24.008 code "Reject by user")
+      2 CLI is not available due to interworking problems or limitations of originating
+        network (refer 3GPP TS 24.008 [8] table 10.5.135a/3GPP TS 24.008 code
+        "Interaction with other service")
+      3 CLI is not available due to calling party being of type payphone
+        (refer 3GPP TS 24.008 [8] table 10.5.135a/3GPP TS 24.008 code "Coin line/payphone")
+      4 CLI is not available due to other reasons (refer 3GPP TS 24.008 [8] table 10.5.135a/
+        3GPP TS 24.008 code "Unavailable")    */
+    private int mCliValidity;
+
+    /**
+     * Constructor function.
+     *
+     * @param callId call id.
+     * @param callMode call mode.
+     * @param callDirection call direction.
+     * @param callState call state.
+     * @param eccCategory emergency category.
+     * @param numberType number type.
+     * @param phoneNumber phone number.
+     * @param name Name information.
+     * @param cliValidity CLI validity.
+     *
+     *
+     */
+    public SrvccCallContext(int callId,
+                            int callMode,
+                            int callDirection,
+                            int callState,
+                            int eccCategory,
+                            int numberType,
+                            String phoneNumber,
+                            String name,
+                            int cliValidity) {
+        mCallId = callId;
+        mCallMode = callMode;
+        mCallDirection = callDirection;
+        mCallState = callState;
+        mEccCategory = eccCategory;
+        mNumberType = numberType;
+        mNumber = phoneNumber;
+        mName = name;
+        mCliValidity = cliValidity;
+    }
+
+    /**
+     * Set call id.
+     *
+     * @param callId call id.
+     *
+     */
+    public void setCallId(int callId) {
+          mCallId = callId;
+    }
+
+    /**
+     * Set call mode.
+     *
+     * @param callMode call mode.
+     *
+     */
+    public void setCallMode(int callMode) {
+          mCallMode = callMode;
+    }
+
+    /**
+     * Set call direction.
+     *
+     * @param callDirection call direction.
+     *
+     */
+    public void setCallDirection(int callDirection) {
+          mCallDirection = callDirection;
+    }
+
+    /**
+     * Set call state.
+     *
+     * @param callState call state.
+     *
+     */
+    public void setCallState(int callState) {
+          mCallState = callState;
+    }
+
+    /**
+     * Set emergency category.
+     *
+     * @param eccCategory emergency category.
+     *
+     */
+    public void setEccCategory(int eccCategory) {
+          mEccCategory = eccCategory;
+    }
+
+    /**
+     * Set number type.
+     *
+     * @param numberType number type.
+     *
+     */
+    public void setNumberType(int numberType) {
+          mNumberType = numberType;
+    }
+
+    /**
+     * Set number.
+     *
+     * @param phoneNumber phone number.
+     *
+     */
+    public void setCallState(String phoneNumber) {
+          mNumber = phoneNumber;
+    }
+
+    /**
+     * Set name.
+     *
+     * @param name Name information.
+     *
+     */
+    public void setName(String name) {
+          mName = name;
+    }
+
+    /**
+     * Set CLI validity.
+     *
+     * @param cliValidity CLI validity.
+     *
+     */
+    public void setCliValidity(int cliValidity) {
+          mCliValidity = cliValidity;
+    }
+
+    /**
+     * Retrieve call id.
+     *
+     * @return call id.
+     *
+     */
+    public int getCallId() {
+          return mCallId;
+    }
+
+    /**
+     * Retrieve call mode.
+     *
+     * @return call mode.
+     *
+     */
+    public int getCallMode() {
+          return mCallMode;
+    }
+
+    /**
+     * Retrieve call direction.
+     *
+     * @return call direction.
+     *
+     */
+    public int getCallDirection() {
+          return mCallDirection;
+    }
+
+    /**
+     * Retrieve call state.
+     *
+     * @return call state.
+     *
+     */
+    public int getCallState() {
+          return mCallState;
+    }
+
+    /**
+     * Retrieve emergency category.
+     *
+     * @return emergency category.
+     *
+     */
+    public int getEccCategory() {
+          return mEccCategory;
+    }
+
+    /**
+     * Retrieve number type.
+     *
+     * @return number type.
+     *
+     */
+    public int getNumberType() {
+          return mNumberType;
+    }
+
+    /**
+     * Retrieve phone number.
+     *
+     * @return phone number.
+     *
+     */
+    public String getNumber() {
+          return mNumber;
+    }
+
+    /**
+     * Retrieve name.
+     *
+     * @return name.
+     *
+     */
+    public String getName() {
+          return mName;
+    }
+
+    /**
+     * Retrieve CLI validity.
+     *
+     * @return CLI validity.
+     *
+     */
+    public int getCliValidity() {
+          return mCliValidity;
+    }
+}
\ No newline at end of file
diff --git a/src/java/com/mediatek/internal/telephony/cdma/CdmaFeatureOptionUtils.java b/src/java/com/mediatek/internal/telephony/cdma/CdmaFeatureOptionUtils.java
new file mode 100644
index 0000000..36372d1
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/cdma/CdmaFeatureOptionUtils.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony.cdma;
+
+import android.os.SystemProperties;
+import com.android.internal.telephony.PhoneConstants;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccUtils;
+
+/**
+ * The utilities class of CDMA related feature option definitions.
+ * @hide
+ */
+public class CdmaFeatureOptionUtils {
+
+    // EVDO dual talk support system property
+    public static final String EVDO_DT_SUPPORT = "ril.evdo.dtsupport";
+    // SVLTE support system property
+    public static final String MTK_SVLTE_SUPPORT = "ro.mtk_svlte_support";
+    // SRLTE support system property
+    public static final String MTK_SRLTE_SUPPORT = "ro.mtk_srlte_support";
+    // IRAT support system property
+    public static final String MTK_IRAT_SUPPORT = "ro.c2k.irat.support";
+    // MTK C2K support
+    public static final String MTK_C2K_SUPPORT = "ro.mtk_c2k_support";
+    // C2K World Phone Solution2
+    public static final String MTK_C2KWP_P2_SUPPORT = "ro.mtk.c2k.slot2.support";
+    // C2K World Phone Solution2 Sim Switch
+    public static final String MTK_C2KWP_SIMSWITCH_SUPPORT = "ro.mtk.c2kwp.simswitch.support";
+    // C2K OM World Phone Network Selection Type
+    public static final String MTK_C2K_OM_NW_SEL_TYPE = "ro.mtk_c2k_om_nw_sel_type";
+    // CT C 6M support
+    public static final String MTK_CT6M_SUPPORT = "ro.ct6m_support";
+    // CT LTE TDD TEST ONLY
+    private static final String MTK_CT_LTE_TDD_TEST = "persist.sys.forcttddtest";
+    // Flight mode power off modem support
+    public static final String MTK_FLIGHT_MODE_POWER_OFF_MODEM_SUPPORT
+            = "ro.mtk_flight_mode_power_off_md";
+
+    // Feature support.
+    public static final String SUPPORT_YES = "1";
+
+    /**
+     * Check if EVDO_DT_SUPPORT feature option support is true.
+     * @return true if SVLTE is enabled
+     */
+    public static boolean isEvdoDTSupport() {
+        if (SystemProperties.get(EVDO_DT_SUPPORT).equals(SUPPORT_YES)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Check if CDMA LTE Dual connection(SVLTE) support is true.
+     * @return true if SVLTE is enabled
+     */
+    public static boolean isCdmaLteDcSupport() {
+        if (SystemProperties.get(MTK_SVLTE_SUPPORT).equals(SUPPORT_YES) ||
+                SystemProperties.get(MTK_SRLTE_SUPPORT).equals(SUPPORT_YES)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Check if CDMA LTE Dual connection(SVLTE) support is true.
+     * @return true if SVLTE is enabled
+     */
+    public static boolean isSvlteSupport() {
+        return SystemProperties.get(MTK_SVLTE_SUPPORT).equals(SUPPORT_YES);
+    }
+
+    /**
+     * Check if CDMA LTE Dual connection(SRLTE) support is true.
+     * @return true if SRLTE is enabled
+     */
+    public static boolean isSrlteSupport() {
+        return SystemProperties.get(MTK_SRLTE_SUPPORT).equals(SUPPORT_YES);
+    }
+
+    /**
+     * Check if CDMA IRAT feature is supported.
+     * @return True if C2K IRAT feature is supported.
+     */
+    public static boolean isCdmaIratSupport() {
+        return SystemProperties.get(MTK_IRAT_SUPPORT).equals(SUPPORT_YES);
+    }
+
+    /**
+     * Check if MTK C2K feature is supported.
+     * @return True if MTK C2K feature is supported.
+     */
+    public static boolean isMtkC2KSupport() {
+        return SystemProperties.get(MTK_C2K_SUPPORT).equals(SUPPORT_YES);
+    }
+
+    /**
+      * Get cdma slot NO.
+      * @return static int
+      */
+    public static int getExternalModemSlot() {
+        // xen0n: MTK TODO
+        /*
+        if (isCdmaLteDcSupport()) {
+            return SvlteModeController.getCdmaSocketSlotId();
+        }
+        */
+        return SystemProperties.getInt("ril.external.md", 0) - 1;
+    }
+
+    /**
+     * Check if C2K World Phone solution2 is supported.
+     * @return True if supported.
+     */
+    public static boolean isC2KWorldPhoneP2Support() {
+        return SystemProperties.get(MTK_C2KWP_P2_SUPPORT).equals(SUPPORT_YES);
+    }
+
+    /**
+     * Check if C2K World Phone solution2 Sim Switch is supported.
+     * @return True if supported.
+     */
+    public static boolean isC2KWpSimSwitchSupport() {
+        return SystemProperties.get(MTK_C2KWP_SIMSWITCH_SUPPORT).equals(SUPPORT_YES);
+    }
+
+
+    /**
+     * Get the C2K OM Network Selection Type.
+     * @return type value
+     */
+    public static int getC2KOMNetworkSelectionType() {
+        return SystemProperties.getInt(MTK_C2K_OM_NW_SEL_TYPE, 0);
+    }
+
+    /**
+     * Get the CT 6M Support
+     */
+    public static boolean isCT6MSupport() {
+        return SUPPORT_YES.equals(SystemProperties.get(MTK_CT6M_SUPPORT, "0"));
+    }
+
+    /**
+     * Get the CT LTE TDD test Support
+     */
+    public static boolean isCTLteTddTestSupport() {
+        // xen0n: MTK TODO
+        return false;
+        /*
+        return isCdmaLteDcSupport()
+                && (SUPPORT_YES.equals(SystemProperties.get(MTK_CT_LTE_TDD_TEST, "0")))
+                && (SvlteUiccUtils.getInstance().isUsimOnly(PhoneConstants.SIM_ID_1));
+        */
+    }
+
+    /**
+     * Check if flight mode power off mode feature is support.
+     * @return Ture if supported.
+     */
+    public static boolean isFlightModePowerOffModemSupport() {
+        return SystemProperties.get(MTK_FLIGHT_MODE_POWER_OFF_MODEM_SUPPORT)
+                .equals(SUPPORT_YES);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/dataconnection/IaExtendParam.java b/src/java/com/mediatek/internal/telephony/dataconnection/IaExtendParam.java
new file mode 100644
index 0000000..1c102a3
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/dataconnection/IaExtendParam.java
@@ -0,0 +1,78 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.internal.telephony.dataconnection;
+
+public class IaExtendParam {
+    public String mOperatorNumeric;
+    public boolean mCanHandleIms;
+    public String[] mDualApnPlmnList;
+
+    public IaExtendParam() {
+        mOperatorNumeric = "";
+        mCanHandleIms = false;
+        mDualApnPlmnList = null;
+    }
+
+    public IaExtendParam(String operatorNumeric) {
+        mOperatorNumeric = operatorNumeric;
+        mCanHandleIms = false;
+        mDualApnPlmnList = null;
+    }
+
+    public IaExtendParam(String operatorNumeric, String[] dualApnPlmnList) {
+        mOperatorNumeric = operatorNumeric;
+        mCanHandleIms = false;
+        mDualApnPlmnList = dualApnPlmnList;
+    }
+
+    public IaExtendParam(String operatorNumeric, boolean canHandleIms,
+            String[] dualApnPlmnList) {
+        mOperatorNumeric = operatorNumeric;
+        mCanHandleIms = canHandleIms;
+        mDualApnPlmnList = dualApnPlmnList;
+    }
+
+    @Override
+    public String toString() {
+        return "[OperatorNumberic: " + mOperatorNumeric + ", CanHandleIms: " + mCanHandleIms +
+                ", DualApnPlmnList: " + mDualApnPlmnList + "]";
+    }
+
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/ltedc/LteDcConstants.java b/src/java/com/mediatek/internal/telephony/ltedc/LteDcConstants.java
new file mode 100644
index 0000000..d9b1edb
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ltedc/LteDcConstants.java
@@ -0,0 +1,17 @@
+package com.mediatek.internal.telephony.ltedc;
+
+/**
+ * LTE DC constants for reference.
+ */
+public final class LteDcConstants {
+    // Attention to not overlap with Google default DctConstants.
+    public static final int BASE_IRAT_DATA_CONNECTION = 0x00045000;
+    public static final int EVENT_IRAT_DATA_RAT_CHANGED = BASE_IRAT_DATA_CONNECTION + 0;
+    public static final int EVENT_LTE_RECORDS_LOADED = BASE_IRAT_DATA_CONNECTION + 1;
+    public static final int EVENT_RETRY_SETUP_DATA_FOR_IRAT = BASE_IRAT_DATA_CONNECTION + 2;
+
+    // PS service is on CDMA or LTE.
+    public static final int PS_SERVICE_UNKNOWN = -1;
+    public static final int PS_SERVICE_ON_CDMA = 0;
+    public static final int PS_SERVICE_ON_LTE = 1;
+}
diff --git a/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java b/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
new file mode 100644
index 0000000..5a7a58d
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony.ltedc.svlte;
+
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+
+/**
+ * Provide SVLTE sub id, phone id get, check, convert and so on.
+ */
+
+public class SvlteUtils {
+    public static final String LOG_TAG = "SvlteUtils";
+
+     /**
+         * Check if subId is lte dc sub id.
+         * @param subId sub id
+         * @return true subId is lte dc sub id
+         */
+    public static boolean isLteDcSubId(int subId) {
+        return (subId == SubscriptionManager.LTE_DC_SUB_ID_1)
+            || (subId == SubscriptionManager.LTE_DC_SUB_ID_2);
+    }
+
+     /**
+         * Get the lte sub id by slot id.
+         * @param slotId slot id
+         * @return Lte sub`s id
+         */
+    public static int getLteDcSubId(int slotId) {
+        if (slotId == PhoneConstants.SIM_ID_1) {
+            return SubscriptionManager.LTE_DC_SUB_ID_1;
+        } else if (slotId == PhoneConstants.SIM_ID_2) {
+            return SubscriptionManager.LTE_DC_SUB_ID_2;
+        } else {
+            return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        }
+    }
+
+     /**
+         * Check if phoneId is lte dc phone id.
+         * @param phoneId phone id
+         * @return true phoneId is lte dc phone id
+         */
+     public static boolean isLteDcPhoneId(int phoneId) {
+        return (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1)
+            || (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2);
+     }
+
+      /**
+         * Get the lte phone id by slot id.
+         * @param slotId slot id
+         * @return Lte phone`s id
+         */
+     public static int getLteDcPhoneId(int slotId) {
+         if (slotId == PhoneConstants.SIM_ID_1) {
+             return SubscriptionManager.LTE_DC_PHONE_ID_1;
+         } else if (slotId == PhoneConstants.SIM_ID_2) {
+             return SubscriptionManager.LTE_DC_PHONE_ID_2;
+         } else {
+             return SubscriptionManager.INVALID_PHONE_INDEX;
+         }
+     }
+
+    /**
+       * Get slot id by lte dc phone id.
+       * @param phoneId lte dc phone id
+       * @return slot id of lte dc phone
+       */
+    public static int getSlotId(int phoneId) {
+         int slotId = phoneId;
+         if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+             slotId = PhoneConstants.SIM_ID_1;
+         } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+             slotId = PhoneConstants.SIM_ID_2;
+         }
+         return slotId;
+    }
+
+    /**
+       * Get slot id by lte dc sub id.
+       * @param subId lte dc phone id
+       * @return slot id of lte dc phone
+       */
+    public static int getSlotIdbySubId(int subId) {
+         int slotId = SubscriptionManager.INVALID_SIM_SLOT_INDEX;
+         if (subId == SubscriptionManager.LTE_DC_SUB_ID_1) {
+             slotId = PhoneConstants.SIM_ID_1;
+         } else if (subId == SubscriptionManager.LTE_DC_SUB_ID_2) {
+             slotId = PhoneConstants.SIM_ID_2;
+         } else {
+             slotId = SubscriptionManager.getSlotId(subId);
+         }
+         return slotId;
+    }
+
+    /**
+       * Check if phone id is validate phone id in svlte.
+       * @param phoneId  phone id that will be check
+       * @return check result
+       */
+    public static boolean isValidPhoneId(int phoneId) {
+        return ((phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount())
+                   || isLteDcPhoneId(phoneId));
+    }
+
+    /**
+       * Check if slot id is validate slot id in svlte.
+       * @param slotId slot id that will be check
+       * @return check result
+       */
+    public static boolean isValidateSlotId(int slotId) {
+        return (slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount());
+    }
+
+    // MTK TODO
+    /**
+       * Get SvltePhoneProxy of phoneId.
+       * @param phoneId phone id
+       * @return SvltePhoneProxy of phoneId
+       */
+    /*
+    public static SvltePhoneProxy getSvltePhoneProxy(int phoneId) {
+        if (PhoneFactory.getPhone(phoneId) instanceof SvltePhoneProxy) {
+            return (SvltePhoneProxy) (PhoneFactory.getPhone(phoneId));
+        } else {
+            throw new IllegalStateException("Not SvltePhoneProxy!");
+        }
+    }
+    */
+
+    /**
+        * Check if phoneId is active svlte mode.
+        * @param phoneId Phone id
+        * @return true if phoneId is active svlte mode
+        */
+    public static boolean isActiveSvlteMode(int phoneId) {
+        // MTK TODO
+        // return SvlteModeController.getActiveSvlteModeSlotId() == getSlotId(phoneId);
+        return false;
+    }
+
+    /**
+        * Check if phone is active svlte mode.
+        * @param phone Phone
+        * @return true if phone is active svlte mode
+        */
+    public static boolean isActiveSvlteMode(Phone phone) {
+        return isActiveSvlteMode(phone.getPhoneId());
+    }
+
+    /**
+        * Get phone id of SVLTE active phone.
+        * @param phoneId Phone id
+        * @return  phone id of SVLTE phone
+        */
+    public static int getSvltePhoneIdByPhoneId(int phoneId) {
+        int curPhoneId = phoneId;
+        if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+            curPhoneId = PhoneConstants.SIM_ID_1;
+        } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+            curPhoneId = PhoneConstants.SIM_ID_2;
+        }
+        return curPhoneId;
+    }
+
+   /**
+       * Get phone id of SVLTE active phone.
+       * @param phone Phone
+       * @return  phone id of SVLTE phone
+       */
+    public static int getSvltePhoneIdByPhone(Phone phone) {
+        return getSvltePhoneIdByPhoneId(phone.getPhoneId());
+    }
+
+   /**
+       * Get sub id of SVLTE active phone.
+       * @param subId Sub id
+       * @return sub id of SVLTE phone
+       */
+    public static int getSvlteSubIdBySubId(int subId) {
+        if (isLteDcSubId(subId)) {
+            int[] subIds = SubscriptionManager.getSubId(getSlotIdbySubId(subId));
+            if (subIds != null && subIds.length > 0) {
+                return subIds[0];
+            }
+        }
+        return subId;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, msg);
+    }
+
+    /**
+     * Get the cdma_rat_mode key.
+     * @param subId sub id
+     * @return the cdma_rat_mode key
+     */
+    public static String getCdmaRatModeKey(int subId) {
+        // MTK TODO
+        /*
+        if (("OP09").equals(SystemProperties.get("ro.operator.optr", "OM"))) {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE;
+        } else {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE + subId;
+        }
+        */
+        return null;
+    }
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
new file mode 100755
index 0000000..e5cd741
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
@@ -0,0 +1,122 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+public interface IWorldPhone {
+    public static final String LOG_TAG = "PHONE";
+
+    public static final int POLICY_OM       = 0;
+    public static final int POLICY_OP01     = 1;
+
+    static final int SELECTION_MODE_MANUAL = 0;
+    static final int SELECTION_MODE_AUTO   = 1;
+
+    static final int UNKNOWN_USER = 0;
+    static final int TYPE1_USER   = 1;
+    static final int TYPE2_USER   = 2;
+    static final int TYPE3_USER   = 3;
+
+    static final int REGION_UNKNOWN  = 0;
+    static final int REGION_DOMESTIC = 1;
+    static final int REGION_FOREIGN  = 2;
+
+    static final int EVENT_RADIO_ON_1 = 0;
+    static final int EVENT_RADIO_ON_2 = 1;
+    static final int EVENT_REG_PLMN_CHANGED_1 = 10;
+    static final int EVENT_REG_PLMN_CHANGED_2 = 11;
+    static final int EVENT_REG_SUSPENDED_1    = 30;
+    static final int EVENT_REG_SUSPENDED_2    = 31;
+    static final int EVENT_STORE_MODEM_TYPE   = 40;
+    static final int EVENT_QUERY_MODEM_TYPE   = 50;
+    static final int EVENT_INVALID_SIM_NOTIFY_1 = 60;
+    static final int EVENT_INVALID_SIM_NOTIFY_2 = 61;
+    static final int EVENT_RESUME_CAMPING       = 70;   //[ALPS01974750]
+
+    //C2K world phone - start
+    static final int EVENT_RADIO_ON_SVLTE_1 = 1000;
+    static final int EVENT_RADIO_ON_SVLTE_2 = 1001;
+    static final int EVENT_REG_PLMN_CHANGED_SVLTE_1 = 1010;
+    static final int EVENT_REG_PLMN_CHANGED_SVLTE_2 = 1011;
+    static final int EVENT_REG_SUSPENDED_SVLTE_1    = 1030;
+    static final int EVENT_REG_SUSPENDED_SVLTE_2    = 1031;
+    static final int EVENT_INVALID_SIM_NOTIFY_SVLTE_1 = 1040;
+    static final int EVENT_INVALID_SIM_NOTIFY_SVLTE_2 = 1041;
+    static final int EVENT_WP_CARD_TYPE_READY         = 1050;  //[ALPS02045100]
+    static final int EVENT_WP_GMSS_RAT_CHANGED_1      = 1060;  //[ALPS02156732]
+    static final int EVENT_WP_GMSS_RAT_CHANGED_2      = 1061;  //[ALPS02156732]
+    //C2K world phone - end
+
+    static final int DEFAULT_MAJOR_SIM    = 0;
+    static final int MAJOR_CAPABILITY_OFF = -1;
+    static final int AUTO_SWITCH_OFF      = -98;
+    static final int MAJOR_SIM_UNKNOWN    = -99;
+
+    static final int CAMP_ON_NOT_DENIED                     = 0;
+    static final int CAMP_ON_DENY_REASON_UNKNOWN            = 1;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD = 2;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD = 3;
+    static final int CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD    = 4;
+
+    static final int ICC_CARD_TYPE_UNKNOWN = 0;
+    static final int ICC_CARD_TYPE_SIM     = 1;
+    static final int ICC_CARD_TYPE_USIM    = 2;
+
+    //switch modem cause type
+    static final int CAUSE_TYPE_PLMN_CHANGE = 0;
+    static final int CAUSE_TYPE_OOS   = 1;
+    static final int CAUSE_TYPE_OTHERS   = 255; //default value, EM, SIM switch,CU/CT card etc
+
+    //C2K world phone
+    static final int RADIO_TECH_MODE_FOR_WP_UNKNOWN = 0;
+    static final int RADIO_TECH_MODE_FOR_WP_CSFB  = 1;
+    static final int RADIO_TECH_MODE_FOR_WP_SVLTE = 2;
+
+    static final String NO_OP = "OM";
+    static final String ACTION_SHUTDOWN_IPO = "android.intent.action.ACTION_SHUTDOWN_IPO";
+    static final String ACTION_ADB_SWITCH_MODEM = "android.intent.action.ACTION_ADB_SWITCH_MODEM";
+    static final String PROPERTY_SWITCH_MODEM_CAUSE_TYPE = "ril.switch.modem.cause.type";
+
+    //[ALPS02302039]
+    static final String ACTION_SAP_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.sap.profile.action.CONNECTION_STATE_CHANGED";
+
+    //For Test
+    static final String ACTION_TEST_WORLDPHONE = "android.intent.action.ACTION_TEST_WORLDPHOE";
+    static final String EXTRA_FAKE_USER_TYPE = "FAKE_USER_TYPE";
+    static final String EXTRA_FAKE_REGION = "EXTRA_FAKE_REGION";
+
+    public void setModemSelectionMode(int mode, int modemType);
+    public void notifyRadioCapabilityChange(int capailitySimId);
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
new file mode 100644
index 0000000..f9708ea
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
@@ -0,0 +1,325 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+
+public class WorldMode extends Handler{
+    private static final String LOG_TAG = "PHONE";
+
+    public static final int MD_WORLD_MODE_UNKNOWN = 0;
+    public static final int MD_WORLD_MODE_LTG     = 8;   //uLTG
+    public static final int MD_WORLD_MODE_LWG     = 9;   //uLWG
+    public static final int MD_WORLD_MODE_LWTG    = 10;  //uLWTG
+    public static final int MD_WORLD_MODE_LWCG    = 11;  //uLWCG
+    public static final int MD_WORLD_MODE_LWCTG   = 12;  //uLWTCG(Auto mode)
+    public static final int MD_WORLD_MODE_LTTG    = 13;  //LtTG
+    public static final int MD_WORLD_MODE_LFWG    = 14;  //LfWG
+
+    public static final int MD_WM_CHANGED_UNKNOWN = -1;
+    public static final int MD_WM_CHANGED_START   = 0;
+    public static final int MD_WM_CHANGED_END     = 1;
+
+    static final int EVENT_RADIO_ON_1 = 1;
+    static final int EVENT_RADIO_ON_2 = 2;
+
+    static final String ACTION_ADB_SWITCH_WORLD_MODE =
+               "android.intent.action.ACTION_ADB_SWITCH_WORLD_MODE";
+    static final String EXTRA_WORLDMODE = "worldMode";
+
+    /** The singleton instance. */
+    private static WorldMode sInstance;
+
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+    private static int sCurrentWorldMode = updateCurrentWorldMode();
+    private static int sActiveWorldMode = MD_WORLD_MODE_UNKNOWN;
+    private static boolean sSwitchingState = false;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static Context sContext = null;
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    public WorldMode() {
+        logd("Constructor invoked");
+        logd("Init world mode: " + sCurrentWorldMode);
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+            sCi[i].registerForOn(this, EVENT_RADIO_ON_1 + i, null);
+        }
+
+        IntentFilter intentFilter = new IntentFilter(TelephonyIntents.ACTION_WORLD_MODE_CHANGED);
+        intentFilter.addAction(ACTION_ADB_SWITCH_WORLD_MODE);
+
+        if (PhoneFactory.getDefaultPhone() != null) {
+            sContext = PhoneFactory.getDefaultPhone().getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+        sContext.registerReceiver(mWorldModeReceiver, intentFilter);
+    }
+
+    /**
+     * Initialize the singleton WorldMode instance.
+     * This is only done once, at startup, from PhoneFactory.makeDefaultPhone().
+     */
+    public static void init() {
+        synchronized (WorldMode.class) {
+            if (sInstance == null) {
+                sInstance = new WorldMode();
+            } else {
+                logd("init() called multiple times!  sInstance = " + sInstance);
+            }
+        }
+    }
+
+    private final BroadcastReceiver mWorldModeReceiver = new  BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            logd("[Receiver]+");
+            String action = intent.getAction();
+            logd("Action: " + action);
+            int wmState = MD_WM_CHANGED_UNKNOWN;
+
+            if (TelephonyIntents.ACTION_WORLD_MODE_CHANGED.equals(action)) {
+                wmState = intent.getIntExtra(
+                        TelephonyIntents.EXTRA_WORLD_MODE_CHANGE_STATE, MD_WM_CHANGED_UNKNOWN);
+                logd("wmState: " + wmState);
+                if (wmState == MD_WM_CHANGED_END) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+            } else if (ACTION_ADB_SWITCH_WORLD_MODE.equals(action)){
+                int toMode = intent.getIntExtra(
+                        EXTRA_WORLDMODE, MD_WORLD_MODE_UNKNOWN);
+                logd("toModem: " + toMode);
+                if (toMode == MD_WORLD_MODE_LTG
+                        || toMode == MD_WORLD_MODE_LWG
+                        || toMode == MD_WORLD_MODE_LWTG
+                        || toMode == MD_WORLD_MODE_LTTG) {
+                    setWorldMode(toMode);
+                }
+            }
+            logd("[Receiver]-");
+        }
+    };
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar = (AsyncResult) msg.obj;
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        switch (msg.what) {
+            case EVENT_RADIO_ON_1:
+                logd("handleMessage : <EVENT_RADIO_ON_1>");
+                protocolSim = WorldPhoneUtil.getMajorSim();
+                if (protocolSim == PhoneConstants.SIM_ID_1) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+                break;
+            case EVENT_RADIO_ON_2:
+                logd("handleMessage : <EVENT_RADIO_ON_2>");
+                protocolSim = WorldPhoneUtil.getMajorSim();
+                if (protocolSim == PhoneConstants.SIM_ID_2) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+                break;
+            default:
+                logd("Unknown msg:" + msg.what);
+        }
+    }
+
+    /**
+     * Trigger RILD to switch world mode
+     * @param worldMode 0 : world mode is unknown
+     *                  8 : uTLG (MD_WORLD_MODE_LTG)
+     *                  9 : uLWG (MD_WORLD_MODE_LWG)
+     *                  10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *                  11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *                  12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *                  13 : LtTG (MD_WORLD_MODE_LTTG)
+     *                  14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    public static void setWorldMode(int worldMode) {
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        logd("[setWorldMode]protocolSim: " + protocolSim);
+        if (protocolSim >= PhoneConstants.SIM_ID_1 &&
+                protocolSim <= PhoneConstants.SIM_ID_4) {
+            setWorldMode(sCi[protocolSim], worldMode);
+        } else {
+            setWorldMode(sCi[PhoneConstants.SIM_ID_1], worldMode);
+        }
+    }
+
+    /**
+     * Trigger RILD to switch world mode with desinated RIL instance
+     * @param worldMode 0 : world mode is unknown
+     *                  8 : uTLG (MD_WORLD_MODE_LTG)
+     *                  9 : uLWG (MD_WORLD_MODE_LWG)
+     *                  10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *                  11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *                  12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *                  13 : LtTG (MD_WORLD_MODE_LTTG)
+     *                  14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    private static void setWorldMode(CommandsInterface ci, int worldMode) {
+        logd("[setWorldMode] worldMode=" + worldMode);
+        if (worldMode == sCurrentWorldMode) {
+            if (worldMode == MD_WORLD_MODE_LTG) {
+                logd("Already in uTLG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWG) {
+                logd("Already in uLWG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWTG) {
+                logd("Already in uLWTG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWCG) {
+                logd("Already in uLWCG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWCTG) {
+                logd("Already in uLWTCG mode");
+            } else if (worldMode == MD_WORLD_MODE_LTTG) {
+                logd("Already in LtTG mode");
+            } else if (worldMode == MD_WORLD_MODE_LFWG) {
+                logd("Already in LfWG mode");
+            }
+            return;
+        }
+        if (ci.getRadioState() ==
+                CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not switch world mode");
+            return;
+        }
+        if ((worldMode >= MD_WORLD_MODE_LTG) &&
+                (worldMode <= MD_WORLD_MODE_LFWG)){
+            ci.reloadModemType(worldMode, null);
+            ci.storeModemType(worldMode, null);
+            ci.setTrm(2, null);
+        } else {
+            logd("Invalid world mode:" + worldMode);
+            return;
+        }
+    }
+
+    /**
+     * Returns modem world mode
+     *
+     * @return 0 : world mode is unknown
+     *         8 : uTLG (MD_WORLD_MODE_LTG)
+     *         9 : uLWG (MD_WORLD_MODE_LWG)
+     *         10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *         11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *         12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *         13 : LtTG (MD_WORLD_MODE_LTTG)
+     *         14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    public static int getWorldMode() {
+        logd("getWorldMode=" + WorldModeToString(sCurrentWorldMode));
+        return sCurrentWorldMode;
+    }
+
+    /**
+     * Returns modem world mode
+     *
+     * @return 0 : world mode is unknown
+     *         8 : uTLG (MD_WORLD_MODE_LTG)
+     *         9 : uLWG (MD_WORLD_MODE_LWG)
+     *         10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *         11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *         12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *         13 : LtTG (MD_WORLD_MODE_LTTG)
+     *         14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    private static int updateCurrentWorldMode() {
+        sCurrentWorldMode = Integer.valueOf(
+                SystemProperties.get(TelephonyProperties.PROPERTY_ACTIVE_MD,
+                Integer.toString(MD_WORLD_MODE_UNKNOWN)));
+        logd("updateCurrentWorldMode=" + WorldModeToString(sCurrentWorldMode));
+        return sCurrentWorldMode;
+    }
+
+    public static void updateSwitchingState(boolean isSwitching){
+        sSwitchingState = isSwitching;
+        logd("updateSwitchingState=" + sSwitchingState);
+    }
+
+    public static boolean isWorldModeSwitching(){
+        if (sSwitchingState){
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public static String WorldModeToString(int worldMode) {
+        String worldModeString;
+        if (worldMode == MD_WORLD_MODE_LTG) {
+            worldModeString = "uTLG";
+        } else if (worldMode == MD_WORLD_MODE_LWG) {
+            worldModeString = "uLWG";
+        } else if (worldMode == MD_WORLD_MODE_LWTG) {
+            worldModeString = "uLWTG";
+        } else if (worldMode == MD_WORLD_MODE_LWCG) {
+            worldModeString = "uLWCG";
+        } else if (worldMode == MD_WORLD_MODE_LWCTG) {
+            worldModeString = "uLWTCG";
+        } else if (worldMode == MD_WORLD_MODE_LTTG) {
+            worldModeString = "LtTG";
+        } else if (worldMode == MD_WORLD_MODE_LFWG) {
+            worldModeString = "LfWG";
+        } else {
+            worldModeString = "Invalid world mode";
+        }
+
+        return worldModeString;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WorldMode]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
new file mode 100755
index 0000000..747a4c9
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
@@ -0,0 +1,1665 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.bluetooth.BluetoothProfile;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.telephony.Rlog;
+
+import java.util.ArrayList;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.UiccController;
+
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+import com.mediatek.internal.telephony.ModemSwitchHandler;
+
+/**
+ *@hide
+ */
+public class WorldPhoneOm extends Handler implements IWorldPhone {
+    private static Object sLock = new Object();
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+    private static final int[] FDD_STANDBY_TIMER = {
+        60
+    };
+    private static final int[] TDD_STANDBY_TIMER = {
+        40
+    };
+    private static final String[] PLMN_TABLE_TYPE1 = {
+        "46000", "46002", "46007", "46008",
+    };
+    private static final String[] PLMN_TABLE_TYPE1_EXT = {
+    };
+    private static final String[] PLMN_TABLE_TYPE3 = {
+        "46001", "46006", "46009", "45407",
+        "46003", "46005", "45502", "46011"
+    };
+    private static final String[] MCC_TABLE_DOMESTIC = {
+        "460"
+    };
+
+    private static ArrayList<String> sPlmnType1;
+    private static ArrayList<String> sPlmnType1Ext;
+    private static ArrayList<String> sPlmnType3;
+    private static ArrayList<String> sMccDomestic;
+
+    private static Context sContext = null;
+    private static Phone sDefultPhone = null;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+    private static String sOperatorSpec;
+    private static String sPlmnSs;
+    private static String sLastPlmn;
+    private static String[] sImsi = new String[PROJECT_SIM_NUM];
+    private static String[] sNwPlmnStrings;
+    private static int sVoiceRegState;
+    private static int sDataRegState;
+    private static int sRilVoiceRegState;
+    private static int sRilDataRegState;
+    private static int sRilVoiceRadioTechnology;
+    private static int sRilDataRadioTechnology;
+    private static int sUserType;
+    private static int sRegion;
+    private static int sDenyReason;
+    private static int sMajorSim;
+    private static int sDefaultBootUpModem = ModemSwitchHandler.MD_TYPE_UNKNOWN;
+    private static int[] sSuspendId = new int[PROJECT_SIM_NUM];
+    private static int[] sIccCardType = new int[PROJECT_SIM_NUM];
+    private static boolean sVoiceCapable;
+    private static boolean[] sIsInvalidSim = new boolean[PROJECT_SIM_NUM];
+    private static boolean[] sSuspendWaitImsi = new boolean[PROJECT_SIM_NUM];
+    private static boolean[] sFirstSelect = new boolean[PROJECT_SIM_NUM];
+    private static UiccController sUiccController = null;
+    private static IccRecords[] sIccRecordsInstance = new IccRecords[PROJECT_SIM_NUM];
+    private static ServiceState sServiceState;
+    private static ModemSwitchHandler sModemSwitchHandler = null;
+    private static int sTddStandByCounter;
+    private static int sFddStandByCounter;
+    private static boolean sWaitInTdd;
+    private static boolean sWaitInFdd;
+    private static boolean sIsAutoSelectEnable;  //[ALPS01881475]
+    private static boolean sIsResumeCampingFail; //[ALPS01974750]
+    private static int sBtSapState; //[ALPS02302039]
+
+    //C2K world phone
+    private static int sRadioTechModeForWp;
+    private static Phone[] sSvlteLtePhone = new Phone[PROJECT_SIM_NUM];
+    private static CommandsInterface[] sSvlteLteCi = new CommandsInterface[PROJECT_SIM_NUM];
+    private static boolean[] sSuspendWaitRadioTech = new boolean[PROJECT_SIM_NUM];
+
+
+    public WorldPhoneOm() {
+        logd("Constructor invoked");
+        sOperatorSpec = SystemProperties.get("ro.operator.optr", NO_OP);
+        logd("Operator Spec:" + sOperatorSpec);
+        sDefultPhone = PhoneFactory.getDefaultPhone();
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            //C2K world phone - start
+            sSvlteLtePhone[i] = null;
+            sSvlteLteCi[i] = null;
+            // MTK TODO
+            /*
+            if (WorldPhoneUtil.isCdmaLteDcSupport() &&
+                    sProxyPhones[i] instanceof SvltePhoneProxy) {
+                logd("Phone " + i + " is SVLTE case so get lte phone directly");
+                sSvlteLtePhone[i] = ((SvltePhoneProxy) sProxyPhones[i]).getLtePhone();
+                sSvlteLteCi[i] = ((PhoneBase) sSvlteLtePhone[i]).mCi;
+            }
+            */
+            //C2K world phone - end
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+        }
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            //C2K world phone - start
+            // MTK TODO
+            /*
+            if (WorldPhoneUtil.isCdmaLteDcSupport() &&
+                    sProxyPhones[i] instanceof SvltePhoneProxy) {
+                sSvlteLteCi[i].setOnPlmnChangeNotification(
+                        this, EVENT_REG_PLMN_CHANGED_SVLTE_1 + i, null);
+                sSvlteLteCi[i].setOnRegistrationSuspended(
+                        this, EVENT_REG_SUSPENDED_SVLTE_1 + i, null);
+                sSvlteLteCi[i].registerForOn(
+                        this, EVENT_RADIO_ON_SVLTE_1 + i, null);
+                sSvlteLteCi[i].setInvalidSimInfo(
+                        this, EVENT_INVALID_SIM_NOTIFY_SVLTE_1 + i, null);
+            }
+            */
+            //C2K world phone - end
+            sCi[i].setOnPlmnChangeNotification(this, EVENT_REG_PLMN_CHANGED_1 + i, null);
+            sCi[i].setOnRegistrationSuspended(this, EVENT_REG_SUSPENDED_1 + i, null);
+            sCi[i].registerForOn(this, EVENT_RADIO_ON_1 + i, null);
+            sCi[i].setInvalidSimInfo(this, EVENT_INVALID_SIM_NOTIFY_1 + i, null);
+        }
+
+        //[ALPS02045100]
+        // MTK TODO
+        /*
+        if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+            sUiccController.getInstance().registerForC2KWPCardTypeReady(
+                    this, EVENT_WP_CARD_TYPE_READY, null);
+        }
+        */
+
+        sModemSwitchHandler = new ModemSwitchHandler();
+        logd(ModemSwitchHandler.modemToString(ModemSwitchHandler.getActiveModemType()));
+
+        IntentFilter intentFilter = new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        intentFilter.addAction(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
+        intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        intentFilter.addAction(ACTION_SHUTDOWN_IPO);
+        intentFilter.addAction(ACTION_ADB_SWITCH_MODEM);
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE);
+        //[ALPS02302039]
+        intentFilter.addAction(ACTION_SAP_CONNECTION_STATE_CHANGED);
+
+        //C2K world phone
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_RADIO_TECHNOLOGY_START);
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_RADIO_TECHNOLOGY_DONE);
+        intentFilter.addAction(ACTION_TEST_WORLDPHONE);
+
+        if (sDefultPhone != null) {
+            sContext = sDefultPhone.getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+        sVoiceCapable = sContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_voice_capable);
+        sContext.registerReceiver(mWorldPhoneReceiver, intentFilter);
+
+        sTddStandByCounter = 0;
+        sFddStandByCounter = 0;
+        sWaitInTdd = false;
+        sWaitInFdd = false;
+        sRegion = REGION_UNKNOWN;
+        sLastPlmn = null;
+        sBtSapState = 0; //[ALPS02302039]
+        resetAllProperties();
+
+        //For Test
+        sPlmnType1 = new ArrayList<String>();
+        sPlmnType1Ext = new ArrayList<String>();
+        sPlmnType3 = new ArrayList<String>();
+        sMccDomestic = new ArrayList<String>();
+        loadDefaultData();
+
+        if (WorldPhoneUtil.getModemSelectionMode() == SELECTION_MODE_MANUAL) {
+            logd("Auto select disable");
+            //sMajorSim = AUTO_SWITCH_OFF;    //[ALPS01881475]
+            sIsAutoSelectEnable = false;
+            // MTK TODO
+            /*
+            Settings.Global.putInt(sContext.getContentResolver(),
+                    Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_MANUAL);
+            */
+        } else {
+            logd("Auto select enable");
+            sIsAutoSelectEnable = true;    //[ALPS01881475]
+            // MTK TODO
+            /*
+            Settings.Global.putInt(sContext.getContentResolver(),
+                    Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_AUTO);
+            */
+        }
+        // MTK TODO
+        /*
+        FDD_STANDBY_TIMER[sFddStandByCounter] = Settings.Global.getInt(
+                sContext.getContentResolver(), Settings.Global.WORLD_PHONE_FDD_MODEM_TIMER,
+                FDD_STANDBY_TIMER[sFddStandByCounter]);
+        Settings.Global.putInt(sContext.getContentResolver(),
+                Settings.Global.WORLD_PHONE_FDD_MODEM_TIMER,
+                FDD_STANDBY_TIMER[sFddStandByCounter]);
+        */
+        logd("FDD_STANDBY_TIMER = " + FDD_STANDBY_TIMER[sFddStandByCounter] + "s");
+        logd("sDefaultBootUpModem = " + sDefaultBootUpModem);
+    }
+
+    private final BroadcastReceiver mWorldPhoneReceiver = new  BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            logd("[Receiver]+");
+            String action = intent.getAction();
+            logd("Action: " + action);
+            int slotId;
+            if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
+                String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                slotId = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                sMajorSim = WorldPhoneUtil.getMajorSim();
+                logd("slotId: " + slotId + " simStatus: " + simStatus + " sMajorSim:" + sMajorSim);
+                if (IccCardConstants.INTENT_VALUE_ICC_IMSI.equals(simStatus)) {
+                    sUiccController = UiccController.getInstance();
+                    if (sUiccController != null) {
+                        sIccRecordsInstance[slotId] = sProxyPhones[slotId].getIccCard()
+                                .getIccRecords();
+                    } else {
+                        logd("Null sUiccController");
+                        return;
+                    }
+                    if (sIccRecordsInstance[slotId] != null) {
+                        sImsi[slotId] = sIccRecordsInstance[slotId].getIMSI();
+                    } else {
+                        logd("Null sIccRecordsInstance");
+                        return;
+                    }
+                    sIccCardType[slotId] = getIccCardType(slotId);
+                    logd("sImsi[" + slotId + "]:" + sImsi[slotId]);
+                    //[ALPS01881475]
+                    //if (slotId == sMajorSim) {
+                    if ((sIsAutoSelectEnable) && (slotId == sMajorSim)) {
+                        logd("Major SIM");
+                        sUserType = getUserType(sImsi[slotId]);
+                        if (sFirstSelect[slotId]) {
+                            sFirstSelect[slotId] = false;
+                            if (sUserType == TYPE1_USER) {
+                                if (sRegion == REGION_DOMESTIC) {
+                                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                                } else if (sRegion == REGION_FOREIGN) {
+                                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                                } else {
+                                    logd("Region unknown");
+                                }
+                            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                            }
+                        }
+                        if (sSuspendWaitImsi[slotId]) {
+                            sSuspendWaitImsi[slotId] = false;
+                            if (sNwPlmnStrings != null) {
+                                logd("IMSI fot slot" + slotId + " now ready, resuming PLMN:"
+                                        + sNwPlmnStrings[0] + " with ID:" + sSuspendId[slotId]);
+                                resumeCampingProcedure(slotId);
+                            } else {
+                                logd("sNwPlmnStrings is Null");
+                            }
+                        }
+                    } else {
+                        logd("Not major SIM or in maual selection mode");
+                        getUserType(sImsi[slotId]);
+                        if (sSuspendWaitImsi[slotId]) {
+                            sSuspendWaitImsi[slotId] = false;
+                            logd("IMSI fot slot" + slotId + " now ready, resuming with ID:"
+                                    + sSuspendId[slotId]);
+                            sCi[slotId].setResumeRegistration(sSuspendId[slotId], null);
+                        }
+                    }
+                } else if (simStatus.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT)) {
+                    sLastPlmn = null;
+                    sImsi[slotId] = "";
+                    sFirstSelect[slotId] = true;
+                    //[ALPS02083291]-reset whan sim ready
+                    //sIsInvalidSim[slotId] = false;
+                    sSuspendWaitImsi[slotId] = false;
+                    sIccCardType[slotId] = ICC_CARD_TYPE_UNKNOWN;
+                    if (slotId == sMajorSim) {
+                        logd("Major SIM removed, no world phone service");
+                        removeModemStandByTimer();
+                        sUserType = UNKNOWN_USER;
+                        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+                        sMajorSim = MAJOR_SIM_UNKNOWN;
+                    } else {
+                        logd("SIM" + slotId + " is not major SIM");
+                    }
+                //[ALPS02083291]-Start: reset whan sim ready
+                } else if (simStatus.equals(IccCardConstants.INTENT_VALUE_ICC_READY)) {
+                    logd("reset sIsInvalidSim by solt:" + slotId);
+                    sIsInvalidSim[slotId] = false;
+                }
+            } else if (action.equals(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED)) {
+                if (intent.getExtras() != null) {
+                    sServiceState = ServiceState.newFromBundle(intent.getExtras());
+                    if (sServiceState != null) {
+                        slotId = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                        sPlmnSs = sServiceState.getOperatorNumeric();
+                        sVoiceRegState = sServiceState.getVoiceRegState();
+                        sRilVoiceRegState = sServiceState.getRilVoiceRegState();
+                        sRilVoiceRadioTechnology = sServiceState.getRilVoiceRadioTechnology();
+                        sDataRegState = sServiceState.getDataRegState();
+                        sRilDataRegState = sServiceState.getRilDataRegState();
+                        sRilDataRadioTechnology = sServiceState.getRilDataRadioTechnology();
+                        logd("slotId: " + slotId + ", " + WorldPhoneUtil.iccCardTypeToString(sIccCardType[slotId]));
+                        logd("sMajorSim: " + sMajorSim);
+                        logd(ModemSwitchHandler.modemToString(ModemSwitchHandler.getActiveModemType()));
+                        logd("sPlmnSs: " + sPlmnSs);
+                        logd("sVoiceRegState: " + WorldPhoneUtil.stateToString(sVoiceRegState));
+                        logd("sRilVoiceRegState: " + WorldPhoneUtil.regStateToString(sRilVoiceRegState));
+                        logd("sRilVoiceRadioTech: " + sServiceState.rilRadioTechnologyToString(sRilVoiceRadioTechnology));
+                        logd("sDataRegState: " + WorldPhoneUtil.stateToString(sDataRegState));
+                        logd("sRilDataRegState: " + WorldPhoneUtil.regStateToString(sRilDataRegState));
+                        logd("sRilDataRadioTech: " + sServiceState.rilRadioTechnologyToString(sRilDataRadioTechnology));
+                        logd("sIsAutoSelectEnable: " + sIsAutoSelectEnable); //[ALPS01881475]
+                        logd("sRadioTechModeForWp: " + sRadioTechModeForWp); //C2K world phone
+                        //[ALPS01881475]
+                        //if (slotId == sMajorSim) {
+                        //if ((sIsAutoSelectEnable) && (slotId == sMajorSim)) {
+                        if (slotId == sMajorSim) {
+                            if (sIsAutoSelectEnable) {
+                                if (isNoService()) {
+                                    handleNoService();
+                                } else if (isInService()) {
+                                    sLastPlmn = sPlmnSs;
+                                    removeModemStandByTimer();
+                                    logd("reset sIsInvalidSim");
+                                    sIsInvalidSim[slotId] = false;
+                                }
+                            } else {
+                                if (isInService()) {
+                                    logd("reset sIsInvalidSim in manual mode");
+                                    sLastPlmn = sPlmnSs;
+                                    sIsInvalidSim[slotId] = false;
+                                }
+                            }
+                        }
+                    } else {
+                        logd("Null sServiceState");
+                    }
+                }
+            } else if (action.equals(ACTION_SHUTDOWN_IPO)) {
+                //C2K world phone - start
+                CommandsInterface ci = null;
+                if (!WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    ci = sCi[PhoneConstants.SIM_ID_1];
+                } else {
+                    ci = getSvlteActiveCi(PhoneConstants.SIM_ID_1);
+                }
+                if (ci == null) {
+                    logd("SHUTDOWN_IPO getActiveCi fail, switch not executed!");
+                    return;
+                }
+                //C2K world phone - end
+
+                if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                    if (WorldPhoneUtil.isLteSupport()) {
+                        ModemSwitchHandler.reloadModem(ci, ModemSwitchHandler.MD_TYPE_LWG);
+                        //ModemSwitchHandler.reloadModem(
+                        //        sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_LWG);
+                        logd("Reload to FDD CSFB modem");
+                    } else {
+                        ModemSwitchHandler.reloadModem(ci, ModemSwitchHandler.MD_TYPE_WG);
+                        //ModemSwitchHandler.reloadModem(
+                        //        sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_WG);
+                        logd("Reload to WG modem");
+                    }
+                } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                    if (WorldPhoneUtil.isLteSupport()) {
+                        ModemSwitchHandler.reloadModem(ci, ModemSwitchHandler.MD_TYPE_LTG);
+                        //ModemSwitchHandler.reloadModem(
+                        //         sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_LTG);
+                        logd("Reload to TDD CSFB modem");
+                    } else {
+                        ModemSwitchHandler.reloadModem(ci, ModemSwitchHandler.MD_TYPE_TG);
+                        //ModemSwitchHandler.reloadModem(
+                        //         sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_TG);
+                        logd("Reload to TG modem");
+                    }
+                }
+            } else if (action.equals(ACTION_ADB_SWITCH_MODEM)) {
+                int toModem = intent.getIntExtra(
+                        TelephonyIntents.EXTRA_MD_TYPE, ModemSwitchHandler.MD_TYPE_UNKNOWN);
+                logd("toModem: " + toModem);
+                if (toModem == ModemSwitchHandler.MD_TYPE_WG
+                        || toModem == ModemSwitchHandler.MD_TYPE_TG
+                        || toModem == ModemSwitchHandler.MD_TYPE_LWG
+                        || toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                    setModemSelectionMode(IWorldPhone.SELECTION_MODE_MANUAL, toModem);
+                } else {
+                    setModemSelectionMode(IWorldPhone.SELECTION_MODE_AUTO, toModem);
+                }
+            } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                if (intent.getBooleanExtra("state", false) == false) {
+                    logd("Leave flight mode");
+                    sLastPlmn = null;
+                    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                        sIsInvalidSim[i] = false;
+                    }
+                } else {
+                    logd("Enter flight mode");
+                    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                        sFirstSelect[i] = true;
+                    }
+                }
+            } else if (action.equals(TelephonyIntents.ACTION_SET_RADIO_CAPABILITY_DONE)) {
+                //if (sMajorSim != AUTO_SWITCH_OFF) {  //[ALPS01881475]
+                    sMajorSim = WorldPhoneUtil.getMajorSim();
+                //}
+                handleSimSwitched();
+            } else if (action.equals(TelephonyIntents.ACTION_SET_RADIO_TECHNOLOGY_START)) {
+                if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_UNKNOWN;
+                } else {
+                    sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_CSFB;
+                }
+            } else if (action.equals(TelephonyIntents.ACTION_SET_RADIO_TECHNOLOGY_DONE)) {
+                // MTK TODO
+                /*
+                if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    int majorySim = WorldPhoneUtil.getMajorSim();
+                    int svlteModeSlot = SvlteModeController.getActiveSvlteModeSlotId();
+                    logd("majorySim=" + majorySim + " svlteModeSlot=" + svlteModeSlot);
+                    if (majorySim != MAJOR_SIM_UNKNOWN) {
+                        if (svlteModeSlot == majorySim) {
+                            sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_SVLTE;
+                        } else {
+                            sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_CSFB;
+                        }
+                    } else {
+                        sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_SVLTE;
+                    }
+                    //[ALPS02105582]
+                    handleSimSwitched();
+                } else {
+                */
+                    sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_CSFB;
+                // }
+            } else if (action.equals(ACTION_TEST_WORLDPHONE)) {
+                int fakeUserType = intent.getIntExtra(EXTRA_FAKE_USER_TYPE, UNKNOWN_USER);
+                int fakeRegion = intent.getIntExtra(EXTRA_FAKE_REGION, REGION_UNKNOWN);
+                boolean hasChanged = false;
+
+                if ((fakeUserType == UNKNOWN_USER) && (fakeRegion == REGION_UNKNOWN)) {
+                    logd("Leave ADB Test mode");
+                    //reset default data
+                    sPlmnType1.clear();
+                    sPlmnType1Ext.clear();
+                    sPlmnType3.clear();
+                    sMccDomestic.clear();
+                    loadDefaultData();
+                } else {
+                    sMajorSim = WorldPhoneUtil.getMajorSim();
+                    if (sMajorSim != MAJOR_SIM_UNKNOWN
+                            && sMajorSim != MAJOR_CAPABILITY_OFF) {
+
+                        String imsi =  sImsi[sMajorSim];
+                        if (imsi != null && !imsi.equals("")) {
+                            imsi = imsi.substring(0, 5);
+                            switch (fakeUserType) {
+                                case TYPE1_USER:
+                                    sPlmnType1.add(imsi);
+                                    hasChanged = true;
+                                    break;
+
+                                case TYPE3_USER:
+                                    sPlmnType3.add(imsi);
+                                    hasChanged = true;
+                                    break;
+
+                                default:
+                                    logd("Unknown fakeUserType:" + fakeUserType);
+                            }
+                        } else {
+                            logd("Imsi of sMajorSim is unknown");
+                        }
+
+                        String currentMcc = sNwPlmnStrings[0];
+                        if (currentMcc == null || currentMcc.equals("") ||
+                                currentMcc.length() < 5) {
+                            logd("Invalid sNwPlmnStrings");
+                        } else {
+                            currentMcc = currentMcc.substring(0, 3);
+                            if (fakeRegion == REGION_DOMESTIC) {
+                                sMccDomestic.add(currentMcc);
+                                hasChanged = true;
+                            } else if (fakeRegion == REGION_FOREIGN) {
+                                sMccDomestic.remove(currentMcc);
+                                hasChanged = true;
+                            } else {
+                                logd("Unknown fakeRegion:" + fakeRegion);
+                            }
+                        }
+                    } else {
+                        logd("sMajorSim is Unknown or Capability OFF");
+                    }
+
+                    if (hasChanged) {
+                        logd("sPlmnType1:" + sPlmnType1);
+                        logd("sPlmnType1Ext:" + sPlmnType1Ext);
+                        logd("sPlmnType3:" + sPlmnType3);
+                        logd("sMccDomestic:" + sMccDomestic);
+                        handleRadioTechModeSwitch();
+                    }
+                }
+            //[ALPS02302039]
+            } else if (action.equals(ACTION_SAP_CONNECTION_STATE_CHANGED)) {
+                int sapState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, 0);
+                if (sapState == BluetoothProfile.STATE_CONNECTED){
+                    logd("BT_SAP connection state is CONNECTED");
+                    sBtSapState = 1;
+                } else if (sapState == BluetoothProfile.STATE_DISCONNECTED){
+                    logd("BT_SAP connection state is DISCONNECTED");
+                    sBtSapState = 0;
+                } else {
+                    logd("BT_SAP connection state is "+sapState);
+                }
+            }
+            logd("[Receiver]-");
+        }
+    };
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar = (AsyncResult) msg.obj;
+        switch (msg.what) {
+            case EVENT_RADIO_ON_1:
+                logd("handleMessage : <EVENT_RADIO_ON_1>");
+                handleRadioOn(PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_PLMN_CHANGED_1:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED_1>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_SUSPENDED_1:
+                logd("handleMessage : <EVENT_REG_SUSPENDED_1>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_RADIO_ON_2:
+                logd("handleMessage : <EVENT_RADIO_ON_2>");
+                handleRadioOn(PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_PLMN_CHANGED_2:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED_2>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_SUSPENDED_2:
+                logd("handleMessage : <EVENT_REG_SUSPENDED_2>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_1:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY_1>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_1, ar);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_2:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY_2>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_2, ar);
+                break;
+
+            //C2K world phone - start
+            case EVENT_RADIO_ON_SVLTE_1:
+                logd("handleMessage : <EVENT_RADIO_ON_SVLTE_L_1>");
+                handleRadioOn(PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_PLMN_CHANGED_SVLTE_1:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED_SVLTE_L_1>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_SUSPENDED_SVLTE_1:
+                logd("handleMessage : <EVENT_REG_SUSPENDED_SVLTE_L_1>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_RADIO_ON_SVLTE_2:
+                logd("handleMessage : <EVENT_RADIO_ON_SVLTE_L_2>");
+                handleRadioOn(PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_PLMN_CHANGED_SVLTE_2:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED_SVLTE_L_2>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_SUSPENDED_SVLTE_2:
+                logd("handleMessage : <EVENT_REG_SUSPENDED_SVLTE_L_2>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_SVLTE_1:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY_SVLTE_L_1>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_1, ar);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_SVLTE_2:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY_SVLTE_L_2>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_2, ar);
+                break;
+            //[ALPS02045100]-start
+            case EVENT_WP_CARD_TYPE_READY:
+                //handleWpCardTypeReady();
+                break;
+            //[ALPS02045100]-end
+
+            //[ALPS02156732]-start
+            case EVENT_WP_GMSS_RAT_CHANGED_1:
+                logd("handleMessage : <EVENT_WP_GMSS_RAT_CHANGED_1>");
+                handleGmssRatChange(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_WP_GMSS_RAT_CHANGED_2:
+                logd("handleMessage : <EVENT_WP_GMSS_RAT_CHANGED_2>");
+                handleGmssRatChange(ar, PhoneConstants.SIM_ID_2);
+                break;
+            //[ALPS02156732]-end
+            //C2K world phone - end
+
+            //[ALPS01974750]-start
+            case EVENT_RESUME_CAMPING:
+                if (ar.exception != null) {
+                    logd("handleMessage : <EVENT_RESUME_CAMPING> with exception");
+                    sIsResumeCampingFail = true;
+                }
+                break;
+            //[ALPS01974750]-end
+            default:
+                logd("Unknown msg:" + msg.what);
+        }
+    }
+
+    private void handleRadioOn(int slotId) {
+        sMajorSim = WorldPhoneUtil.getMajorSim();
+        logd("handleRadioOn Slot:" + slotId + " sMajorSim:" + sMajorSim);
+        sIsInvalidSim[slotId] = false;
+        //[ALPS01974750]-start
+        if (sIsResumeCampingFail) {
+            logd("try to resume camping again");
+            //C2K world phone - start
+            if (!WorldPhoneUtil.isCdmaLteDcSupport()) {
+                sCi[slotId].setResumeRegistration(sSuspendId[slotId], null);
+            } else {
+                CommandsInterface ci = getSvlteActiveCi(slotId);
+                if (ci != null) {
+                    ci.setResumeRegistration(sSuspendId[slotId], null);
+                }
+            }
+            sIsResumeCampingFail = false;
+        }
+        //[ALPS01974750]-end
+    }
+
+    private void handlePlmnChange(AsyncResult ar, int slotId) {
+        sMajorSim = WorldPhoneUtil.getMajorSim();
+        logd("Slot:" + slotId + " sMajorSim:" + sMajorSim);
+
+        if (ar.exception == null && ar.result != null) {
+            String[] plmnString = (String[]) ar.result;
+            if (slotId == sMajorSim) {
+                sNwPlmnStrings = plmnString;
+            }
+            for (int i = 0; i < plmnString.length; i++) {
+                logd("plmnString[" + i + "]=" + plmnString[i]);
+            }
+            //[ALPS01881475]
+            if (sIsAutoSelectEnable) {
+                if (sMajorSim == slotId && sUserType == TYPE1_USER
+                        && sDenyReason != CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD) {
+                    searchForDesignateService(plmnString[0]);
+                }
+                //To speed up performance in foreign countries,once get PLMN(no matter which slot)
+                //determine region right away and switch modem type if needed
+                sRegion = getRegion(plmnString[0]);
+
+                //[ALPS01881475]
+                //if (sUserType != TYPE3_USER && sRegion == REGION_FOREIGN
+                //        && sMajorSim != AUTO_SWITCH_OFF && sMajorSim != MAJOR_CAPABILITY_OFF) {
+                if (sUserType != TYPE3_USER && sRegion == REGION_FOREIGN
+                        && sMajorSim != MAJOR_CAPABILITY_OFF) {
+
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                }
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    //[ALPS02156732]
+    private void handleGmssRatChange(AsyncResult ar, int slotId) {
+        int[] info = null;
+        String mccString = null;
+
+        sMajorSim = WorldPhoneUtil.getMajorSim();
+        logd("Slot:" + slotId + " sMajorSim:" + sMajorSim);
+
+        if (ar.exception == null && ar.result != null) {
+            info = (int[]) ar.result;
+            mccString = Integer.toString(info[1]);
+            logd("[handleGmssRatChange] mccString=" + mccString);
+            if ((slotId == sMajorSim) &&(mccString.length() >= 3)) {
+                if (sNwPlmnStrings == null){
+                    sNwPlmnStrings = new String[1];
+                }
+                sNwPlmnStrings[0] = mccString;
+            }
+            if (sIsAutoSelectEnable){
+                sRegion = getRegion(mccString);
+                if (sUserType != TYPE3_USER && sRegion == REGION_FOREIGN
+                        && sMajorSim != MAJOR_CAPABILITY_OFF) {
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                }
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleRegistrationSuspend(AsyncResult ar, int slotId) {
+        logd("Slot" + slotId);
+        if (ar.exception == null && ar.result != null) {
+            sSuspendId[slotId] = ((int[]) ar.result)[0];
+            logd("Suspending with Id=" + sSuspendId[slotId]);
+            //[ALPS01881475]
+            //if (sMajorSim == slotId) {
+            if ((sIsAutoSelectEnable) && (sMajorSim == slotId)) {
+                //C2K - start
+                if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    resumeCampingProcedure(slotId);
+                } else {
+                //C2K - end
+                    if (sUserType != UNKNOWN_USER) {
+                        resumeCampingProcedure(slotId);
+                    } else {
+                        sSuspendWaitImsi[slotId] = true;
+                        logd("User type unknown, wait for IMSI");
+                    }
+                }
+            } else {
+                logd("Not major slot or in maual selection mode, camp on OK");
+                //C2K world phone - start
+                if (!WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    sCi[slotId].setResumeRegistration(sSuspendId[slotId], null);
+                } else {
+                    CommandsInterface ci = getSvlteActiveCi(slotId);
+                    if (ci != null) {
+                        ci.setResumeRegistration(sSuspendId[slotId], null);
+                    }
+                }
+                //C2K world phone - end
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleInvalidSimNotify(int slotId, AsyncResult ar) {
+        logd("Slot" + slotId);
+        if (ar.exception == null && ar.result != null) {
+            String[] invalidSimInfo = (String[]) ar.result;
+            String plmn = invalidSimInfo[0];
+            int cs_invalid = Integer.parseInt(invalidSimInfo[1]);
+            int ps_invalid = Integer.parseInt(invalidSimInfo[2]);
+            int cause = Integer.parseInt(invalidSimInfo[3]);
+            int testMode = -1;
+            testMode = SystemProperties.getInt("gsm.gcf.testmode", 0);
+            if (testMode != 0) {
+                logd("Invalid SIM notified during test mode: " + testMode);
+                return;
+            }
+            logd("testMode:" + testMode + ", cause: " + cause + ", cs_invalid: " + cs_invalid +
+                    ", ps_invalid: " + ps_invalid + ", plmn: " + plmn);
+            if (sVoiceCapable && cs_invalid == 1) {
+                if (sLastPlmn == null) {
+                    logd("CS reject, invalid SIM");
+                    sIsInvalidSim[slotId] = true;
+                    return;
+                }
+            }
+            if (ps_invalid == 1) {
+                if (sLastPlmn == null) {
+                    logd("PS reject, invalid SIM");
+                    sIsInvalidSim[slotId] = true;
+                    return;
+                }
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleSwitchModem(int toModem) {
+        int mMajorSim = WorldPhoneUtil.getMajorSim();
+
+        CommandsInterface ci = null;
+
+        //C2K world phone-START
+        if (sIsAutoSelectEnable && WorldPhoneUtil.isCdmaLteDcSupport()) {
+            if (!isNeedHandleSwitchForRadioTechMode()) {
+                logd("[handleSwitchModem]No need to handle, switch not executed!");
+                return;
+            }
+        }
+        //C2K world phone-END
+
+        if (mMajorSim >= 0 && sIsInvalidSim[mMajorSim]
+                && WorldPhoneUtil.getModemSelectionMode() == SELECTION_MODE_AUTO) {
+            logd("[handleSwitchModem] Invalid SIM, switch not executed!");
+            return;
+        }
+        if (toModem == ModemSwitchHandler.MD_TYPE_TDD) {
+            if (WorldPhoneUtil.isLteSupport()) {
+                toModem = ModemSwitchHandler.MD_TYPE_LTG;
+            } else {
+                toModem = ModemSwitchHandler.MD_TYPE_TG;
+            }
+        } else if (toModem == ModemSwitchHandler.MD_TYPE_FDD) {
+            if (WorldPhoneUtil.isLteSupport()) {
+                toModem = ModemSwitchHandler.MD_TYPE_LWG;
+            } else {
+                toModem = ModemSwitchHandler.MD_TYPE_WG;
+            }
+        }
+
+        //C2K world phone - start
+        ci = getSvlteActiveCi(PhoneConstants.SIM_ID_1);
+        if (ci == null) {
+            logd("[handleSwitchModem] get Ci fail, switch not executed!");
+            return;
+        }
+        //C2K world phone - end
+
+        //[ALPS01881475]
+        //if (sMajorSim == AUTO_SWITCH_OFF) {
+        if (!sIsAutoSelectEnable) {
+            logd("[handleSwitchModem] Auto select disable, storing modem type: " + toModem);
+            //C2K world phone
+            ci.storeModemType(toModem, null);
+            //sCi[PhoneConstants.SIM_ID_1].storeModemType(toModem, null);
+        } else {
+            if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_UNKNOWN) {
+                logd("[handleSwitchModem] Storing modem type: " + toModem);
+                //C2K world phone
+                ci.storeModemType(toModem, null);
+                //sCi[PhoneConstants.SIM_ID_1].storeModemType(toModem, null);
+            } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    logd("[handleSwitchModem] Storing modem type: " +
+                            ModemSwitchHandler.MD_TYPE_WG);
+                    //C2K world phone
+                    ci.storeModemType(ModemSwitchHandler.MD_TYPE_LWG, null);
+                    //sCi[PhoneConstants.SIM_ID_1].storeModemType(
+                    //       ModemSwitchHandler.MD_TYPE_LWG, null);
+                } else {
+                    logd("[handleSwitchModem] Storing modem type: " +
+                            ModemSwitchHandler.MD_TYPE_LWG);
+                    //C2K world phone
+                    ci.storeModemType(ModemSwitchHandler.MD_TYPE_WG, null);
+                    //sCi[PhoneConstants.SIM_ID_1].storeModemType(
+                    //        ModemSwitchHandler.MD_TYPE_WG, null);
+                }
+            } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    logd("[handleSwitchModem] Storing modem type: " +
+                            ModemSwitchHandler.MD_TYPE_WG);
+                    //C2K world phone
+                    ci.storeModemType(ModemSwitchHandler.MD_TYPE_LTG, null);
+                    //sCi[PhoneConstants.SIM_ID_1].storeModemType(
+                    //        ModemSwitchHandler.MD_TYPE_LTG, null);
+                } else {
+                    logd("[handleSwitchModem] Storing modem type: " +
+                            ModemSwitchHandler.MD_TYPE_LWG);
+                    //C2K world phone
+                    ci.storeModemType(ModemSwitchHandler.MD_TYPE_TG, null);
+                    //sCi[PhoneConstants.SIM_ID_1].storeModemType(
+                    //        ModemSwitchHandler.MD_TYPE_TG, null);
+                }
+            }
+        }
+        if (toModem == ModemSwitchHandler.getActiveModemType()) {
+            if (toModem == ModemSwitchHandler.MD_TYPE_WG) {
+                logd("Already in WG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_TG) {
+                logd("Already in TG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LWG) {
+                logd("Already in FDD CSFB modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                logd("Already in TDD CSFB modem");
+            }
+            return;
+        } else {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                if (sActivePhones[i].getState() != PhoneConstants.State.IDLE) {
+                    logd("Phone" + i + " is not idle, modem switch not allowed");
+                    return;
+                }
+            }
+            removeModemStandByTimer();
+            if (toModem == ModemSwitchHandler.MD_TYPE_WG) {
+                logd("Switching to WG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_TG) {
+                logd("Switching to TG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LWG) {
+                logd("Switching to FDD CSFB modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                logd("Switching to TDD CSFB modem");
+            }
+            ModemSwitchHandler.switchModem(toModem);
+            resetNetworkProperties();
+        }
+    }
+
+    private void handleSimSwitched() {
+        if (sMajorSim == MAJOR_CAPABILITY_OFF) {
+            logd("Major capability turned off");
+            removeModemStandByTimer();
+            sUserType = UNKNOWN_USER;
+        //[ALPS01881475]
+        //} else if (sMajorSim == AUTO_SWITCH_OFF) {
+        } else if (!sIsAutoSelectEnable) {
+            logd("Auto modem selection disabled");
+            removeModemStandByTimer();
+        } else if (sMajorSim == MAJOR_SIM_UNKNOWN) {
+            logd("Major SIM unknown");
+        } else {
+            logd("Auto modem selection enabled");
+            logd("Major capability in slot" + sMajorSim);
+            if (sImsi[sMajorSim] == null || sImsi[sMajorSim].equals("")) {
+                // may caused by receive 3g switched intent when boot up
+                logd("Major slot IMSI not ready");
+                sUserType = UNKNOWN_USER;
+                return;
+            }
+            sUserType = getUserType(sImsi[sMajorSim]);
+            if (sUserType == TYPE1_USER) {
+                if (sNwPlmnStrings != null) {
+                    sRegion = getRegion(sNwPlmnStrings[0]);
+                }
+                if (sRegion == REGION_DOMESTIC) {
+                    sFirstSelect[sMajorSim] = false;
+                    sIccCardType[sMajorSim] = getIccCardType(sMajorSim);
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                } else if (sRegion == REGION_FOREIGN) {
+                    sFirstSelect[sMajorSim] = false;
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                } else {
+                    logd("Unknown region");
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                sFirstSelect[sMajorSim] = false;
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+            } else {
+                logd("Unknown user type");
+            }
+        }
+    }
+
+    private void handleNoService() {
+        logd("[handleNoService]+ Can not find service");
+        logd("Type" + sUserType + " user");
+        logd(WorldPhoneUtil.regionToString(sRegion));
+        int mdType = ModemSwitchHandler.getActiveModemType();
+        logd(ModemSwitchHandler.modemToString(mdType));
+        IccCardConstants.State iccState = (
+                (PhoneProxy) sProxyPhones[sMajorSim]).getIccCard().getState();
+        if (iccState == IccCardConstants.State.READY) {
+            if (sUserType == TYPE1_USER) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    if (TDD_STANDBY_TIMER[sTddStandByCounter] >= 0) {
+                        if (!sWaitInTdd) {
+                            sWaitInTdd = true;
+                            logd("Wait " + TDD_STANDBY_TIMER[sTddStandByCounter] +
+                                    "s. Timer index = " + sTddStandByCounter);
+                            postDelayed(mTddStandByTimerRunnable,
+                                    TDD_STANDBY_TIMER[sTddStandByCounter] * 1000);
+                        } else {
+                            logd("Timer already set:" +
+                                    TDD_STANDBY_TIMER[sTddStandByCounter] + "s");
+                        }
+                    } else {
+                        logd("Standby in TDD modem");
+                    }
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    if (FDD_STANDBY_TIMER[sFddStandByCounter] >= 0) {
+                        if (!sWaitInFdd) {
+                            sWaitInFdd = true;
+                            logd("Wait " + FDD_STANDBY_TIMER[sFddStandByCounter] +
+                                    "s. Timer index = " + sFddStandByCounter);
+                            postDelayed(mFddStandByTimerRunnable,
+                                    FDD_STANDBY_TIMER[sFddStandByCounter] * 1000);
+                        } else {
+                            logd("Timer already set:" +
+                                FDD_STANDBY_TIMER[sFddStandByCounter] + "s");
+                        }
+                    } else {
+                        logd("Standby in FDD modem");
+                    }
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    logd("Standby in FDD modem");
+                } else {
+                    logd("Should not enter this state");
+                }
+            } else {
+                logd("Unknow user type");
+            }
+        } else {
+            logd("IccState not ready");
+        }
+        logd("[handleNoService]-");
+
+        return;
+    }
+
+    private boolean isAllowCampOn(String plmnString, int slotId) {
+        logd("[isAllowCampOn]+ " + plmnString);
+        logd("User type: " + sUserType);
+        logd(WorldPhoneUtil.iccCardTypeToString(sIccCardType[slotId]));
+        sRegion = getRegion(plmnString);
+        int mdType = ModemSwitchHandler.getActiveModemType();
+        logd(ModemSwitchHandler.modemToString(mdType));
+        if (sUserType == TYPE1_USER) {
+            if (sRegion == REGION_DOMESTIC) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    sDenyReason = CAMP_ON_NOT_DENIED;
+                    logd("Camp on OK");
+                    logd("[isAllowCampOn]-");
+                    return true;
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD;
+                    logd("Camp on REJECT");
+                    logd("[isAllowCampOn]-");
+                    return false;
+                }
+            } else if (sRegion == REGION_FOREIGN) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD;
+                    logd("Camp on REJECT");
+                    logd("[isAllowCampOn]-");
+                    return false;
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    sDenyReason = CAMP_ON_NOT_DENIED;
+                    logd("Camp on OK");
+                    logd("[isAllowCampOn]-");
+                    return true;
+                }
+            } else {
+                logd("Unknow region");
+            }
+        } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+            if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                    || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD;
+                logd("Camp on REJECT");
+                logd("[isAllowCampOn]-");
+                return false;
+            } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                    || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                sDenyReason = CAMP_ON_NOT_DENIED;
+                logd("Camp on OK");
+                logd("[isAllowCampOn]-");
+                return true;
+            }
+        } else {
+            logd("Unknown user type");
+        }
+        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+        logd("Camp on REJECT");
+        logd("[isAllowCampOn]-");
+
+        return false;
+    }
+
+    private boolean isInService() {
+        boolean inService = false;
+
+        if (sVoiceRegState == ServiceState.STATE_IN_SERVICE
+                || sDataRegState == ServiceState.STATE_IN_SERVICE) {
+            inService = true;
+        }
+        logd("inService: " + inService);
+
+        return inService;
+    }
+
+    private boolean isNoService() {
+        boolean noService = false;
+
+        if (sVoiceRegState == ServiceState.STATE_OUT_OF_SERVICE
+                && (sRilVoiceRegState == ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING
+                || sRilVoiceRegState == ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED)
+                && sDataRegState == ServiceState.STATE_OUT_OF_SERVICE
+                && sRilDataRegState == ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING) {
+            noService = true;
+        } else {
+            noService = false;
+        }
+        logd("noService: " + noService);
+
+        return noService;
+    }
+
+    private int getIccCardType(int slotId) {
+        int simType;
+        String simString = "Unknown";
+
+        simString = ((PhoneProxy) sProxyPhones[slotId]).getIccCard().getIccCardType();
+        if (simString.equals("SIM")) {
+            logd("IccCard type: SIM");
+            simType = ICC_CARD_TYPE_SIM;
+        } else if (simString.equals("USIM")) {
+            logd("IccCard type: USIM");
+            simType = ICC_CARD_TYPE_USIM;
+        } else {
+            logd("IccCard type: Unknown");
+            simType = ICC_CARD_TYPE_UNKNOWN;
+        }
+
+        return simType;
+    }
+
+    private int getRegion(String plmn) {
+        String currentMcc;
+        //[ALPS02297462] if plmn is update via EGMSS then plmn.length ==3
+        //if (plmn == null || plmn.equals("") || plmn.length() < 5) {
+        if (plmn == null || plmn.equals("") || plmn.length() < 3) {
+            logd("[getRegion] Invalid PLMN");
+            return REGION_UNKNOWN;
+        }
+        currentMcc = plmn.substring(0, 3);
+        for (String mcc : sMccDomestic) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] REGION_DOMESTIC");
+                return REGION_DOMESTIC;
+            }
+        }
+        logd("[getRegion] REGION_FOREIGN");
+        return REGION_FOREIGN;
+    }
+
+    private int getUserType(String imsi) {
+        if (imsi != null && !imsi.equals("")) {
+            imsi = imsi.substring(0, 5);
+            for (String mccmnc : sPlmnType1) {
+                if (imsi.equals(mccmnc)) {
+                    logd("[getUserType] Type1 user");
+                    return TYPE1_USER;
+                }
+            }
+            for (String mccmnc : sPlmnType1Ext) {
+                if (imsi.equals(mccmnc)) {
+                   logd("[getUserType] Extended Type1 user");
+                   return TYPE1_USER;
+                }
+            }
+            for (String mccmnc : sPlmnType3) {
+                if (imsi.equals(mccmnc)) {
+                    logd("[getUserType] Type3 user");
+                    return TYPE3_USER;
+                }
+            }
+            logd("[getUserType] Type2 user");
+            return TYPE2_USER;
+        } else {
+            logd("[getUserType] null IMSI");
+            return UNKNOWN_USER;
+        }
+    }
+
+    private void resumeCampingProcedure(int slotId) {
+        logd("Resume camping slot " + slotId);
+        String plmnString;
+        if (sNwPlmnStrings != null && sNwPlmnStrings[0] != null) {
+            plmnString = sNwPlmnStrings[0];
+            if (isAllowCampOn(plmnString, slotId)) {
+                removeModemStandByTimer();
+                //C2K world phone - start
+                if (!WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    sCi[slotId].setResumeRegistration(
+                            sSuspendId[slotId], obtainMessage(EVENT_RESUME_CAMPING));
+                } else {
+                    CommandsInterface ci = getSvlteActiveCi(slotId);
+                    if (ci != null) {
+                        ci.setResumeRegistration(
+                                sSuspendId[slotId], obtainMessage(EVENT_RESUME_CAMPING));
+                    }
+                }
+                //C2K world phone - end
+            } else {
+                logd("Because: " + WorldPhoneUtil.denyReasonToString(sDenyReason));
+                if (sDenyReason == CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD) {
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                } else if (sDenyReason == CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD) {
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                }
+            }
+        } else {
+            logd("sNwPlmnStrings[0] is null");
+        }
+    }
+
+    private Runnable mTddStandByTimerRunnable = new Runnable() {
+        public void run() {
+            sTddStandByCounter++;
+            if (sTddStandByCounter >= TDD_STANDBY_TIMER.length) {
+                sTddStandByCounter = TDD_STANDBY_TIMER.length - 1;
+            }
+            //[ALPS02302039]
+            if (sBtSapState == 0 ){
+                logd("TDD time out!");
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+            } else {
+                logd("TDD time out but BT SAP is connected, switch not executed!");
+            }
+        }
+    };
+
+    private Runnable mFddStandByTimerRunnable = new Runnable() {
+        public void run() {
+            sFddStandByCounter++;
+            if (sFddStandByCounter >= FDD_STANDBY_TIMER.length) {
+                sFddStandByCounter = FDD_STANDBY_TIMER.length - 1;
+            }
+            //[ALPS02302039]
+            if (sBtSapState == 0 ){
+                logd("FDD time out!");
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+            } else {
+                logd("FDD time out but BT SAP is connected, switch not executed!");
+            }
+        }
+    };
+
+    private void removeModemStandByTimer() {
+        if (sWaitInTdd) {
+            logd("Remove TDD wait timer. Set sWaitInTdd = false");
+            sWaitInTdd = false;
+            removeCallbacks(mTddStandByTimerRunnable);
+        }
+        if (sWaitInFdd) {
+            logd("Remove FDD wait timer. Set sWaitInFdd = false");
+            sWaitInFdd = false;
+            removeCallbacks(mFddStandByTimerRunnable);
+        }
+    }
+
+    private void resetAllProperties() {
+        logd("[resetAllProperties]");
+        sNwPlmnStrings = null;
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sFirstSelect[i] = true;
+        }
+        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+        sIsResumeCampingFail = false; //[ALPS01974750]
+        sRadioTechModeForWp = RADIO_TECH_MODE_FOR_WP_UNKNOWN; //C2K world phone
+        sBtSapState = 0; //[ALPS02302039]
+        resetSimProperties();
+        resetNetworkProperties();
+    }
+
+    private void resetNetworkProperties() {
+        logd("[resetNetworkProperties]");
+        synchronized (sLock) {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                sSuspendWaitImsi[i] = false;
+            }
+            if (sNwPlmnStrings != null) {
+                for (int i = 0; i < sNwPlmnStrings.length; i++) {
+                    sNwPlmnStrings[i] = "";
+                }
+            }
+        }
+    }
+
+    private void resetSimProperties() {
+        logd("[resetSimProperties]");
+        synchronized (sLock) {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                sImsi[i] = "";
+                sIccCardType[i] = ICC_CARD_TYPE_UNKNOWN;
+            }
+            sUserType = UNKNOWN_USER;
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+        }
+    }
+
+    private void searchForDesignateService(String strPlmn) {
+        if ((strPlmn == null) || (strPlmn.length() < 5)) {
+            logd("[searchForDesignateService]- null source");
+            return;
+        }
+        strPlmn = strPlmn.substring(0, 5);
+        for (String mccmnc : sPlmnType1) {
+            if (strPlmn.equals(mccmnc)) {
+                logd("Find TD service");
+                logd("sUserType: " + sUserType + " sRegion: " + sRegion);
+                logd(ModemSwitchHandler.modemToString(
+                        ModemSwitchHandler.getActiveModemType()));
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                break;
+            }
+        }
+
+        return;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+        // MTK TODO
+        /*
+        Settings.Global.putInt(sContext.getContentResolver(),
+                Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, mode);
+        */
+        if (mode == SELECTION_MODE_AUTO) {
+            logd("Modem Selection <AUTO>");
+            sIsAutoSelectEnable = true;    //[ALPS01881475]
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+            handleSimSwitched();
+        } else {
+            logd("Modem Selection <MANUAL>");
+            //sMajorSim = AUTO_SWITCH_OFF;    //[ALPS01881475]
+            sIsAutoSelectEnable = false;
+            handleSwitchModem(modemType);
+            if (modemType == ModemSwitchHandler.getActiveModemType()) {
+                removeModemStandByTimer();
+            }
+        }
+    }
+
+    public void notifyRadioCapabilityChange(int capailitySimId) {
+        int majorSimId = WorldPhoneUtil.getMajorSim();
+        // int activeSvlteModeSlotId = SvlteModeController.getActiveSvlteModeSlotId();
+        int toModem = 0;
+
+        logd("[setRadioCapabilityChange] majorSimId:" + majorSimId +
+                " capailitySimId=" + capailitySimId);
+        if (!sIsAutoSelectEnable) {
+            logd("[setRadioCapabilityChange] Auto modem selection disabled");
+            removeModemStandByTimer();
+        } else {
+            if (sImsi[capailitySimId] == null || sImsi[capailitySimId].equals("")) {
+                // may caused by receive 3g switched intent when boot up
+                logd("Capaility slot IMSI not ready");
+                sUserType = UNKNOWN_USER;
+                return;
+            }
+            sUserType = getUserType(sImsi[capailitySimId]);
+            if (sUserType == TYPE1_USER) {
+                if (sNwPlmnStrings != null) {
+                    sRegion = getRegion(sNwPlmnStrings[0]);
+                }
+                if (sRegion == REGION_DOMESTIC) {
+                    sFirstSelect[capailitySimId] = false;
+                    sIccCardType[capailitySimId] = getIccCardType(capailitySimId);
+                    toModem = ModemSwitchHandler.MD_TYPE_TDD;
+                } else if (sRegion == REGION_FOREIGN) {
+                    sFirstSelect[capailitySimId] = false;
+                    toModem = ModemSwitchHandler.MD_TYPE_FDD;
+                } else {
+                    logd("Unknown region");
+                    return;
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                sFirstSelect[capailitySimId] = false;
+                toModem = ModemSwitchHandler.MD_TYPE_FDD;
+            } else {
+                logd("Unknown user type");
+                return;
+            }
+
+            if (toModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    toModem = ModemSwitchHandler.MD_TYPE_LTG;
+                } else {
+                    toModem = ModemSwitchHandler.MD_TYPE_TG;
+                }
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    toModem = ModemSwitchHandler.MD_TYPE_LWG;
+                } else {
+                    toModem = ModemSwitchHandler.MD_TYPE_WG;
+                }
+            }
+
+            logd("notifyRadioCapabilityChange: Storing modem type: " + toModem);
+
+            //C2K world phone - start
+            CommandsInterface ci = null;
+            if (majorSimId != MAJOR_SIM_UNKNOWN) {
+                // MTK TODO
+                /*
+                if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+                    if (!isSpecialCardMode()) {
+                        if (capailitySimId != activeSvlteModeSlotId) {
+                            //new Radio Tech. Mode will be CSFB mode
+                            logd("new RT mode is CSFB");
+                            ci = getSvlteActiveCi(majorSimId);
+                        } else {
+                            //[ALPS02095187]-start
+                            //new RT mode is SVLTE mode
+                            if (toModem == ModemSwitchHandler.MD_TYPE_LWG) {
+                                logd("new RT mode is SVLTE and new type is LWG");
+                                ci = getSvlteActiveCi(majorSimId);
+                            }
+                            //[ALPS02095187]-end
+                        }
+                    } else {
+                        logd("isSpecialCardMode=true, ignore this change!");
+                    }
+                } else {
+                */
+                    ci = sCi[PhoneConstants.SIM_ID_1];
+                // }
+
+                if (ci != null) {
+                    ci.storeModemType(toModem, null);
+                    ci.reloadModemType(toModem, null);
+                    resetNetworkProperties();
+                    //sCi[PhoneConstants.SIM_ID_1].reloadModemType(toModem, null);
+                }
+            } else {
+                //wait for radio capa. switch done
+                logd("notifyRadioCapabilityChange: major sim is unknown");
+            }
+            //C2K world phone - end
+        }
+    }
+
+    public void handleRadioTechModeSwitch() {
+        int toModem = 0;
+        logd("[handleRadioTechModeSwitch]");
+        logd("sRadioTechModeForWp: " + sRadioTechModeForWp);
+        if (!sIsAutoSelectEnable) {
+            logd("Auto modem selection disabled");
+            removeModemStandByTimer();
+        } else {
+            logd("Auto modem selection enabled");
+            if (sImsi[sMajorSim] == null || sImsi[sMajorSim].equals("")) {
+                // may caused by receive 3g switched intent when boot up
+                logd("Capaility slot IMSI not ready");
+                sUserType = UNKNOWN_USER;
+                return;
+            }
+            sUserType = getUserType(sImsi[sMajorSim]);
+            if (sUserType == TYPE1_USER) {
+                if (sNwPlmnStrings != null) {
+                    sRegion = getRegion(sNwPlmnStrings[0]);
+                }
+                if (sRegion == REGION_DOMESTIC) {
+                    sFirstSelect[sMajorSim] = false;
+                    sIccCardType[sMajorSim] = getIccCardType(sMajorSim);
+                    toModem = ModemSwitchHandler.MD_TYPE_TDD;
+                } else if (sRegion == REGION_FOREIGN) {
+                    sFirstSelect[sMajorSim] = false;
+                    toModem = ModemSwitchHandler.MD_TYPE_FDD;
+                } else {
+                    logd("Unknown region");
+                    return;
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                sFirstSelect[sMajorSim] = false;
+                toModem = ModemSwitchHandler.MD_TYPE_FDD;
+            } else {
+                logd("Unknown user type");
+                return;
+            }
+
+            if (toModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    toModem = ModemSwitchHandler.MD_TYPE_LTG;
+                } else {
+                    toModem = ModemSwitchHandler.MD_TYPE_TG;
+                }
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    toModem = ModemSwitchHandler.MD_TYPE_LWG;
+                } else {
+                    toModem = ModemSwitchHandler.MD_TYPE_WG;
+                }
+            }
+
+            logd("[handleRadioTechModeSwitch]: switch type: " + toModem);
+            handleSwitchModem(toModem);
+            resetNetworkProperties();
+        }
+    }
+
+    private static void loadDefaultData() {
+        for (String plmn : PLMN_TABLE_TYPE1) {
+            sPlmnType1.add(plmn);
+        }
+
+        for (String plmn : PLMN_TABLE_TYPE1_EXT) {
+            sPlmnType1Ext.add(plmn);
+        }
+
+        for (String plmn : PLMN_TABLE_TYPE3) {
+            sPlmnType3.add(plmn);
+        }
+
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            sMccDomestic.add(mcc);
+        }
+    }
+
+    private CommandsInterface getSvlteActiveCi(int slotId) {
+        if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+            logd("[getSvlteActiveCi]: slotId=" + slotId +
+                    " sMajorSim=" + sMajorSim +
+                    " sRadioTechModeForWp=" + sRadioTechModeForWp);
+
+            // MTK TODO
+            if (false /* sProxyPhones[slotId] instanceof SvltePhoneProxy */) {
+                logd("[getSvlteActiveCi]: return sSvlteLteCi");
+                return sSvlteLteCi[slotId];
+            } else {
+                logd("[getSvlteActiveCi]: return sCi");
+                return sCi[slotId];
+            }
+        } else {
+            logd("[getSvlteActiveCi]: return sCi");
+            return sCi[slotId];
+        }
+    }
+
+    private boolean isNeedHandleSwitchForRadioTechMode() {
+        boolean isNeed = false;
+        logd("[isNeedHandleSwitchForRadioTechMode] RT mode=" + sRadioTechModeForWp);
+
+        if ((sRadioTechModeForWp == RADIO_TECH_MODE_FOR_WP_SVLTE) ||
+                (isSpecialCardMode())) {
+            if (ModemSwitchHandler.getActiveModemType() ==  ModemSwitchHandler.MD_TYPE_LTG) {
+                logd("[isNeedHandleSwitchForRadioTechMode] SVLTE mode and MD type is LTG");
+                //need switch to LWG
+                isNeed = true;
+            }
+        } else if (sRadioTechModeForWp == RADIO_TECH_MODE_FOR_WP_CSFB) {
+            logd("[isNeedHandleSwitchForRadioTechMode] CSFB mode");
+            isNeed = true;
+        } else {
+            logd("[isNeedHandleSwitchForRadioTechMode] no need to switch");
+        }
+        return isNeed;
+    }
+
+    private boolean isSpecialCardMode() {
+        // MTK TODO
+        /*
+        boolean specialCardMode = false;
+        if (sRadioTechModeForWp != RADIO_TECH_MODE_FOR_WP_UNKNOWN) {
+            int numberPhones = TelephonyManager.getDefault().getPhoneCount();
+            int[] cardType = new int[numberPhones];
+            cardType = UiccController.getInstance().getC2KWPCardType();
+
+            if ((is4GCdmaCard(cardType[0]) && is4GCdmaCard(cardType[1])) ||
+                    (is3GCdmaCard(cardType[0]) && is3GCdmaCard(cardType[1]))) {
+                logd("isSpecialCardMode cardType1=" + cardType[0] +
+                        ", cardType2=" + cardType[1]);
+                specialCardMode = true;
+            }
+        }
+        logd("isSpecialCardMode:" + specialCardMode);
+        return specialCardMode;
+        */
+        return false;
+    }
+
+    private boolean is4GCdmaCard(int cardType) {
+        if ((cardType & UiccController.CARD_TYPE_USIM) > 0 &&
+            containsCdma(cardType)) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean is3GCdmaCard(int cardType) {
+        if ((cardType & UiccController.CARD_TYPE_USIM) == 0 &&
+            (cardType & UiccController.CARD_TYPE_SIM) == 0 &&
+            containsCdma(cardType)) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean containsCdma(int cardType) {
+        if ((cardType & UiccController.CARD_TYPE_RUIM) > 0 ||
+                (cardType & UiccController.CARD_TYPE_CSIM) > 0) {
+            return true;
+        }
+        return false;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPOM]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
new file mode 100755
index 0000000..5cec9e3
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
@@ -0,0 +1,431 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.Context;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.ProxyController;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+import com.mediatek.internal.telephony.ModemSwitchHandler;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
+/**
+ *@hide
+ */
+public class WorldPhoneUtil implements IWorldPhone {
+
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN = 0;
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_FDD = 1;
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_TDD = 2;
+
+    private static final int ACTIVE_MD_TYPE_UNKNOWN = 0;
+    private static final int ACTIVE_MD_TYPE_WG   = 1;//3G(WCDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_TG   = 2;//3G(TDS-CDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LWG  = 3;//4G(TDD-LTE+FDD-LTE)+3G(WCDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LTG  = 4;//4G(TDD-LTE+FDD-LTE)+3G(TDS-CDMA)+2G(GSM)
+    //4G(TDD-LTE+FDD-LTE)+3G(WCDMA+EVDO)+2G(GSM+CDMA2000)
+    private static final int ACTIVE_MD_TYPE_LWCG = 5;
+    private static final int ACTIVE_MD_TYPE_LtTG = 6;//4G(TDD-LTE)+3G(TDS-CDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LfWG = 7;//4G(FDD-LTE)+3G(WCDMA)+2G(GSM)
+
+    private static final int PROJECT_SIM_NUM = TelephonyManager.getDefault().getSimCount();
+    private static final boolean IS_WORLD_PHONE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_world_phone", 0) == 1);
+    private static final boolean IS_LTE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1);
+    private static final boolean IS_CDMA_LTE_DC_SUPPORT =
+            CdmaFeatureOptionUtils.isCdmaLteDcSupport();
+    private static final boolean IS_WORLD_MODE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_md_world_mode_support", 0) == 1);
+    private static final String PROPERTY_MAJOR_SIM = "persist.radio.simswitch";
+    private static Context sContext = null;
+    private static Phone sDefultPhone = null;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+
+
+    public WorldPhoneUtil() {
+        logd("Constructor invoked");
+        sDefultPhone = PhoneFactory.getDefaultPhone();
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+        }
+        if (sDefultPhone != null) {
+            sContext = sDefultPhone.getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    public static int getProjectSimNum() {
+        return PROJECT_SIM_NUM;
+    }
+
+    public static int getMajorSim() {
+        // MTK TODO
+        if (true /* !ProxyController.getInstance().isCapabilitySwitching() */) {
+            String currMajorSim = SystemProperties.get(PROPERTY_MAJOR_SIM, "");
+            if (currMajorSim != null && !currMajorSim.equals("")) {
+                logd("[getMajorSim]: " + ((Integer.parseInt(currMajorSim)) - 1));
+                return (Integer.parseInt(currMajorSim)) - 1;
+            } else {
+                logd("[getMajorSim]: fail to get major SIM");
+                return MAJOR_SIM_UNKNOWN;
+            }
+        } else {
+            logd("[getMajorSim]: radio capability is switching");
+            return MAJOR_SIM_UNKNOWN;
+        }
+    }
+
+    public static int getModemSelectionMode() {
+        if (sContext == null) {
+            logd("sContext = null");
+            return SELECTION_MODE_AUTO;
+        }
+
+        // MTK TODO
+        // return Settings.Global.getInt(sContext.getContentResolver(),
+        //             Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_AUTO);
+        return SELECTION_MODE_AUTO;
+    }
+
+    public static boolean isWorldPhoneSupport() {
+        return IS_WORLD_PHONE_SUPPORT;
+    }
+
+    public static boolean isLteSupport() {
+        return IS_LTE_SUPPORT;
+    }
+
+    public static String regionToString(int region) {
+        String regionString;
+        switch (region) {
+            case REGION_UNKNOWN:
+                regionString = "REGION_UNKNOWN";
+                break;
+            case REGION_DOMESTIC:
+                regionString = "REGION_DOMESTIC";
+                break;
+            case REGION_FOREIGN:
+                regionString = "REGION_FOREIGN";
+                break;
+            default:
+                regionString = "Invalid Region";
+                break;
+        }
+
+        return regionString;
+    }
+
+    public static String stateToString(int state) {
+        String stateString;
+        switch (state) {
+            case ServiceState.STATE_POWER_OFF:
+                stateString = "STATE_POWER_OFF";
+                break;
+            case ServiceState.STATE_IN_SERVICE:
+                stateString = "STATE_IN_SERVICE";
+                break;
+            case ServiceState.STATE_OUT_OF_SERVICE:
+                stateString = "STATE_OUT_OF_SERVICE";
+                break;
+            case ServiceState.STATE_EMERGENCY_ONLY:
+                stateString = "STATE_EMERGENCY_ONLY";
+                break;
+            default:
+                stateString = "Invalid State";
+                break;
+        }
+
+        return stateString;
+    }
+
+    public static String regStateToString(int regState) {
+        String rsString;
+        switch (regState) {
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_HOME_NETWORK:
+                rsString = "REGISTRATION_STATE_HOME_NETWORK";
+                break;
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED:
+                rsString = "REGISTRATION_STATE_REGISTRATION_DENIED";
+                break;
+            case ServiceState.REGISTRATION_STATE_UNKNOWN:
+                rsString = "REGISTRATION_STATE_UNKNOWN";
+                break;
+            case ServiceState.REGISTRATION_STATE_ROAMING:
+                rsString = "REGISTRATION_STATE_ROAMING";
+                break;
+            case ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED:
+                rsString =
+                    "REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED:
+                rsString =
+                    "REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED:
+                rsString = "REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED:
+                rsString = "REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED";
+                break;
+            default:
+                rsString = "Invalid RegState";
+                break;
+        }
+
+        return rsString;
+    }
+
+    public static String denyReasonToString(int reason) {
+        String drString;
+        switch (reason) {
+            case CAMP_ON_NOT_DENIED:
+                drString = "CAMP_ON_NOT_DENIED";
+                break;
+            case CAMP_ON_DENY_REASON_UNKNOWN:
+                drString = "CAMP_ON_DENY_REASON_UNKNOWN";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD";
+                break;
+            case CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD:
+                drString = "CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD";
+                break;
+            default:
+                drString = "Invalid Reason";
+                break;
+        }
+
+        return drString;
+    }
+
+    public static String iccCardTypeToString(int iccCardType) {
+        String iccTypeString;
+        switch (iccCardType) {
+            case ICC_CARD_TYPE_SIM:
+                iccTypeString = "SIM";
+                break;
+            case ICC_CARD_TYPE_USIM:
+                iccTypeString = "USIM";
+                break;
+            case ICC_CARD_TYPE_UNKNOWN:
+                iccTypeString = "Icc Card Type Unknown";
+                break;
+            default:
+                iccTypeString = "Invalid Icc Card Type";
+                break;
+        }
+
+        return iccTypeString;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+    }
+
+    public void notifyRadioCapabilityChange(int capailitySimId) {
+    }
+
+    public static boolean isCdmaLteDcSupport() {
+        return IS_CDMA_LTE_DC_SUPPORT;
+    }
+
+    //C2K world phone
+    public static int getRadioTechModeForWp() {
+        int mode = RADIO_TECH_MODE_FOR_WP_UNKNOWN;
+        if (isCdmaLteDcSupport()) {
+            // MTK TODO
+            /*
+            int majorySimId = getMajorSim();
+            int svlteModeSlotId = SvlteModeController.getActiveSvlteModeSlotId();
+            logd("[getRadioTechModeForWp]: majorySimId=" + majorySimId +
+                    " svlteModeSlotId=" + svlteModeSlotId);
+            if (majorySimId != MAJOR_SIM_UNKNOWN) {
+                if (svlteModeSlotId == majorySimId) {
+                    mode = RADIO_TECH_MODE_FOR_WP_SVLTE;
+                } else {
+                    mode = RADIO_TECH_MODE_FOR_WP_CSFB;
+                }
+            } else {
+                mode = RADIO_TECH_MODE_FOR_WP_UNKNOWN;
+            }
+            */
+            logd("[getRadioTechModeForWp]: xen0n: TODO for CDMA!");
+        } else {
+            mode = RADIO_TECH_MODE_FOR_WP_CSFB;
+        }
+        logd("[getRadioTechModeForWp]: " + mode);
+        return mode;
+    }
+
+    //WorldMode
+    public static boolean isWorldModeSupport() {
+        return IS_WORLD_MODE_SUPPORT;
+    }
+
+    /**
+     * In world phone support project, modem support both FDD(Frequency-division duplexing) mode and
+     * TDD(Time-division duplexin) mode for 3G(UTRAN). It runs only one mode, FDD or TDD, at a time.
+     * This API will return acully divison duplexing mode.
+     *
+     * @return 0 :unknown
+     *         1 : FDD
+     *         2 : TDD
+     */
+    public static int get3GDivisionDuplexMode(){
+        int duplexMode = UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN;
+        int activeMdType = getActiveModemType();
+
+
+        switch (activeMdType) {
+            case ACTIVE_MD_TYPE_WG:
+            case ACTIVE_MD_TYPE_LWG:
+            case ACTIVE_MD_TYPE_LfWG:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_FDD;
+                break;
+
+            case ACTIVE_MD_TYPE_TG:
+            case ACTIVE_MD_TYPE_LTG:
+            case ACTIVE_MD_TYPE_LtTG:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_TDD;
+                break;
+            default:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN;
+            break;
+        }
+        logd("get3GDivisionDuplexMode=" + duplexMode);
+        return duplexMode;
+    }
+
+    private static int getActiveModemType(){
+        int modemType = 0;
+        int activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+
+        if(!isWorldModeSupport()){
+            modemType = ModemSwitchHandler.getActiveModemType();
+            switch (modemType) {
+                case ModemSwitchHandler.MD_TYPE_WG:
+                    activeMdType = ACTIVE_MD_TYPE_WG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_TG:
+                    activeMdType = ACTIVE_MD_TYPE_TG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_LWG:
+                    activeMdType = ACTIVE_MD_TYPE_LWG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_LTG:
+                    activeMdType = ACTIVE_MD_TYPE_LTG;
+                    break;
+                default:
+                    activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+                break;
+            }
+        } else {
+            modemType = WorldMode.getWorldMode();
+            int activeMode = Integer.valueOf(
+                    SystemProperties.get("ril.nw.worldmode.activemode",
+                    Integer.toString(ACTIVE_MD_TYPE_UNKNOWN)));
+            logd("[getActiveModemType]: activeMode"+ activeMode);
+            switch (modemType) {
+                case WorldMode.MD_WORLD_MODE_LTG:
+                    activeMdType = ACTIVE_MD_TYPE_LTG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWG:
+                    activeMdType = ACTIVE_MD_TYPE_LWG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWTG:
+                case WorldMode.MD_WORLD_MODE_LWCTG:
+                    if (activeMode > 0){
+                        if (activeMode == 1){
+                            //FDD mode
+                            activeMdType = ACTIVE_MD_TYPE_LWG;
+                        } else if (activeMode == 2){
+                            //TDD mode
+                            activeMdType = ACTIVE_MD_TYPE_LTG;
+                        }
+                    }
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWCG:
+                    activeMdType = ACTIVE_MD_TYPE_LWCG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LTTG:
+                    activeMdType = ACTIVE_MD_TYPE_LtTG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LFWG:
+                    activeMdType = ACTIVE_MD_TYPE_LfWG;
+                    break;
+                default:
+                    activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+                break;
+            }
+        }
+        logd("getActiveModemType=" + activeMdType);
+        return activeMdType;
+    }
+
+    public static boolean isWorldPhoneSwitching(){
+        if (isWorldModeSupport()){
+            return WorldMode.isWorldModeSwitching();
+        } else {
+            return false;
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPP_UTIL]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java
new file mode 100755
index 0000000..be839fe
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java
@@ -0,0 +1,87 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+
+
+
+/**
+ *@hide
+ */
+public class WorldPhoneWrapper implements IWorldPhone {
+    private static int sOperatorSpec = -1;
+    private static IWorldPhone sWorldPhoneInstance = null;
+    private static WorldPhoneUtil sWorldPhoneUtil = null;
+
+    public WorldPhoneWrapper() {
+    }
+
+    public static IWorldPhone getWorldPhoneInstance() {
+        if (sWorldPhoneInstance == null) {
+            // String optr = SystemProperties.get("ro.operator.optr");
+            // if (optr != null && optr.equals("OP01")) {
+            //     sOperatorSpec = POLICY_OP01;
+            // } else {
+                sOperatorSpec = POLICY_OM;
+            // }
+            sWorldPhoneUtil = new WorldPhoneUtil();
+            // if (sOperatorSpec == POLICY_OP01) {
+            //     sWorldPhoneInstance = new WorldPhoneOp01();
+            // } else if (sOperatorSpec == POLICY_OM) {
+                sWorldPhoneInstance = new WorldPhoneOm();
+            // }
+        }
+        logd("sOperatorSpec: " + sOperatorSpec + ", isLteSupport: " + WorldPhoneUtil.isLteSupport());
+
+        return sWorldPhoneInstance;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+        if (sOperatorSpec == POLICY_OP01 || sOperatorSpec == POLICY_OM) {
+            sWorldPhoneInstance.setModemSelectionMode(mode, modemType);
+        } else {
+            logd("Unknown World Phone Spec");
+        }
+    }
+
+    public void notifyRadioCapabilityChange(int capailitySimId) {
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPO_WRAPPER]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/telephony/ExternalSimConstants.java b/src/java/com/mediatek/telephony/ExternalSimConstants.java
new file mode 100644
index 0000000..928b67c
--- /dev/null
+++ b/src/java/com/mediatek/telephony/ExternalSimConstants.java
@@ -0,0 +1,100 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+/**
+ * @hide
+ */
+public class ExternalSimConstants {
+    // External SIM to platform
+    public static final int MSG_ID_INITIALIZATION_REQUEST           = 1;
+    public static final int MSG_ID_GET_PLATFORM_CAPABILITY_REQUEST  = 2;
+    public static final int MSG_ID_EVENT_REQUEST                    = 3;
+    public static final int MSG_ID_UICC_RESET_RESPONSE              = 4;
+    public static final int MSG_ID_UICC_APDU_RESPONSE               = 5;
+    public static final int MSG_ID_UICC_POWER_DOWN_RESPONSE         = 6;
+    public static final int MSG_ID_GET_SERVICE_STATE_REQUEST        = 7;
+    public static final int MSG_ID_FINALIZATION_REQUEST             = 8;
+
+    // Type id of MSG_ID_EVENT_REQUEST event
+    public static final int REQUEST_TYPE_ENABLE_EXTERNAL_SIM        = 1;
+    public static final int REQUEST_TYPE_DISABLE_EXTERNAL_SIM       = 2;
+    public static final int REQUEST_TYPE_PLUG_OUT                   = 3;
+    public static final int REQUEST_TYPE_PLUG_IN                    = 4;
+
+    // SIM type
+    public static final int SIM_TYPE_LOCAL_SIM  = 1;
+    public static final int SIM_TYPE_REMOTE_SIM = 2;
+
+    // Response result
+    public static final int RESPONSE_RESULT_OK                  = 0;
+    public static final int RESPONSE_RESULT_GENERIC_ERROR       = -1;
+    public static final int RESPONSE_RESULT_PLATFORM_NOT_READY  = -2;
+
+    // Platform to external SIM
+    public static final int MSG_ID_INITIALIZATION_RESPONSE          = 1001;
+    public static final int MSG_ID_GET_PLATFORM_CAPABILITY_RESPONSE = 1002;
+    public static final int MSG_ID_EVENT_RESPONSE                   = 1003;
+    public static final int MSG_ID_UICC_RESET_REQUEST               = 1004;
+    public static final int MSG_ID_UICC_APDU_REQUEST                = 1005;
+    public static final int MSG_ID_UICC_POWER_DOWN_REQUEST          = 1006;
+    public static final int MSG_ID_GET_SERVICE_STATE_RESPONSE       = 1007;
+    public static final int MSG_ID_FINALIZATION_RESPONSE            = 1008;
+
+    // Platfrom capability parameters
+    public static final int MULTISIM_CONFIG_UNKNOWN = 0;
+    public static final int MULTISIM_CONFIG_DSDS = 1;
+    public static final int MULTISIM_CONFIG_DSDA = 2;
+    public static final int MULTISIM_CONFIG_TSTS = 3;
+}
+
+
diff --git a/src/java/com/mediatek/telephony/ExternalSimManager.java b/src/java/com/mediatek/telephony/ExternalSimManager.java
new file mode 100644
index 0000000..e9e25b7
--- /dev/null
+++ b/src/java/com/mediatek/telephony/ExternalSimManager.java
@@ -0,0 +1,1272 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalServerSocket;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import android.telephony.SubscriptionManager;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.telephony.TelephonyManager.MultiSimVariants;
+
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.mediatek.internal.telephony.RadioManager;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
+/**
+ * @hide
+ */
+public class ExternalSimManager {
+    private static final String TAG = "ExternalSimManager";
+
+    private static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
+
+    private static ExternalSimManager sInstance = null;
+    private VsimEvenHandler mEventHandler = null;
+    private VsimIoThread mRilIoThread = null;
+    private boolean isMdWaitingResponse = false;
+
+    static final String[] PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+
+    /*  Construction function for TelephonyManager */
+    public ExternalSimManager() {
+        Rlog.d(TAG, "construtor 0 parameter is called - done");
+    }
+
+    private ExternalSimManager(Context context) {
+        Rlog.d(TAG, "construtor 1 parameter is called - start");
+
+        mEventHandler = new VsimEvenHandler();
+
+        new Thread() {
+            public void run() {
+                ServerTask server = new ServerTask();
+                server.listenConnection(mEventHandler);
+            }
+        }.start();
+
+        // Need to reset system properties when shutdown ipo to avoid receiving unexcepted
+        // intetnt in case of IPO boot up.
+        IntentFilter intentFilter = new IntentFilter("android.intent.action.ACTION_SHUTDOWN_IPO");
+        context.registerReceiver(sReceiver, intentFilter);
+
+        Rlog.d(TAG, "construtor is called - end");
+    }
+
+    /** @hide
+     *  @return return the static instance of ExternalSimManager
+     */
+    public static ExternalSimManager getDefault(Context context) {
+        Rlog.d(TAG, "getDefault()");
+        if (sInstance == null) {
+            sInstance = new ExternalSimManager(context);
+        }
+        return sInstance;
+    }
+
+    private static ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    // Need to reset system properties when shutdown ipo to avoid receiving unexcepted
+    // intetnt in case of IPO boot up.
+    private final BroadcastReceiver sReceiver = new  BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Rlog.d(TAG,"[Receiver]+");
+            String action = intent.getAction();
+            Rlog.d(TAG,"Action: " + action);
+
+            if (action.equals("android.intent.action.ACTION_SHUTDOWN_IPO")) {
+                // set system property to note that sim enabled
+                SystemProperties.set(TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "");
+                SystemProperties.set(TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "");
+            }
+            Rlog.d(TAG,"[Receiver]-");
+        }
+    };
+
+    public boolean initializeService(byte[] userData) {
+        Rlog.d(TAG, "initializeService() - start");
+
+        if (SystemProperties.getInt("ro.mtk_external_sim_support", 0) == 0) {
+            Rlog.d(TAG, "initializeService() - mtk_external_sim_support didn't support");
+            return false;
+        }
+
+        try {
+            getITelephonyEx().initializeService("osi");
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+        Rlog.d(TAG, "initialize() - end");
+        return true;
+    }
+
+    public boolean finalizeService(byte[] userData) {
+        Rlog.d(TAG, "finalizeService() - start");
+
+        if (SystemProperties.getInt("ro.mtk_external_sim_support", 0) == 0) {
+            Rlog.d(TAG, "initializeService() - mtk_external_sim_support didn't support");
+            return false;
+        }
+
+        try {
+            getITelephonyEx().finalizeService("osi");
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+        Rlog.d(TAG, "finalizeService() - end");
+        return true;
+    }
+
+    /**
+     * Maintain a server task to provide extenal client to connect to do
+     * some external SIM operation.
+     *
+     */
+    public class ServerTask {
+        public static final String HOST_NAME = "vsim-adaptor";
+        private VsimIoThread ioThread = null;
+
+        public void listenConnection(VsimEvenHandler eventHandler) {
+            Rlog.d(TAG, "listenConnection() - start");
+
+            LocalServerSocket serverSocket = null;
+            ExecutorService threadExecutor = Executors.newCachedThreadPool();
+
+            try {
+                // Create server socket
+                serverSocket = new LocalServerSocket(HOST_NAME);
+
+                while(true) {
+                    // Allow multiple connection connect to server.
+                    LocalSocket socket = serverSocket.accept();
+                    Rlog.d(TAG, "There is a client is accpted: " + socket.toString());
+
+                    threadExecutor.execute(new ConnectionHandler(socket, eventHandler));
+                }
+            } catch (IOException e) {
+                Rlog.d(TAG, "listenConnection catch IOException");
+                e.printStackTrace();
+            } catch (Exception e) {
+                Rlog.d(TAG, "listenConnection catch Exception");
+                e.printStackTrace();
+            } finally {
+                Rlog.d(TAG, "listenConnection finally!!");
+                if (threadExecutor != null )
+                    threadExecutor.shutdown();
+                if (serverSocket != null) {
+                    try {
+                        serverSocket.close();
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+            Rlog.d(TAG, "listenConnection() - end");
+        }
+    }
+
+
+    /**
+     * Maintain a RIL client task to connect to ril_vsim socket to communicate with rild/modem.
+     *
+     */
+    public class RilClientTask {
+        public static final String SERVER_NAME = "rild-vsim";
+        LocalSocket mSocket = null;
+        private VsimIoThread ioThread = null;
+        private int retryCount = 0;
+
+        // Need to connect to ril_vsim socket to communicate with rild/modem
+        public void connectToServer() {
+            Rlog.d(TAG, "connectToServer() - start");
+            while (retryCount < 10) {
+                try {
+                    Rlog.d(TAG, "connectToServer() - before");
+
+                    mSocket = new LocalSocket();
+                    LocalSocketAddress addr = new LocalSocketAddress(SERVER_NAME,
+                            LocalSocketAddress.Namespace.RESERVED);
+
+                    mSocket.connect(addr);
+
+                    Rlog.d(TAG, "connectToServer() - after");
+                } catch (IOException e) {
+                    Rlog.d(TAG, "connectToServer catch IOException");
+                    e.printStackTrace();
+
+                    if (mSocket != null && !mSocket.isConnected()) {
+                        retryCount++;
+                        try {
+                            Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                        } catch (InterruptedException er) {
+                        }
+                        Rlog.d(TAG, "connectToServer retry later, retry count: " + retryCount);
+                    }
+                }
+
+                if (mSocket != null && mSocket.isConnected()) {
+                    Rlog.d(TAG, "connectToServer connected!");
+                    break;
+                }
+            }
+            Rlog.d(TAG, "connectToServer() - end");
+        }
+
+        public VsimIoThread getIoThread(VsimEvenHandler eventHandler) {
+            if (ioThread == null) {
+                try {
+                    ioThread = new VsimIoThread(
+                            SERVER_NAME,
+                            mSocket.getInputStream(),
+                            mSocket.getOutputStream(),
+                            eventHandler);
+                    ioThread.start();
+                } catch (IOException e) {
+                    Rlog.d(TAG, "getIoThread catch IOException");
+                    e.printStackTrace();
+                }
+             }
+            return ioThread;
+        }
+    }
+
+    public class ConnectionHandler implements Runnable {
+        private LocalSocket mSocket;
+        //private RilClientTask mRilSocket;
+        private VsimEvenHandler mEventHandler;
+        public static final String RILD_SERVER_NAME = "rild-vsim";
+
+        public ConnectionHandler(LocalSocket clientSocket, VsimEvenHandler eventHandler) {
+            mSocket = clientSocket;
+            mEventHandler = eventHandler;
+        }
+
+        /* (non-Javadoc)
+         * @see java.lang.Runnable#run()
+         */
+        @Override
+        public void run() {
+            Rlog.d(TAG, "New connection: " + mSocket.toString());
+
+            try {
+                //mRilSocket = new RilClientTask();
+                //mRilSocket.connectToServer();
+
+                VsimIoThread ioThread = new VsimIoThread(
+                        ServerTask.HOST_NAME,
+                        mSocket.getInputStream(),
+                        mSocket.getOutputStream(),
+                        mEventHandler);
+                ioThread.start();
+
+                if (mRilIoThread == null) {
+                    mRilIoThread = new VsimIoThread(
+                            RILD_SERVER_NAME,
+                            RILD_SERVER_NAME,
+                            mEventHandler);
+                    mRilIoThread.start();
+                }
+
+                mEventHandler.setDataStream(ioThread, mRilIoThread);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static class VsimEvent {
+        public static final int DEFAULT_MAX_DATA_LENGTH = 20480;
+        private int mTransactionId;
+        private int mMessageId;
+        private int mSlotId;
+        private int mDataLen;
+        private int mReadOffset;
+        private byte mData[];
+        private int mEventMaxDataLen = DEFAULT_MAX_DATA_LENGTH;
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         */
+        public VsimEvent(int transactionId, int messageId) {
+            this(transactionId, messageId, 0);
+        }
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         * @param slotId the indicated slotId
+         */
+        public VsimEvent(int transactionId, int messageId, int slotId) {
+            this(transactionId, messageId, DEFAULT_MAX_DATA_LENGTH, slotId);
+        }
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         * @param length the max data length of the event
+         * @param slotId the indicated slotId
+         */
+        public VsimEvent(int transactionId, int messageId, int length, int slotId) {
+            mTransactionId = transactionId;
+            mMessageId = messageId;
+            mSlotId = slotId;
+            mEventMaxDataLen = length;
+            mData = new byte[mEventMaxDataLen];
+            mDataLen = 0;
+            mReadOffset = 0;
+        }
+
+        public int putInt(int value) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - 4) {
+                    return -1;
+                }
+
+                for (int i = 0 ; i < 4 ; ++i) {
+                    mData[mDataLen] = (byte) ((value >> (8 * i)) & 0xFF);
+                    mDataLen++;
+                }
+            }
+            return 0;
+        }
+
+        public int putShort(int value) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - 2) {
+                    return -1;
+                }
+
+                for (int i = 0 ; i < 2 ; ++i) {
+                    mData[mDataLen] = (byte) ((value >> (8 * i)) & 0xFF);
+                    mDataLen++;
+                }
+            }
+            return 0;
+        }
+
+        public int putByte(int value) {
+            if (mDataLen > mEventMaxDataLen - 1) {
+                return -1;
+            }
+
+            synchronized (this) {
+                mData[mDataLen] = (byte) (value & 0xFF);
+                mDataLen++;
+            }
+            return 0;
+        }
+
+        public int putString(String str, int len) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - len) {
+                    return -1;
+                }
+
+                byte s[] = str.getBytes();
+                if (len < str.length()) {
+                    System.arraycopy(s, 0, mData, mDataLen, len);
+                    mDataLen += len;
+                } else {
+                    int remain = len - str.length();
+                    System.arraycopy(s, 0, mData, mDataLen, str.length());
+                    mDataLen += str.length();
+                    for (int i = 0 ; i < remain ; i++) {
+                        mData[mDataLen] = 0;
+                        mDataLen++;
+                    }
+                }
+            }
+            return 0;
+        }
+
+        public int putBytes(byte [] value) {
+            synchronized (this) {
+                int len = value.length;
+
+                if (len > mEventMaxDataLen) {
+                    return -1;
+                }
+
+                System.arraycopy(value, 0, mData, mDataLen, len);
+                mDataLen += len;
+            }
+            return 0;
+        }
+
+        public int putCapability(int multiSim, int vsimSupported, int allowedSlots) {
+            if (mDataLen > mEventMaxDataLen - (4 * 4)) {
+                return -1;
+            }
+
+            putInt(1);  //valid capablity
+            putInt(multiSim);
+            putInt(vsimSupported);
+            putInt(allowedSlots);
+            return 0;
+        }
+
+        public int putPaddingCapability(){
+            if (mDataLen > mEventMaxDataLen - (4 * 4)) {
+                return -1;
+            }
+
+            putInt(0);  //valid capablity
+            putInt(0);  //multi Sim
+            putInt(0);  //vsim supported flag
+            putInt(0);  //allowed sim slots
+            return 0;
+        }
+
+        public int putUiccCommand(int commandLen, byte[] command) {
+            if (mDataLen > mEventMaxDataLen - (4 * 3)) {
+                return -1;
+            }
+
+            putInt(1);  //valid uicc request command
+            putInt(commandLen);
+            putBytes(command);
+            return 0;
+        }
+
+        public int putPaddingUiccCommand(){
+            if (mDataLen > mEventMaxDataLen - (4 * 3)) {
+                return -1;
+            }
+
+            putInt(1);  //valid uicc request command
+            putInt(0);  //command len
+            //putBytes(command);
+            return 0;
+        }
+
+        public byte [] getData() {
+            byte tempData[] = new byte[mDataLen];
+            System.arraycopy(mData, 0, tempData, 0, mDataLen);
+            return tempData;
+        }
+
+        public int getDataLen() {
+            return mDataLen;
+        }
+
+        public int getMessageId() {
+            return mMessageId;
+        }
+
+        /*
+         * Return slot bit mask.
+         * 1 means slot0,
+         * 2 means slot1,
+         * 3 means slot 0 and slot 1.
+         */
+        public int getSlotBitMask() {
+            return mSlotId;
+        }
+
+        /*
+         * Return the first mapping slot of slot bit mask value.
+         */
+        public int getFirstSlotId() {
+            int simCount = TelephonyManager.getDefault().getSimCount();
+            for (int i = 0; i < simCount; i++) {
+                if ((getSlotBitMask() & (1 << i)) != 0) {
+                    Rlog.d(TAG, "getFirstSlotId, slotId = " + i
+                            + ", slot bit mapping = " + getSlotBitMask());
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        public int getTransactionId() {
+            return mTransactionId;
+        }
+
+        public int getInt() {
+            int ret = 0;
+            synchronized (this) {
+                if (mData.length >= 4) {
+                    ret = ((mData[mReadOffset + 3] & 0xff) << 24 |
+                           (mData[mReadOffset + 2] & 0xff) << 16 |
+                        (mData[mReadOffset + 1] & 0xff) << 8 |
+                        (mData[mReadOffset] & 0xff));
+                    mReadOffset += 4;
+                }
+            }
+            return ret;
+        }
+
+        public int getShort() {
+            int ret = 0;
+            synchronized (this) {
+                ret =  ((mData[mReadOffset + 1] & 0xff) << 8 | (mData[mReadOffset] & 0xff));
+                mReadOffset += 2;
+            }
+            return ret;
+        }
+
+        // Notice: getByte is to get int8 type from VA, not get one byte.
+        public int getByte() {
+            int ret = 0;
+            synchronized (this) {
+                ret = (mData[mReadOffset] & 0xff);
+                mReadOffset += 1;
+            }
+            return ret;
+        }
+
+        public byte[] getBytes(int length) {
+            synchronized (this) {
+                if (length > mDataLen - mReadOffset) {
+                    return null;
+                }
+
+                byte[] ret = new byte[length];
+
+                for (int i = 0 ; i < length ; i++) {
+                    ret[i] = mData[mReadOffset];
+                    mReadOffset++;
+                }
+                return ret;
+            }
+        }
+
+        public String getString(int len) {
+            byte buf [] = new byte[len];
+
+            synchronized (this) {
+                System.arraycopy(mData, mReadOffset, buf, 0, len);
+                mReadOffset += len;
+            }
+
+            return (new String(buf)).trim();
+        }
+    }
+
+
+    class VsimIoThread extends Thread {
+        private String mName = "";
+        private static final int MAX_DATA_LENGTH = (20 * 1024);
+        private DataInputStream mInput = null;
+        private DataOutputStream mOutput = null;
+        private VsimEvenHandler mEventHandler = null;
+        private LocalSocket mSocket = null;
+        private String mServerName = "";
+
+        private byte[] readBuffer = null;
+
+        public VsimIoThread(
+                String name,
+                InputStream inputStream,
+                OutputStream outputStream,
+                VsimEvenHandler eventHandler) {
+            mName = name;
+            mInput = new DataInputStream(inputStream);
+            mOutput = new DataOutputStream(outputStream);
+            mEventHandler = eventHandler;
+            log("VsimIoThread constructor is called.");
+        }
+
+        public VsimIoThread(String name, String serverName, VsimEvenHandler eventHandler) {
+            mServerName = serverName;
+            createClientSocket(mServerName);
+            mName = name;
+            mEventHandler = eventHandler;
+            log("VsimIoThread constructor with creating socket is called.");
+        }
+
+        private void createClientSocket(String serverName) {
+            int retryCount = 0;
+            log("createClientSocket() - start");
+            while (retryCount < 10) {
+                try {
+                    log("createClientSocket() - before, serverName: " + serverName);
+
+                    mSocket = new LocalSocket();
+                    LocalSocketAddress addr = new LocalSocketAddress(serverName,
+                            LocalSocketAddress.Namespace.RESERVED);
+
+                    mSocket.connect(addr);
+
+                    mInput = new DataInputStream(mSocket.getInputStream());
+                    mOutput = new DataOutputStream(mSocket.getOutputStream());
+
+                    log("createClientSocket() - after, mSocket:" + mSocket.toString());
+                } catch (IOException e) {
+                    log("createClientSocket catch IOException");
+                    e.printStackTrace();
+
+                    if (mSocket != null && !mSocket.isConnected()) {
+                        retryCount++;
+                        try {
+                            mSocket.close();
+                            mSocket = null;
+                            Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                        } catch (InterruptedException e1) {
+                            e1.printStackTrace();
+                        } catch (IOException e2) {
+                            e2.printStackTrace();
+                        }
+                        log("createClientSocket retry later, retry count: " + retryCount);
+                    }
+                }
+
+                if (mSocket != null && mSocket.isConnected()) {
+                    log("createClientSocket connected!");
+                    break;
+                }
+            }
+            log("createClientSocket() - end");
+        }
+
+        public void closeSocket() {
+            try {
+                if (mSocket != null) {
+                    mSocket.close();
+                    mSocket = null;
+                    log("closeSocket.");
+                }
+            } catch (IOException e) {
+                log("closeSocket IOException.");
+                e.printStackTrace();
+            }
+        }
+
+        public void run() {
+            log("VsimIoThread running.");
+            while(true) {
+                try {
+                    //if (mInput.available() > 0) {
+                        VsimEvent event = readEvent();
+                        // Need to handle the event
+                        if (event != null) {
+                            Message msg = new Message();
+                            msg.obj = event;
+                            mEventHandler.sendMessage(msg);
+                        }
+                    //} else if (!mSocket.isConnected()){
+                    //    log("VsimIoThread mSocket is disconnected!");
+                    //}
+                } catch (IOException e) {
+                    log("VsimIoThread IOException.");
+                    e.printStackTrace();
+
+                    // To avoid server socket is closed due to modem reset
+                    try {
+
+                        if (mSocket != null) {
+                            mSocket.close();
+                            mSocket = null;
+                        }
+
+                        if (!mServerName.equals("")) {
+                            createClientSocket(mServerName);
+                        } else {
+                            // Means the client socket has been disconnected.
+                            // We shall close the socket and waiting for the new connection.
+                            log("Ingore exception");
+                            return;
+                        }
+                    } catch (IOException e2) {
+                        log("VsimIoThread IOException 2.");
+                        e2.printStackTrace();
+                    }
+                } catch (Exception e) {
+                    log("VsimIoThread Exception.");
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        private void writeBytes(byte [] value, int len) throws IOException {
+            mOutput.write(value, 0, len);
+        }
+
+        private void writeInt(int value) throws IOException {
+            for (int i = 0 ; i < 4 ; ++i) {
+                mOutput.write((value >> (8 * i)) & 0xff);
+            }
+        }
+
+        public int writeEvent(VsimEvent event) {
+            return writeEvent(event, false);
+        }
+
+        public int writeEvent(VsimEvent event, boolean isBigEndian) {
+            log("writeEvent Enter, isBigEndian:" + isBigEndian);
+            int ret = -1;
+            try {
+                synchronized (this) {
+                    if (mOutput != null) {
+                        dumpEvent(event);
+
+                        writeInt(event.getTransactionId());
+                        writeInt(event.getMessageId());
+                        // Platfrom slot id start from 0, so need to add 1.
+                        writeInt(event.getSlotBitMask());
+                        writeInt(event.getDataLen());
+                        writeBytes(event.getData(), event.getDataLen());
+                        mOutput.flush();
+                        ret = 0;
+                    } else {
+                        log("mOut is null, socket is not setup");
+                    }
+                }
+            } catch (Exception e) {
+                log("writeEvent Exception");
+                e.printStackTrace();
+                return -1;
+            }
+
+            return ret;
+        }
+
+        /**
+         * DataInputStream's readInt is Big-Endian method.
+         */
+        private int readInt() throws IOException {
+            byte[] tempBuf = new byte[8];
+            int readCount = mInput.read(tempBuf, 0, 4);
+            if (readCount < 0) {
+                log("readInt(), fail to read and throw exception");
+                throw new IOException("fail to read");
+            }
+            //log("[readInt] after readFully");
+            return ((tempBuf[3]) << 24 |
+                    (tempBuf[2] & 0xff) << 16 |
+                    (tempBuf[1] & 0xff) << 8 |
+                    (tempBuf[0] & 0xff));
+        }
+
+        private VsimEvent readEvent() throws IOException {
+            log("readEvent Enter");
+
+            int transaction_id = readInt();
+            int msg_id = readInt();
+            int slot_id = readInt();
+            int data_len = readInt();
+            log("readEvent transaction_id: " + transaction_id +
+                    ", msgId: " + msg_id + ", slot_id: " + slot_id + ", len: " + data_len);
+
+            readBuffer = new byte[data_len];
+
+            int offset = 0;
+            int remaining = data_len;
+
+            do {
+                int countRead = mInput.read(readBuffer, offset, remaining);
+
+                if (countRead < 0) {
+                    log("readEvent(), fail to read and throw exception");
+                    throw new IOException("fail to read");
+                }
+
+                offset += countRead;
+                remaining -= countRead;
+            } while (remaining > 0);
+
+            VsimEvent event = new VsimEvent(transaction_id, msg_id, data_len, slot_id);
+            event.putBytes(readBuffer);
+
+            dumpEvent(event);
+            return event;
+        }
+
+        private void dumpEvent(VsimEvent event) {
+            log("dumpEvent: transaction_id: " + event.getTransactionId()
+                    + ", message_id:" + event.getMessageId()
+                    + ", slot_id:" + event.getSlotBitMask()
+                    + ", data_len:" + event.getDataLen()
+                    + ", event:" + IccUtils.bytesToHexString(event.getData()));
+        }
+
+        private void log(String s) {
+            Rlog.d(TAG, "[" + mName + "] " + s);
+        }
+    }
+
+
+    public class VsimEvenHandler extends Handler {
+        private VsimIoThread mVsimAdaptorIo = null;
+        private VsimIoThread mVsimRilIo = null;
+        private boolean mHasNotifyEnableEvnetToModem = false;
+
+        @Override
+        public void handleMessage(Message msg) {
+            dispatchCallback((VsimEvent) msg.obj);
+        }
+
+        private void setDataStream(VsimIoThread vsimAdpatorIo, VsimIoThread vsimRilIo) {
+            mVsimAdaptorIo = vsimAdpatorIo;
+            mVsimRilIo = vsimRilIo;
+            Rlog.d(TAG, "VsimEvenHandler setDataStream done.");
+        }
+
+        private void setMdWaitingFlag(boolean isWaiting) {
+            Rlog.d(TAG, "setMdWaitingFlag: " + isWaiting);
+            isMdWaitingResponse = isWaiting;
+        }
+
+        private boolean getMdWaitingFlag() {
+            Rlog.d(TAG, "getMdWaitingFlag: " + isMdWaitingResponse);
+            return isMdWaitingResponse;
+        }
+
+        private void handleEventRequest(int type, VsimEvent event) {
+            Rlog.d(TAG, "VsimEvenHandler eventHandlerByType: type[" + type + "] start");
+
+            // Get external SIM slot id
+            int slotId = event.getFirstSlotId();
+            // Get if a local SIM (local SIM mean no need to download SIM data from server)
+            int simType = event.getInt();
+            // Response result
+            int result = ExternalSimConstants.RESPONSE_RESULT_OK;
+
+            Rlog.d(TAG, "VsimEvenHandler First slotId:" + slotId + ", simType:" + simType);
+
+            switch (type) {
+                case ExternalSimConstants.REQUEST_TYPE_ENABLE_EXTERNAL_SIM: {
+                    // set result according to sub ready state
+                    if (SubscriptionController.getInstance().isReady()) {
+                        result = ExternalSimConstants.RESPONSE_RESULT_OK;
+                    } else {
+                        result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+                    }
+
+                    // 1.set default data sub id without capablity swtich to VSIM slot
+                    int subId = SubscriptionManager.getSubIdUsingPhoneId(slotId);
+                    SubscriptionController ctrl = SubscriptionController.getInstance();
+
+                    if (simType != ExternalSimConstants.SIM_TYPE_LOCAL_SIM) {
+                        // MTK TODO
+                        // ctrl.setDefaultDataSubIdWithoutCapabilitySwitch(subId);
+
+                        Rlog.d(TAG, "VsimEvenHandler set default data to subId: " + subId);
+                    }
+                    // set system property to note that sim enabled
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "1");
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_DISABLE_EXTERNAL_SIM: {
+                    // 1.set system property to note that sim enabled
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "0");
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    // 2.send event to modem side, will reset in rild side
+                    // FIXME: C2K project need to reset modem on both modem, so we can't
+                    // reset modem on gsm rild.
+                    mVsimRilIo.writeEvent(event);
+
+                    // 3. set modem waiting flag to false to drop the following uncompleted APDU
+                    //    or RESET request.
+                    setMdWaitingFlag(false);
+
+                    RadioManager.getInstance().setSilentRebootPropertyForAllModem("1");
+                    // MTK TODO
+                    // UiccController.getInstance().resetRadioForVsim();
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_PLUG_IN: {
+                     // 1.write shared prefrence/system property to record vsim availble event.
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED,
+                            String.valueOf(simType));
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, "persist.radio.external.sim",
+                            String.valueOf(simType));
+                    // 2.capability switch or reset modem with set VSIM on
+                    SubscriptionController ctrl = SubscriptionController.getInstance();
+                    int mCPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+                    //int mCSubId = ctrl.getSubIdUsingPhoneId(mCPhoneId);
+                    //int[] mTSubId = ctrl.getSubId(slotId);
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                        if (mCPhoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+                            mCPhoneId = PhoneConstants.SIM_ID_1;
+                        }
+                        if (mCPhoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+                            mCPhoneId = PhoneConstants.SIM_ID_2;
+                        }
+                    }
+
+                    if (slotId == mCPhoneId) {
+                        // Send event to rild which will reset modem in rild side.
+                        Rlog.d(TAG, "VsimEvenHandler no need to do capablity switch");
+                        mVsimRilIo.writeEvent(event);
+                        RadioManager.getInstance().setSilentRebootPropertyForAllModem("1");
+                        // MTK TODO
+                        // UiccController.getInstance().resetRadioForVsim();
+                    } else {
+                        // set result according to sub ready state
+                        Rlog.d(TAG, "VsimEvenHandler need to do capablity switch");
+                        if (SubscriptionController.getInstance().isReady()) {
+                            // Capbility switch will reset modem
+                            int subId = SubscriptionManager.getSubIdUsingPhoneId(slotId);
+                            SubscriptionController.getInstance().setDefaultDataSubId(subId);
+                            result = ExternalSimConstants.RESPONSE_RESULT_OK;
+                        } else {
+                            result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+                        }
+                    }
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_PLUG_OUT: {
+                    // 1.write shared prefrence/system property to record vsim unavailble event.
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+                    // 2.send event to modem side
+                    mVsimRilIo.writeEvent(event);
+
+                    // 3. set modem waiting flag to false to drop the following uncompleted APDU
+                    //    or RESET request.
+                    setMdWaitingFlag(false);
+                    break;
+                }
+            }
+
+            VsimEvent eventResponse = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_EVENT_RESPONSE, event.getSlotBitMask());
+            eventResponse.putInt(result);  //result
+            mVsimAdaptorIo.writeEvent(eventResponse);
+
+            Rlog.d(TAG, "VsimEvenHandler eventHandlerByType: type[" + type + "] end");
+        }
+
+        private void handleGetPlatformCapability(VsimEvent event) {
+            int eventId = event.getInt();   //no-used
+            int simType = event.getInt();
+
+            VsimEvent response = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_GET_PLATFORM_CAPABILITY_RESPONSE,
+                    event.getSlotBitMask());
+            // 1. Put result value to check platform ready
+            if (SubscriptionController.getInstance().isReady()) {
+                response.putInt(ExternalSimConstants.RESPONSE_RESULT_OK);
+            } else {
+                response.putInt(ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY);
+            }
+
+            // 2.1 Return multi-phone type, such as dsds or dsda.
+            MultiSimVariants config = TelephonyManager.getDefault().getMultiSimConfiguration();
+            if (config == MultiSimVariants.DSDS) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_DSDS);
+            } else if (config == MultiSimVariants.DSDA) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_DSDA);
+            } else if (config == MultiSimVariants.TSTS) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_TSTS);
+            } else {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_UNKNOWN);
+            }
+
+            // 2.2 Return external SIM support flag (refer to feature option)
+            response.putInt(SystemProperties.getInt("ro.mtk_external_sim_support", 0));
+
+            // 2.3 Return slots allow to enable external SIM.
+            // The value is bit-mask, bit X means the slot (X - 1) is allowed to use external
+            // SIM. For an example, value 3 is bit 1 and 2 is 1 means external SIM is allowed
+            // to enable on slot 1 and slot 0.
+            int simCount = TelephonyManager.getDefault().getSimCount();
+
+            Rlog.d(TAG, "handleGetPlatformCapability simType: " + simType
+                    + ", simCount: " + simCount);
+
+            if (simType == ExternalSimConstants.SIM_TYPE_LOCAL_SIM) {
+                response.putInt((1 << simCount) - 1);
+            } else {
+                if (config == MultiSimVariants.DSDA) {
+                    int isCdmaCard = 0;
+                    int isHasCard = 0;
+
+                    for (int i = 0; i < simCount; i++) {
+                        String cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[i], "");
+                        if (!cardType.equals("")) {
+                            isHasCard |= (1 << i);
+                        }
+
+                        if (cardType.contains("CSIM")
+                                || cardType.contains("RUIM") || cardType.contains("UIM")) {
+                            isCdmaCard |= (1 << i);
+                        }
+                    }
+
+                    Rlog.d(TAG, "handleGetPlatformCapability isCdmaCard: " + isCdmaCard
+                            + ", isHasCard: " + isHasCard);
+
+                    if (isHasCard == 0) {
+                        // DSDA project and there is no card is inserted.
+                        response.putInt(0);
+                    } else if (isCdmaCard == 0) {
+                        // DSDA project and there is no C card is inserted.
+                        response.putInt(0);
+                    } else {
+                        // DSDA project and there is a C card is inserted.
+                        response.putInt(isCdmaCard ^ ((1 << simCount) - 1));
+                    }
+
+                } else {
+                    // Non-DSDA project and it is not local SIM.
+                    // In this case, we could enable external SIM.
+                    response.putInt(0);
+                }
+            }
+
+            // Write response event by socket
+            mVsimAdaptorIo.writeEvent(response);
+        }
+
+        private void handleServiceStateRequest(VsimEvent event) {
+            int result = ExternalSimConstants.RESPONSE_RESULT_OK;
+            int voiceRejectCause = -1;
+            int dataRejectCause = -1;
+
+            VsimEvent response = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_GET_SERVICE_STATE_RESPONSE,
+                    event.getSlotBitMask());
+            if (SubscriptionController.getInstance().isReady()) {
+                ITelephonyEx telEx = ITelephonyEx.Stub.asInterface(
+                        ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+                if (telEx == null) {
+                    try {
+                        int subId = SubscriptionManager.getSubIdUsingPhoneId(
+                                event.getFirstSlotId());
+                        Bundle bundle = telEx.getServiceState(subId);
+                        ServiceState ss = ServiceState.newFromBundle(bundle);
+                        Rlog.d(TAG, "handleServiceStateRequest subId: " + subId +
+                                ", ss = " + ss.toString());
+                        voiceRejectCause = ss.getVoiceRejectCause();
+                        dataRejectCause = ss.getDataRejectCause();
+                    } catch (RemoteException e) {
+                        Rlog.d(TAG, "RemoteException!!");
+                        result = ExternalSimConstants.RESPONSE_RESULT_GENERIC_ERROR;
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+            }
+
+            //Put response result
+            response.putInt(result);
+            //Put voice reject cause
+            response.putInt(voiceRejectCause);
+            //Put data reject cause
+            response.putInt(dataRejectCause);
+
+            mVsimAdaptorIo.writeEvent(response);
+        }
+
+        /* dispatch Callback */
+        private void dispatchCallback(VsimEvent event) {
+            // Handler events
+            int msgId = event.getMessageId();
+
+            Rlog.d(TAG, "VsimEvenHandler handleMessage: msgId[" + msgId + "]");
+
+            switch (msgId) {
+                case ExternalSimConstants.MSG_ID_INITIALIZATION_REQUEST:
+                    // Customized: allow to do neccessary initialization related to external SIM.
+                    // For an example, start an indicated service or set some configuration.
+                    break;
+
+                case ExternalSimConstants.MSG_ID_FINALIZATION_REQUEST:
+                    // Customized: allow to do neccessary finalization related to external SIM.
+                    // For an example, stop an indicated service or set some configuration.
+                    break;
+
+                case ExternalSimConstants.MSG_ID_GET_PLATFORM_CAPABILITY_REQUEST:
+                    handleGetPlatformCapability(event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_EVENT_REQUEST:
+                    handleEventRequest(event.getInt(), event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_EVENT_RESPONSE:
+                    // Is need to return from modem???
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_APDU_REQUEST: {
+                    setMdWaitingFlag(true);
+                    // Reguest from modem side, just adjust format and dispatch the event
+
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_APDU_RESPONSE:
+                    if (getMdWaitingFlag()) {
+                        // If modem waiting flag is set to flag, mean that, there might
+                        // be a plug out event during waiting response.
+                        // In this case, AP should drop this event to avoid modem receive
+                        // unexcepted event.
+                        // If the waiting flag is true,
+                        // just send to modem side without parsing data.
+                        mVsimRilIo.writeEvent(event);
+                        setMdWaitingFlag(false);
+                    }
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_RESET_REQUEST: {
+                    setMdWaitingFlag(true);
+                    // Reguest from modem side, just adjust format and dispatch the event
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_RESET_RESPONSE:
+                    if (getMdWaitingFlag()) {
+                        // If modem waiting flag is set to flag, mean that, there might
+                        // be a plug out event during waiting response.
+                        // In this case, AP should drop this event to avoid modem receive
+                        // unexcepted event.
+                        // If the waiting flag is true,
+                        // just send to modem side without parsing data.
+                        mVsimRilIo.writeEvent(event);
+                        setMdWaitingFlag(false);
+                    }
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_POWER_DOWN_REQUEST: {
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_POWER_DOWN_RESPONSE:
+                    mVsimRilIo.writeEvent(event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_GET_SERVICE_STATE_REQUEST:
+                    handleServiceStateRequest(event);
+                    break;
+                default:
+                    Rlog.d(TAG, "VsimEvenHandler handleMessage: default");
+            }
+        }
+    }
+}
+
diff --git a/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java b/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
new file mode 100755
index 0000000..31c87e7
--- /dev/null
+++ b/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
@@ -0,0 +1,2431 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.telephony;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+import android.text.Editable;
+import android.text.SpannableStringBuilder;
+import android.text.Selection;
+import android.telephony.Rlog;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import com.android.internal.telephony.PhoneConstants;
+
+
+/**
+ * MediaTek Phone Number Format Tool.
+ * There are 22 country&region supported.
+ *
+ * Country&Region   Code
+ *
+ * China Mainland   +86
+ * China Taiwan     +886
+ * China Honkong    +852
+ * China Macao      +853
+ * England          +44
+ *  France          +33
+ *  Italy           +39
+ *  Germany         +39
+ *  Russian         +7
+ *  India           +91
+ *  Spain           +34
+ *  Malaysia        +60
+ *  Singapore       +65
+ *  Indonesia       +62
+ *  Thailand        +66
+ *  Vietnam         +84
+ *  Portugal        +351
+ *  Poland          +48
+ *  Australia       +61
+ *  New Zealand     +64
+ *  Brazil          +55
+ *  Turkey          +90
+ *  @hide
+ */
+public class PhoneNumberFormatUtilEx {
+
+    public static final String TAG = "PhoneNumberFormatUtilEx";
+    public static final boolean DEBUG = false;
+    /**
+     *  List of country codes for countries that use the NANP
+     *  Need to SYNC google default PhoneNumberUtils if changes
+     */
+    private static final String[] NANP_COUNTRIES = new String[] {
+        "US", // United States
+        "CA", // Canada
+        "AS", // American Samoa
+        "AI", // Anguilla
+        "AG", // Antigua and Barbuda
+        "BS", // Bahamas
+        "BB", // Barbados
+        "BM", // Bermuda
+        "VG", // British Virgin Islands
+        "KY", // Cayman Islands
+        "DM", // Dominica
+        "DO", // Dominican Republic
+        "GD", // Grenada
+        "GU", // Guam
+        "JM", // Jamaica
+        "PR", // Puerto Rico
+        "MS", // Montserrat
+        "MP", // Northern Mariana Islands
+        "KN", // Saint Kitts and Nevis
+        "LC", // Saint Lucia
+        "VC", // Saint Vincent and the Grenadines
+        "TT", // Trinidad and Tobago
+        "TC", // Turks and Caicos Islands
+        "VI", // U.S. Virgin Islands
+    };
+
+    /** The current locale is unknown, look for a country code or don't format */
+    public static final int FORMAT_UNKNOWN = 0;
+    /** NANP formatting */
+    public static final int FORMAT_NANP = 1;
+    public static final String[] NANP_INTERNATIONAL_PREFIXS = {"011"};
+    /** Japanese formatting */
+    public static final int FORMAT_JAPAN = 2;
+    public static final String[] JAPAN_INTERNATIONAL_PREFIXS = {"010", "001", "0041", "0061"};
+    /**
+     * China mainland +86 or 0086
+     */
+    public static final int FORMAT_CHINA_MAINLAND = 3;
+    /**
+     * China Hongkong +852 or 00852
+     */
+    public static final int FORMAT_CHINA_HONGKONG = 4;
+
+    /**
+     * it comes from "http://www.chahaoba.com/%E9%A6%99%E6%B8%AF"
+     */
+    public static final String[] HONGKONG_INTERNATIONAL_PREFIXS = {"001", "0080", "0082", "009"};
+
+    /**
+     * China MACAU +853 or 00853
+     */
+    public static final int FORMAT_CHINA_MACAU = 5;
+
+    /**
+     * TAIWAN +886
+     */
+    public static final int FORMAT_TAIWAN = 6;
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Taiwan"
+     */
+    public static final String[] TAIWAN_INTERNATIONAL_PREFIXS = {"002", "005", "006", "007", "009", "019"};
+
+    public static final int FORMAT_ENGLAND = 7;
+
+    public static final int FORMAT_FRANCE = 8;
+    /**
+     * it comes from "http://countrycode.org/france"
+     */
+    public static final String[] FRANCE_INTERNATIONAL_PREFIXS = {"00", "40", "50", "70", "90"};
+
+    public static final int FORMAT_ITALY = 9;
+
+    public static final int FORMAT_GERMANY = 10;
+
+    public static final int FORMAT_RUSSIAN = 11;
+    //TODO RUSSIAN INTERNATIONAL PREFIXS
+
+
+    public static final int FORMAT_INDIA = 12;
+
+    public static final int FORMAT_SPAIN = 13;
+
+    public static final int FORMAT_MALAYSIA = 14;
+
+    public static final int FORMAT_SINGAPORE = 15;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Singapore"
+     */
+    public static final String[] SINGAPORE_INTERNATIONAL_PREFIXS = {"001", "002", "008", "012", "013", "018", "019"};
+
+    public static final int FORMAT_INDONESIA = 16;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Indonesia"
+     */
+    public static final String[] INDONESIA_INTERNATIONAL_PREFIXS = {"001", "007", "008", "009"};
+
+    public static final int FORMAT_THAILAND = 17;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Thailand"
+     */
+    public static final String[] THAILAND_INTERNATIONAL_PREFIXS = {"001", "004", "005", "006", "007", "008", "009"};
+
+    public static final int FORMAT_VIETNAM = 18;
+
+    public static final int FORMAT_PORTUGAL = 19;
+
+    public static final int FORMAT_POLAND = 20;
+
+    public static final int FORMAT_AUSTRALIA = 21;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Australia"
+     */
+    public static final String[] AUSTRALIA_INTERNATIONAL_PREFIXS = {"0011", "0014", "0015", "0016", "0018", "0019"};
+
+    public static final int FORMAT_NEW_ZEALAND = 22;
+
+
+    public static final int FORMAT_BRAZIL = 23;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Brazil"
+     */
+    public static final String[] BRAZIL_INTERNATIONAL_PREFIXS = {"0012", "0014", "0015", "0021", "0023", "0025", "0031", "0041"};
+
+    public static final int FORMAT_TURKEY = 24;
+
+    /**
+     * ***Warning****
+     * this country code array index matches FORMAT_XXXXX - 1.
+     * so if you add value, you must add new FORMAT_XXXXX, and the index still matches it.
+     */
+    public static String[] FORMAT_COUNTRY_CODES = {
+        "1",    "81",   "86",   "852",  "853",  "886", "44",
+        "33",   "39",   "49",   "7",    "91",   "34",  "60",
+        "65",   "62",   "66",   "84",   "351",  "48",  "61",
+        "64",   "55",   "90",
+    };
+
+    /**
+     * the country Alpha-2.
+     * reference: "http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2"
+     * ****Warning****
+     * this names match FORMAT_COUNTRY_CODES, and the index is also FORMAT_XXXXX - 1.
+     * so if you add value, you must add new FORMAT_XXXXX, and the index still matches it.
+     */
+    public static final String[] FORMAT_COUNTRY_NAMES = {
+        "US",   "JP",   "CN",   "HK",   "MO",   "TW",   "GB",
+        "FR",   "IT",   "DE",   "RU",   "IN",   "ES",   "MY",
+        "SG",   "ID",   "TH",   "VN",   "PT",   "PL",   "AU",
+        "NZ",   "BR",   "TR",
+    };
+
+    /**
+     * Returns the phone number formatting type for the given locale.
+     *
+     * @param locale The locale of interest, usually {@link Locale#getDefault()}
+     * @return The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting
+     * rules are not known for the given locale
+     * @hide
+     */
+    public static int getFormatTypeForLocale(Locale locale) {
+//        String country = locale.getCountry();
+        String simIso = getDefaultSimCountryIso();
+        log("getFormatTypeForLocale Get sim sio:" + simIso);
+        return getFormatTypeFromCountryCode(simIso);
+    }
+
+    /**
+     * Get default sim country ISO.
+     * If the system is GEMINI System, the sim card is default sim, else the sim card is sim1; if the default sim is not inserted, select other sim.
+     *
+     * Returns the ISO country code equivalent for the SIM provider's country code.
+     * @return
+     */
+    /*package*/static String getDefaultSimCountryIso() {
+       int simId;
+       String iso = null;
+       if ("1".equals(SystemProperties.get("ro.mtk_gemini_support"))) {
+            simId = -1; //SystemProperties.getInt(PhoneConstants.GEMINI_DEFAULT_SIM_PROP, -1);
+             if (simId == -1) { // No default sim setting
+                 simId = PhoneConstants.SIM_ID_1;
+             }
+             if (!TelephonyManagerEx.getDefault().hasIccCard(simId)) {
+                 //simId = Phone.GEMINI_SIM_2 ^ simId;
+                 if (TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_1)) {
+                     simId = PhoneConstants.SIM_ID_1;
+                 } else if (TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_2)) {
+                     simId = PhoneConstants.SIM_ID_2;
+                 } else if (TelephonyManager.getDefault().getPhoneCount() >= 3 && TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_3)) {
+                     simId = PhoneConstants.SIM_ID_3;
+                 } else if (TelephonyManager.getDefault().getPhoneCount() >= 4 && TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_4)) {
+                     simId = PhoneConstants.SIM_ID_4;
+                 }
+             }
+             iso = TelephonyManagerEx.getDefault().getSimCountryIso(simId);
+       } else {
+           iso = TelephonyManager.getDefault().getSimCountryIso();
+       }
+       return iso;
+    }
+
+
+   private static int getFormatTypeFromCountryCodeInternal(String country) {
+        // Check for the NANP countries
+        int length = NANP_COUNTRIES.length;
+        for (int i = 0; i < length; i++) {
+            if (NANP_COUNTRIES[i].compareToIgnoreCase(country) == 0) {
+                return FORMAT_NANP;
+            }
+        }
+        if ("jp".compareToIgnoreCase(country) == 0) {
+            return FORMAT_JAPAN;
+        }
+        return FORMAT_UNKNOWN;
+    }
+    /**
+     * MediaTek extension for getting format type from country code.
+     * @param  country Country code.
+     * @return Return format type according to country parameter.
+     * @hide
+     */
+    public static int getFormatTypeFromCountryCode(String country) {
+        int type = FORMAT_UNKNOWN;
+        if (country != null && country.length() != 0) {
+            type = getFormatTypeFromCountryCodeInternal(country);
+//          type = PhoneNumberUtils.getFormatTypeFromCountryCode(country);
+            if (type == FORMAT_UNKNOWN) {
+                int index = 0;
+                for (String name : FORMAT_COUNTRY_NAMES) {
+                    index++;
+                    if (name.compareToIgnoreCase(country) == 0) {
+                        type = index;
+                        break;
+                    }
+                }
+                //for UK. which has two iso code
+                if (type == FORMAT_UNKNOWN && "UK".compareToIgnoreCase(country) == 0) {
+                    type = FORMAT_ENGLAND;
+                }
+            }
+        }
+        log("Get Format Type:" + type);
+        return type;
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @hide
+     */
+    public static String formatNumber(String source) {
+        Locale sCachedLocale;
+        sCachedLocale = Locale.getDefault();
+        return formatNumber(source, getFormatTypeForLocale(sCachedLocale));
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @param defaultFormattingType
+     * @hide
+     */
+//   public static void formatNumber(Editable text, int defaultFormattingType){
+//      String result = formatNumber(text.toString(),defaultFormattingType);
+//      //text.append(result);
+//      text.replace(0,text.length(),result);
+//    }
+    public static void formatNumber(Editable text, int defaultFormattingType) {
+        String result = formatNumber(text.toString(), defaultFormattingType);
+        if (result != null && !result.equals(text.toString())) {
+            //record the old cursor.
+            int oldIndex = Selection.getSelectionStart(text);
+            int digitCount = oldIndex;
+            int i = 0;
+            char c;
+            for (i = 0; i < oldIndex; i++) {
+                c = text.charAt(i);
+                if (c == ' ' || c == '-') {
+                        digitCount -- ;
+                }
+            }
+
+            text.replace(0, text.length(), result);
+
+            //update the cursor to old cursor
+            int count = 0;
+            for (i = 0; i < text.length() && count < digitCount ; i++) {
+                c = text.charAt(i);
+                if (!(c == ' ' || c == '-')) {
+                        count ++ ;
+                }
+            }
+            Selection.setSelection(text, i);
+            //Rlog.d(TAG,"OldIndex: "+oldIndex+", digitCount: "+digitCount + ", newCursor: "+i);
+        }
+
+    }
+
+    /**
+     * check the input number is '0-9','-','*','#',' ','+'
+     * warning: now we don't support WILD,PAUSE,WAIT.
+     * @param text
+     * @return
+     */
+    /*package*/static boolean checkInputNormalNumber(CharSequence text) {
+        boolean result = true;
+        char c;
+        for (int index = 0; index < text.length(); index++) {
+            c = text.charAt(index);
+            if (!((c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == ' ' || c == '-')) {
+                result  = false;
+                break;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @param defaultFormattingType
+     * @return
+     */
+    public static String formatNumber(String text, int defaultFormattingType) {
+        log("MTK Format Number:" + text + " " + defaultFormattingType);
+        if (!checkInputNormalNumber(text)) {
+            log("Abnormal Number:" + text + ", do nothing.");
+            return text;
+        }
+        text = removeAllDash(new StringBuilder(text));
+        int formatType = (defaultFormattingType == FORMAT_UNKNOWN) ? FORMAT_NANP : defaultFormattingType;
+        String result = text;
+        if (text.length() > 2 && text.charAt(0) == '+') {
+            if (text.charAt(1) == '1') {
+                formatType = FORMAT_NANP;
+            } else if (text.length() >= 3 && text.charAt(1) == '8' && text.charAt(2) == '1') {
+                formatType = FORMAT_JAPAN;
+            } else if (formatType == FORMAT_NANP || formatType == FORMAT_JAPAN) {
+                result = mtkFormatNumber(text, formatType);
+                return result;
+            }
+         }
+        log("formatNumber:" + formatType);
+         switch (formatType) {
+         case FORMAT_NANP:
+         case FORMAT_JAPAN:
+             result = PhoneNumberUtils.formatNumber(text, formatType);
+             break;
+         default:
+             result = mtkFormatNumber(text, formatType);
+         }
+
+        return result;
+    }
+
+    /**
+     * MediaTek Extension to format phone number.
+     *
+     * @param text
+     * @param defaultFormatType
+     * @return
+     */
+    /*package*/static String mtkFormatNumber(String text, int defaultFormatType) {
+        log("MTK Format Number:" + text + " " + defaultFormatType);
+        int length = text.length();
+        if (length < 6) {
+            // The string is either a shortcode or too short to be formatted
+            return text;
+        }
+
+      //check there are '*' or '#' in the number,remove all ' ' and '-', then return.
+      //alps00036166 also check sip number '@'
+        if (text.contains("*") || text.contains("#") || text.contains("@")) {
+            return removeAllDash(new StringBuilder(text));
+        }
+
+        int formatType = defaultFormatType;
+        //Update format type from number.
+        int[] match = getFormatTypeFromNumber(text, defaultFormatType);
+        int startIndex = 0;
+        if (match != null && match[1] != FORMAT_UNKNOWN) {
+            formatType = match[1];
+            startIndex = match[0];
+        }
+        //only input more 4 code and less 16 code follow country code.
+        //the longest length of mobile phone brazil is 12, and maybe three '-'.
+        if (length < startIndex + 4) {
+            return text;
+        } else if (length > startIndex + 15) {
+            return text;
+        }
+        String result = text;
+        StringBuilder sb = new StringBuilder(text);
+        int blankPosition = -1;
+        // Strip the dashes first and add format blank, as we're going to add them back
+        blankPosition = removeAllDashAndFormatBlank(sb, startIndex);
+        //there are may +886 9-11 ,delete 1, +886 9-1. so check again.
+        if (sb.length() < startIndex + 4 || sb.length() == startIndex + 4 && sb.charAt(blankPosition + 1) == '0') {
+            return sb.toString();
+        }
+
+        switch(formatType) {
+        case FORMAT_CHINA_MAINLAND:
+            result = formatChinaNumber(sb, blankPosition);
+            break;
+        case FORMAT_CHINA_HONGKONG:
+        case FORMAT_SINGAPORE:
+            result = formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition);
+            break;
+        case FORMAT_CHINA_MACAU:
+            result = formatMacauNumber(sb, blankPosition);
+            break;
+        case FORMAT_NANP:
+            SpannableStringBuilder ssb = null;
+            if (blankPosition >= 0) {
+                ssb = new SpannableStringBuilder(sb.substring(startIndex + 1));
+                PhoneNumberUtils.formatNanpNumber(ssb);
+                result = sb.substring(0, startIndex + 1).concat(ssb.toString());
+            } else {
+                ssb = new SpannableStringBuilder(sb);
+                PhoneNumberUtils.formatNanpNumber(ssb);
+                result = ssb.toString();
+            }
+            break;
+        case FORMAT_JAPAN:
+            SpannableStringBuilder ssb2 = null;
+            if (blankPosition >= 0) {
+                ssb2 = new SpannableStringBuilder(sb.substring(startIndex + 1));
+                PhoneNumberUtils.formatJapaneseNumber(ssb2);
+                result = sb.substring(0, startIndex + 1).concat(ssb2.toString());
+            } else {
+                ssb2 = new SpannableStringBuilder(sb);
+                PhoneNumberUtils.formatJapaneseNumber(ssb2);
+                result = ssb2.toString();
+            }
+            break;
+        case FORMAT_TAIWAN:
+            result = formatTaiwanNumber(sb, blankPosition);
+            break;
+        case FORMAT_VIETNAM:
+            result = formatVietnamNubmer(sb, blankPosition);
+            break;
+        case FORMAT_PORTUGAL:
+            result = formatPortugalNumber(sb, blankPosition);
+            break;
+        case FORMAT_POLAND:
+            result = formatPolandNumber(sb, blankPosition);
+            break;
+        case FORMAT_AUSTRALIA:
+            result = formatAustraliaNumber(sb, blankPosition);
+            break;
+        case FORMAT_NEW_ZEALAND:
+            result = formatNewZealandNumber(sb, blankPosition);
+            break;
+        case FORMAT_THAILAND:
+            result = formatThailandNumber(sb, blankPosition);
+            break;
+        case FORMAT_INDONESIA:
+            result = formatIndonesiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_MALAYSIA:
+            result = formatMalaysiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_SPAIN:
+            result = formatSpainNumber(sb, blankPosition);
+            break;
+        case FORMAT_RUSSIAN:
+            result = formatRussianNumber(sb, blankPosition);
+            break;
+        case FORMAT_GERMANY:
+            result = formatGermanyNumber(sb, blankPosition);
+            break;
+        case FORMAT_INDIA:
+            result = formatIndiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_ITALY:
+            result = formatItalyNumber(sb, blankPosition);
+            break;
+        case FORMAT_FRANCE:
+            result = formatFranceNumber(sb, blankPosition);
+            break;
+        case FORMAT_ENGLAND:
+            result = formatEnglandNumber(sb, blankPosition);
+            break;
+        case FORMAT_BRAZIL:
+            result = formatBrazilNumber(sb, blankPosition);
+            break;
+        case FORMAT_TURKEY:
+            result = formatTurkeyNumber(sb, blankPosition);
+            break;
+        default:
+            //move all ' ' and '-'
+            result = removeAllDash(sb);
+        }
+        return result;
+    }
+
+    /**
+     * get the format from common number, the now country international prefix is STD '00' or '+'
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text the length of text must more or equals 5
+     * @return
+     */
+    private static int[] getFormatTypeByCommonPrefix(String text) {
+        int result = FORMAT_UNKNOWN;
+        int index = 0;
+        int startIndex = 0;
+        int[] match = new int[2];
+        //is start with '00' or '+'
+        if (text.length() > 0 && text.charAt(0) == '+') {
+            startIndex = 1;
+        } else if (text.length() > 1 && text.charAt(0) == '0' && text.charAt(1) == '0') {
+            startIndex = 2;
+        }
+        if (startIndex != 0) {
+            for (String pattern : FORMAT_COUNTRY_CODES) {
+                index++;
+                if (text.startsWith(pattern, startIndex)) {
+                    result = index;
+                    startIndex = startIndex + pattern.length();
+                    break;
+                }
+            }
+        }
+        if (result == FORMAT_UNKNOWN) {
+            startIndex = 0;
+        }
+        match[0] = startIndex;
+        match[1] = result;
+        return match;
+    }
+
+    /**
+     * get the format from number, the now country international prefix is special in prefixs.
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text
+     * @param prefixs
+     * @return
+     */
+    private static int[] getFormatNumberBySpecialPrefix(String text, String[] prefixs) {
+        int result = FORMAT_UNKNOWN;
+        int index = 0;
+        int startIndex = 0;
+        int[] match = new int[2];
+        //is start with '+'
+        if (text.charAt(0) == '+') {
+            startIndex = 1;
+        } else {
+            // is start with special prefix
+            for (String prefix : prefixs) {
+                if (text.startsWith(prefix)) {
+                    startIndex = prefix.length();
+                    break;
+                }
+            }
+        }
+        //is start with '+' or special prefix
+        if (startIndex > 0) {
+            for (String pattern : FORMAT_COUNTRY_CODES) {
+                index++;
+                if (text.startsWith(pattern, startIndex)) {
+                    result = index;
+                    startIndex = startIndex + pattern.length();
+                    break;
+                }
+            }
+        }
+        if (result == FORMAT_UNKNOWN) {
+            startIndex = 0;
+        }
+        match[0] = startIndex;
+        match[1] = result;
+        return match;
+    }
+
+    /**
+     * get the format from number
+     * China mainland, China macao, England, Italy, Germany, India, Spain, Malaysia, Vietnam, Portugal, Poland, New Zealand is common prefix: '00' or '+'
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text
+     * @param defaultFormatType
+     * @param FORMAT_CHIAN_HONGKONG
+     * @return
+     */
+    private static int[] getFormatTypeFromNumber(String text, int defaultFormatType) {
+        int[] match = null;
+        switch(defaultFormatType) {
+        case FORMAT_CHINA_MAINLAND:
+        case FORMAT_CHINA_MACAU:
+        case FORMAT_ENGLAND:
+        case FORMAT_ITALY:
+        case FORMAT_GERMANY:
+        case FORMAT_INDIA:
+        case FORMAT_SPAIN:
+        case FORMAT_MALAYSIA:
+        case FORMAT_VIETNAM:
+        case FORMAT_PORTUGAL:
+        case FORMAT_POLAND:
+        case FORMAT_NEW_ZEALAND:
+        case FORMAT_TURKEY:
+        //just '+' for Russian.
+        case FORMAT_RUSSIAN:
+            match = getFormatTypeByCommonPrefix(text);
+            break;
+        case FORMAT_TAIWAN:
+            match = getFormatNumberBySpecialPrefix(text, TAIWAN_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_CHINA_HONGKONG:
+            match = getFormatNumberBySpecialPrefix(text, HONGKONG_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_NANP:
+            match = getFormatNumberBySpecialPrefix(text, NANP_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_JAPAN:
+            match = getFormatNumberBySpecialPrefix(text, JAPAN_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_FRANCE:
+            match = getFormatNumberBySpecialPrefix(text, FRANCE_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_SINGAPORE:
+            match = getFormatNumberBySpecialPrefix(text, SINGAPORE_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_INDONESIA:
+            match = getFormatNumberBySpecialPrefix(text, INDONESIA_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_THAILAND:
+            match = getFormatNumberBySpecialPrefix(text, THAILAND_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_AUSTRALIA:
+            match = getFormatNumberBySpecialPrefix(text, AUSTRALIA_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_BRAZIL:
+            match = getFormatNumberBySpecialPrefix(text, BRAZIL_INTERNATIONAL_PREFIXS);
+            break;
+        }
+        return match;
+    }
+
+    /**
+     * remove all dash.
+     * @param sb
+     * @return
+     */
+    private static String removeAllDash(StringBuilder sb) {
+        int p = 0;
+        while (p < sb.length()) {
+            if (sb.charAt(p) == '-' || sb.charAt(p) == ' ') {
+                sb.deleteCharAt(p);
+            } else {
+                p++;
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * remove all dash and add format blank, if stated with international code.
+     * @param sb
+     * @param startIndex
+     * @return
+     */
+    private static int removeAllDashAndFormatBlank(StringBuilder sb, int startIndex) {
+        int p = 0;
+        int index = -1;
+        while (p < sb.length()) {
+            if (sb.charAt(p) == '-' || sb.charAt(p) == ' ') {
+                sb.deleteCharAt(p);
+            } else {
+                p++;
+            }
+        }
+        if (startIndex > 0) {
+            //add blank follow country code
+            index = startIndex;
+            sb.replace(index, index, " ");
+        }
+        return index;
+    }
+
+    /**
+     * remove trailing dashes.
+     * @param sb
+     * @return
+     */
+    private static String removeTrailingDashes(StringBuilder sb) {
+        // Remove trailing dashes
+        int len = sb.length();
+        while (len > 0) {
+            if (sb.charAt(len - 1) == '-') {
+                sb.delete(len - 1, len);
+                len--;
+            } else {
+                break;
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format China Mianland Call number
+     *
+     * reference "http://www.ct10000.com/main/services/05/"
+     *           "http://en.wikipedia.org/wiki/Telephone_numbers_in_China"
+     *
+     * +86 10-NNNNNNNN    International Beijing Telephone
+     * +86 2N-NNNNNNNN    International Super city Telephone
+     * +86 NNN-NNNNNNNN   International Common region Telephone
+     * +86 NNN-NNNN-NNNN  International mobile phone
+     *
+     * 010-NNNNNNNN      Beijing Telephone
+     * 02N-NNNNNNNN      Super city Telephone
+     * 0NNN-NNNNNNN
+     * 10-NNNNNNNN
+     * 2N-NNNNNNNN
+     * NNN-NNNNNNNN     Common region Telephone
+     * NNN-NNNN-NNNN     mobile phone
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatChinaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for beijing or other super city.
+            //+86 10NNN -> +86 10-NNN
+            if (c1 == '1' && c2 == '0' || c1 == '2') {
+                dashPositions[numDashes++] = index + 2;
+            } else if (c1 == '1') {
+                //for mobile phone
+                //+86 1NNNN - > +86 1NN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+86 1NN-NNNNNN -> +86 1NN-NNNN-NN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 7;
+                }
+            } else { //for other common region code.
+                dashPositions[numDashes++] = index + 3;
+            }
+        } else {
+            char c1 = sb.charAt(phoneNumPosition);
+            char c2 = sb.charAt(phoneNumPosition + 1);
+            if (c1 == '1' && c2 != '0') {
+                //for mobile phone
+                //1NNNN - > 1NN-NN
+                if (length > phoneNumPosition + 4) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                }
+                //1NN-NNNNNN -> 1NN-NNNN-NN
+                if (length > phoneNumPosition + 8) {
+                    dashPositions[numDashes++] = phoneNumPosition + 7;
+                }
+            } else if (c1 == '1' && c2 == '0') {
+                //1NNNN - > 1NN-NN
+                if (length > phoneNumPosition + 3) {
+                    dashPositions[numDashes++] = phoneNumPosition + 2;
+                }
+            } else {
+                //No we don't know the code has region code(ignored 0), only when then length of number is more than 8
+                if (length > phoneNumPosition + 8) {
+                    if (c1 == '2') {
+                        dashPositions[numDashes++] = phoneNumPosition + 2;
+                    } else {
+                        dashPositions[numDashes++] = phoneNumPosition + 3;
+                    }
+                }
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Taiwan Call Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Taiwan"
+     *
+     * +886 9-NNNN-NNNN
+     * +886 N-NNNN-NNNN
+     * +886 N-NNN-NNNN
+     * +886 NN-NNNN-NNNN
+     * +886 NN-NNN-NNNN
+     * +886 NNN-NNN-NNN
+     *
+     *  0N-NNNN-NNNN
+     *  0N-NNN-NNNN
+     *  0NN-NNNN-NNNN
+     *  0NN-NNN-NNNN
+     *  0NNN-NNN-NNN
+     *  09-NNNN-NNNN     mobile phone
+     *
+     *  NNN-NNNN
+     *  NNNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatTaiwanNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //for mobile phone
+            if (c1 == '9') {
+//              dashPositions[numDashes++] = index + 1;
+//              //+886 9-NNNNNN -> +886 9-NNNN-NN
+//              if(length > index + 6){
+//                  dashPositions[numDashes++] = index + 5;
+//              }
+                if (length > index + 4)
+                dashPositions[numDashes++] = index + 3;
+                //+886 9NN-NNNN -> +886 9NN-NNN-NNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if ((c1 == '8' && c2 == '2' && c3 == '6') || (c1 == '8' && c2 == '3' && c3 == '6')) {
+                //for 0826, 0836
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+886 NNN-NNN-NNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if ((c1 == '3' && c2 == '7') || (c1 == '4' && c2 == '9') || (c1 == '8' && c2 == '9') || (c1 == '8' && c2 == '2')) {
+                //for 037, 049, 089, 082
+                dashPositions[numDashes++] = index + 2;
+                //+886 NN-NNN-NNNN
+                if (length > index + 6 && length < index + 10) {
+                    dashPositions[numDashes++] = index + 5;
+                } else if (length >= index + 10) { //+886 NN-NNNN-NNNN
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //for 02 04 05 06 07 08 ......
+                dashPositions[numDashes++] = index + 1;
+                //+886 N-NNN-NNNN
+                if (length > index + 6 && length < index + 9) {
+                    dashPositions[numDashes++] = index + 4;
+                } else if (length >= index + 9) { //+886 N-NNNN-NNNN
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            if (length > phoneNumPosition + 4 && length < phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length >= phoneNumPosition + 8) { //NNNN-NNNN....
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format China Macau Call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Macau"
+     *
+     * +853 NNNN-NNNN
+     * NNNN-NNNN
+     * 01 NNNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatMacauNumber(StringBuilder sb, int blankPosition) {
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //01 for Hongkong
+        if (sb.charAt(phoneNumPosition) == '0' && sb.charAt(phoneNumPosition + 1) == '1') {
+            sb.replace(phoneNumPosition + 2, phoneNumPosition + 2, " ");
+            return formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition + 3);
+        } else {
+            return formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition);
+        }
+    }
+
+    /**
+     * format number which length is 8, insert a hyphen to index 4.
+     * it is used for Hongkong, Macau, Singapore
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Hong_Kong"
+     *            "http://en.wikipedia.org/wiki/Telephone_numbers_in_Macau"
+     *            "http://en.wikipedia.org/wiki/Telephone_numbers_in_Singapore"
+     *
+     * +NNN NNNN-NNNN
+     * NNNN-NNNN
+     * @param text
+     * @param startIndex
+     * @return
+     */
+    private static String formatHeightLengthWithoutRegionCodeNumber(StringBuilder sb, int blankPosition) {
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+
+        if (sb.length() >= phoneNumPosition + 6) {
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return removeTrailingDashes(sb);
+    }
+
+    /**
+     * format Vietnam call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Vietnam"
+     *
+     * +84 4|8-XXXXXXXX
+     * +84 XX-XXXXXXX
+     * +84 YYY-XXXXXX
+     * 09Y-NNN-NNNN
+     * 01YY-NNN-NNNN
+     *
+     * 04-NNNNNNNN
+     * 08-NNNNNNNN
+     * 0NN-NNNNNNN
+     * 0NNN-NNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatVietnamNubmer(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for 02,04
+            if (c1 == '4' || c1 == '8') {
+                dashPositions[numDashes++] = index + 1;
+            } else if (c1 == '2' && (c2 == '1' || c2 == '3' || c2 == '4' || c2 == '8')
+                    || (c1 == '3' && (c2 == '2' || c2 == '5'))
+                    || (c1 == '6' && c2 == '5')
+                    || (c1 == '7' && (c2 == '1' || c2 == '8'))) {
+                //for 021X,023X,024X,028X, 032X,035X, 065X, 071X,078X
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+            } else if (c1 == '9') { //for mobile phone 09N
+                //+84 9NNN -> +84 9N-NN
+                dashPositions[numDashes++] = index + 2;
+                //+84 9N-NNNNN -> +84 9N-NNN-NN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (c1 == '1') { //for mobile phone 01NN
+                //+84 1NNNN -> +84 1NN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+84 1NN-NNNNN - > +84 1NN-NNN-NN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //for XX
+                dashPositions[numDashes++] = index + 2;
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+
+    /**
+     * format Portugal Number
+     *
+     * +351 9T-NNN-NNNN
+     * +351 NN-NNN-NNNN
+     * 9T-NNN-NNNN
+     * NN-NNN-NNNN
+     *
+     * @param text
+     * @param startIndex
+     * @return
+     */
+    private static String formatPortugalNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (length > phoneNumPosition + 4) {
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+        }
+        if (length > phoneNumPosition + 8) {
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Brazil Phone Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Brazil"
+     *
+     * +55-aa-nnnn-nnnn
+     *
+     * 0-xx-aa-nnnn-nnnn
+     * 0-aa-nnnn-nnnn
+     *
+     * nnnn-nnnn
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatBrazilNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[5];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                dashPositions[numDashes++] = phoneNumPosition + 1;
+                index ++;
+            }
+            if (length > index + 3) {
+                dashPositions[numDashes++] = index + 2;
+            }
+            if (length > index + 7 && length <= index + 10) {
+                dashPositions[numDashes++] = index + 6;
+            } else if (length > index + 10) {
+                dashPositions[numDashes++] = index + 4;
+                dashPositions[numDashes++] = index + 8;
+            }
+        } else if (length > phoneNumPosition + 5) {
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Poland call number
+     *
+     * +48 NN-NNN-NN-NN mobile phone(started with 5,6,7,8)
+     * +48 NNN-NNN-NNN  fixed phone
+     * NN-NNN-NN-NN
+     * NNN-NNN-NNN
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_Poland
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatPolandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[3];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //for mobile phone(started with 5,6,7,8)
+        if (sb.charAt(phoneNumPosition) >= '5' && sb.charAt(phoneNumPosition) <= '8') {
+            if (length > phoneNumPosition + 4) {
+                dashPositions[numDashes++] = phoneNumPosition + 2;
+            }
+            if (length > phoneNumPosition + 6) {
+                dashPositions[numDashes++] = phoneNumPosition + 5;
+            }
+            if (length > phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 7;
+            }
+        } else {
+            if (length > phoneNumPosition + 5) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+            if (length > phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 6;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Australia Number
+     *
+     * +61 4NN-NNN-NNN
+     * +61 X-XXXX-XXXX
+     * 04XX-NNN-NNN mobile phone
+     * 0X-XXXX-XXXX landline phone
+     * XXXX-XXXX
+     *
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_Australia
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatAustraliaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone
+            if (sb.charAt(index) == '4') {
+                //+61 4NNNNN -> +61 4NN-NNN or 04NNNNN -> 04NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+61 4NN-NNNNNN->+61 4NN-NNN-NNN or 04NN NNNNNN - > 04NN-NNN-NNN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //+61 XNNNN -> +61 X-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+61 X-NNNNNNNN -> +61 X-NNNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            //only do when the length of local number is 8
+            //XXXXXXXX->XXXX-XXXX
+            System.out.println(length);
+            if (length == phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format New Zealand call number
+     *
+     * +64 N-NNN-NNNN
+     * +64 2X-NNN-NNNN
+     * 02N-NNN-NNNN mobile phone
+     * 0N-NNN-NNNN landline phone
+     * NNN-NNNN landline phone
+     *
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_New_Zealand
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatNewZealandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone. start 2X but not 24.
+            if (sb.charAt(index) == '2' && sb.charAt(index + 1) != '4') {
+                //+64 2XNNN -> +64 2X-NNN or 02XNNN -> 02X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+64 2X-NNNNNNN->+61 2X-NNN-NNNN or 02X-NNNNNNN - > 02X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else {
+                //+64 XNNN -> +64 X-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+64 X-NNNNNNN -> +61 X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            }
+        } else {
+            //only do when the length of local number is 7
+            //NNNNNNN->NNN-NNNN
+            System.out.println(length);
+            if (length == phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Tailand call number
+     *
+     * +66 2-NNN-NNNN
+     * +66 NN-NNN-NNN
+     * +66 8N-NNN-NNNN
+     * 02-NNN-NNNN
+     * 0XX-NNN-NNN
+     * 08X-NNN-NNNN
+     *
+     * reference "http://www.wtng.info/wtng-66-th.html"
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Thailand"
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatThailandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone. started with 8 or 08
+            if (sb.charAt(index) == '8') {
+                //+66 8XNNN -> +66 8X-NNN or 08XNNN -> 08X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+66 8X-NNNNNN->+61 8X-NNN-NNN or 08X-NNNNNNN - > 08X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (sb.charAt(index) == '2') { //for Bangkok started with 2 or 02.
+                //+66 2NNN -> +64 2-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+66 2-NNNNNNN -> +66 2-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else { //for other region code with NN or 0NN
+                //+66 XXNNN -> +66 XX-NNN or 0XXNNN -> 0XX-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+66 XX-NNNNNN->+61 XX-NNN-NNN or 0XX-NNNNNNN - > 0XX-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            //To dial a land line in Thailand all over the country, the format is Area Code + Phone Number.
+            //Even through dial local phone, must add area code.
+            //only do when the length of local number is 7
+            //NNNNNNN->NNN-NNNN
+            //System.out.println(length);
+            //if(length == phoneNumPosition + 7 ){
+            //  dashPositions[numDashes++] = phoneNumPosition + 3;
+            //}
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Indonesia call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Indonesia"
+     *
+     * +62 8NN-NNN-NNN
+     * +62 8NN-NNN-NNNN
+     * +62 8NN-NNNN-NNNN
+     * +62 NN-NNNN-NNNN
+     * +62 NNN-NNN-NNNN
+     * 08NN-NNN-NNN
+     * 08NN-NNN-NNNN
+     * 08NN-NNNN-NNNN
+     * 0NN-NNNN-NNNN
+     * 0NNN-NNN-NNNN
+     * 8NN-NNNN-NNNN
+     * 8NN-NNN-NNNN
+     * 8NN-NNN-NNN
+     * NNNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatIndonesiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //mobile phone started with +62 8 or 08
+            if (c1 == '8') {
+                //+62 8NNNNN -> +62 8NN-NNN or 08NNNNN -> 08NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+62 8NN-NNNNN.. -> +62 8NN-NNN-NN.., when the length of mobile phone number is less then 11
+                if (length >= index + 8 && length <= index + 10) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+                //+62 8NN-NNNNNNNN -> +62 8NN-NNNN-NNNN, when the length of mobile phone number is more then 10.
+                if (length > index + 10) {
+                    dashPositions[numDashes++] = index + 7;
+                }
+            } else if ((c1 == '2' && (c2 == '1' || c2 == '2' || c2 == '4'))
+                    || (c1 == '3' && c2 == '1')
+                    || (c1 == '6' && c2 == '1' && c3 != '9')) {
+                //region code 21,22,24,31,61(not 619)
+                //+62 XXNNN -> +62 XX-NNN or 0XXNNN -> 0XX-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+62 XX-NNNNNNNN -> +62 XX-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //region code YYY
+                //+62 YYYNNN -> +62 YYY-NNN or 0YYYNNN -> 0YYY-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+62 YYY-NNNNNNN -> +62 YYY-NNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            }
+        } else {
+            //NNNNNNN->NNN-NNNN
+            if (length == phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length == phoneNumPosition + 8) {
+                //NNNNNNNN->NNNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            } else if (sb.charAt(phoneNumPosition) == '8') { //FOR 8NNNNNNNNNN...
+                if (length > phoneNumPosition + 8 && length <= phoneNumPosition + 10) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                    dashPositions[numDashes++] = phoneNumPosition + 6;
+                } else if (length > phoneNumPosition + 10) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                    dashPositions[numDashes++] = phoneNumPosition + 7;
+                }
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Malaysia call number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Malaysia"
+     *
+     * +60 3-NNNNNNNN
+     * +60 X-NNNNNNN
+     * +60 8X-NNNNNN
+     * +60 1X-NNN-NNNN
+     *
+     * 2-NNNN-NNNN (to Singapore)
+     * 03-NNNNNNNN
+     * 0X-NNNNNNN
+     * 08X-NNNNNN
+     * 01X-NNN-NNNN
+     *
+     * 1X-NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatMalaysiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            //+60 X-NNNNNNN or +60 3-NNNNNNNN or 03-NNNNNNNN or 0X-NNNNNNN
+            if (c1 >= '3' && c1 <= '7' || c1 == '9') {
+                //+60 XNNNN -> +60 X-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+            } else if (c1 == '8') {
+                //+60 8XNNN -> +60 8X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+            } else if (c1 == '1') {
+                //mobile phone
+                //+60 1XNNN -> +60 1X-NNN or 01XNNN -> 01X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+60 1X-NNNNNN->+60 1X-NNN-NNN or 01X-NNNNNNN - > 01X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (c1 == '2') { //to Singapore
+                //+60 2NNNN -> +60 2-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+60 2NNNNNNN -> +60 2-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else if (sb.charAt(phoneNumPosition) == '2' && length > phoneNumPosition + 8) { //to Singapore
+            // 2NNNN -> 2-NNNN
+            dashPositions[numDashes++] = phoneNumPosition + 1;
+            // 2NNNNNNN -> 2-NNNN-NNNN
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        } else if (sb.charAt(phoneNumPosition) == '1' && length > phoneNumPosition + 8) {
+            //for mobile phone.
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Spain Number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Spain"
+     *
+     * +34 NNN-NNN-NNN
+     *
+     * NNN-NNN-NNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatSpainNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //+34 NNNNNN - > +34 NNN-NNNN
+        if (length > phoneNumPosition + 5) {
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+        }
+        //+34 NNNNNNNN-> +34 NNN-NNN-NN
+        if (length > phoneNumPosition + 7) {
+            dashPositions[numDashes++] = phoneNumPosition + 6;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+    private static int[] INDIA_7_MOBILE_AREA_CODE = {
+
+    };
+    //TODO maybe use table, and binary search is better.
+    */
+
+    /**
+     * India Three digits area codes
+     *
+     * reference: "http://www.bsnl.co.in/stdsearch.php"
+     *
+     */
+    private static final int[] INDIA_THREE_DIGIG_AREA_CODES = {
+        120, 121, 122, 124, 129, 130, 131, 132, 135, 141, 144, 145, 151, 154, 160, 161, 164, 171, 172, 175, 177, 180, 181, 183, 184, 186, 191, 194,
+        212, 215, 217, 230, 231, 233, 240, 241, 250, 251, 253, 257, 260, 261, 265, 268, 278, 281, 285, 286, 288, 291, 294, 326, 341, 342, 343, 353,
+        354, 360, 361, 364, 368, 369, 370, 372, 373, 374, 376, 381, 385, 389, 413, 416, 421, 422, 423, 424, 427, 431, 435, 451, 452, 461, 462, 468,
+        469, 470, 471, 474, 475, 476, 477, 478, 479, 480, 481, 483, 484, 485, 487, 490, 491, 494, 495, 496, 497, 512, 515, 522, 532, 535, 542, 548,
+        551, 562, 565, 571, 581, 591, 595, 612, 621, 631, 641, 651, 657, 661, 663, 671, 674, 680, 712, 721, 724, 731, 733, 734, 744, 747, 751, 755,
+        761, 771, 788, 816, 820, 821, 824, 831, 832, 836, 861, 863, 866, 870, 877, 878, 883, 884, 891
+    };
+
+    /**
+     * check 8NNN,7NNN is moble phone number, or is fixed number.
+     * if is mobile phone number,return 0.
+     * if is two digits region code, return 2;
+     * if is three digits region code, return 3;
+     * if is four digits region code, reutrn 4;
+     *
+     * Waring: we are now using the strategy that mobile phones to expend,
+     *         when the number is not used, it is the mobile phone number by default, but the statistics are not complete.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Mobile_telephone_numbering_in_India"
+     * reference: "http://www.bsnl.co.in/stdsearch.php"
+     *
+     * @param c1 c1 != '0'
+     * @param c2
+     * @param c3
+     * @param c4
+     * @return
+     */
+    private static int checkIndiaNumber(char c1, char c2, char c3, char c4) {
+        int result = -1;
+        int temp = (c3 - '0') * 10 + (c4 - '0');
+        if (c1 == '9') {
+            result = 0;
+        } else if (c1 == '8') {
+            if ((c2 == '0' && (temp < 20 || temp >= 50 && temp <= 60 || temp >= 80))
+                    || (c2 == '1' && (temp < 10 || temp >= 20 && temp <= 29 || temp >= 40 && temp <= 49))
+                    || (c2 == '7' && (temp >= 90 || temp == 69))
+                    || (c2 == '8' && (temp < 10 || temp == 17 || temp >= 25 && temp <= 28 || temp == 44 || temp == 53 || temp >= 90))
+                    || (c3 == '9' && (temp < 10 || temp == 23 || temp == 39 || temp >= 50 && temp <= 62 || temp == 67 || temp == 68 || temp >= 70))) {
+                result = 0;
+            }
+        } else if (c1 == '7') {
+            //TODO maybe use table, and binary search is better.
+            if (c2 == '0' //expend to mobile phone number
+                || (c2 == '2' && (temp == 0 || temp >= 4 && temp <= 9 || temp == 50 || temp == 59 || temp >= 75 && temp <= 78 || temp == 93 || temp == 9))
+                || (c2 == '3' && (temp == 73 || temp == 76 || temp == 77 || temp == 96 || temp == 98 || temp == 99))
+                || (c2 == '4' && (temp < 10 || temp == 11 || temp >= 15 && temp <= 19 || temp == 28 || temp == 29 || temp == 39 || temp == 83 || temp == 88 || temp == 89 || temp == 98 || temp == 99))
+                || (c2 == '5' && (temp <= 4 || temp == 49 || temp == 50 || temp >= 66 && temp <= 69 || temp == 79 || temp >= 87 && temp <= 89 || temp >= 97))
+                || (c2 == '6' && (temp == 0 || temp == 2 || temp == 7 || temp == 20 || temp == 31 || temp == 39 || temp == 54 || temp == 55 || temp >= 65 && temp <= 69 || temp >= 76 && temp <= 79 || temp >= 96))
+                || (c2 == '7' && (temp == 2 || temp == 8 ||  temp == 9 || temp >= 35 && temp <= 39 || temp == 42 || temp == 60 || temp == 77 || temp >= 95))
+                || (c2 == '8' && temp <= 39 && (temp == 0 || temp >= 7 && temp <= 9 || temp == 14 || temp >= 27 && temp <= 30 || temp >= 37 && temp <= 39))
+                || (c2 == '8' && temp > 39 && (temp == 42 || temp == 45 || temp == 60 || temp >= 69 && temp <= 79 || temp >= 90))) {
+                result = 0;
+            }
+        }
+        if (result == 0) {
+            return result;
+        }
+        if ((c1 == '1' && c2 == '1')
+                || (c1 == '2' && (c2 == '0' || c2 == '2'))
+                || (c1 == '3' && c2 == '3')
+                || (c1 == '4' && (c2 == '0' || c2 == '4'))
+                || (c1 == '7' && c2 == '9')
+                || (c1 == '8' && c2 == '0')) {
+            result = 2;
+        } else {
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            if (Arrays.binarySearch(INDIA_THREE_DIGIG_AREA_CODES, key) >= 0) {
+                result = 3;
+            } else {
+                result = 4;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * format India call number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_India"
+     *
+     * +91 XX-YY-NNNNNN
+     * +91 NN-NNNNNNNN
+     * +91 NNN-NNNNNNN
+     * +91 NNNN-NNNNNN
+     *
+     * 0XX-YY-NNNNNN
+     * 0NN-NNNNNNNN
+     * 0NNN-NNNNNNN
+     * 0NNNN-NNNNNN
+     *
+     * XX-YY-NNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatIndiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+
+        //has country code. or started with '0'
+        char c = sb.charAt(phoneNumPosition);
+        if ((phoneNumPosition > 0 && c != '0') ||
+                (c == '0' && length > phoneNumPosition + 4)) {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            char c4 = sb.charAt(index + 3);
+            //check the india number type.
+            int type = checkIndiaNumber(c1, c2, c3, c4);
+            //for mobile phone
+            if (type == 0) {
+                dashPositions[numDashes++] = index + 2;
+                //+91 9X-YYNNNN -> +91 9X-YY-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else if (type == 2) {
+                //+91 NNNN -> + 91 NN-NN
+                dashPositions[numDashes++] = index + 2;
+            } else if (type == 3) {
+                //+91 NNNNN -> + 91 NNN-NN
+                dashPositions[numDashes++] = index + 3;
+            } else {
+                //+91 NNNNNN -> +91 NNNN-NN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            }
+        } else if (length > phoneNumPosition + 8) {
+            //XXYYNNNNNN -> XX-YY-NNNNNN
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Russian Number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Russia"
+     *
+     * Because in Russian, when dialing Long Distance or International Call, the prefix is 8~ or 8~10, it come to DTMF.
+     * There are plans to change those prefixes to '0' for national and '00' for international dialing, but they are not yet implemented.
+     * So, we don't check any Long Distance or International Call prefix, all number format as follow:
+     *
+     * +7 NNN-NNN-NN-NN
+     * +7 9NN-NNN-NN-NN
+     * YYY-NNN-NN-NN only in same country, so YYY can be ignored.
+     * NNN-NN-NN
+     * NN-NN-NN
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatRussianNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[3];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code.
+        if (phoneNumPosition > 0) {
+            //+7 NNNNNN -> +7 NNN-NNN
+            if (length > phoneNumPosition + 5) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+            //+7 NNN-NNNNNN-> +7 NNN-NNN-NN
+            if (length > phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 6;
+            }
+            //+7 NNN-NNN-NNNN-> +7 NNN-NNN-NN-NN
+            if (length > phoneNumPosition + 9) {
+                dashPositions[numDashes++] = phoneNumPosition + 8;
+            }
+        } else if (length == phoneNumPosition + 6) {
+            //NNNNNN -> NN-NN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        } else if (length == phoneNumPosition + 7) {
+            //NNNNNNN -> NNN-NN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        } else if (length >= phoneNumPosition + 8) {
+            //NNNNNNNN - > NNN-NNN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+            dashPositions[numDashes++] = phoneNumPosition + 6;
+            //NNN-NNN-NNNN -> NNN-NNN-NN-NN
+            if (length > phoneNumPosition + 9) {
+                dashPositions[numDashes++] = phoneNumPosition + 8;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Germany region codes: three digits, exclude XX1.
+     *
+     * Warning: 212 must don't follow 9.
+     * reference: "http://en.wikipedia.org/wiki/Area_codes_in_Germany"
+     *
+     */
+    private static final int[] Germany_THREE_PART_REGION_CODES = {
+            202, 203, 208, 209, 212, 214, 221, 228, 234, 249, 310, 335, 340, 345, 365, 375, 385, 395,
+            457, 458, 459, 700, 709, 710, 728, 729, 749, 759, 769, 778, 779, 786, 787, 788, 789, 792,
+            798, 799, 800, 872, 875, 879, 900, 902, 903, 906
+    };
+
+    /**
+     * Germany region codes: four digits, and started with 3.
+     * reference: "http://en.wikipedia.org/wiki/Area_codes_in_Germany"
+     */
+    private static final int[] Germany_FOUR_PART_REGION_CODES = {
+            3301, 3302, 3303, 3304, 3306, 3307, 3321, 3322, 3327, 3328, 3329, 3331, 3332, 3334,
+            3335, 3337, 3338, 3341, 3342, 3344, 3346, 3361, 3362, 3364, 3366, 3371, 3372, 3375,
+            3377, 3378, 3379, 3381, 3382, 3385, 3386, 3391, 3394, 3395, 3421, 3423, 3425, 3431,
+            3433, 3435, 3437, 3441, 3443, 3445, 3447, 3448, 3461, 3462, 3464, 3466, 3471, 3473,
+            3475, 3476, 3491, 3493, 3494, 3496, 3501, 3504, 3521, 3522, 3523, 3525, 3528, 3529,
+            3531, 3533, 3537, 3541, 3542, 3544, 3546, 3561, 3562, 3563, 3564, 3571, 3573, 3574,
+            3576, 3578, 3581, 3583, 3585, 3586, 3588, 3591, 3592, 3594, 3596, 3601, 3603, 3605,
+            3606, 3621, 3622, 3623, 3624, 3626, 3627, 3628, 3629, 3631, 3632, 3634, 3635, 3636,
+            3641, 3643, 3644, 3647, 3661, 3663, 3671, 3672, 3675, 3677, 3679, 3680, 3681, 3682,
+            3683, 3685, 3686, 3691, 3693, 3695, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3731,
+            3733, 3735, 3737, 3741, 3744, 3745, 3761, 3762, 3763, 3764, 3765, 3771, 3772, 3773,
+            3774, 3821, 3831, 3834, 3838, 3841, 3843, 3844, 3847, 3871, 3874, 3876, 3877, 3881,
+            3883, 3886, 3901, 3921, 3923, 3925, 3928, 3931, 3933, 3935, 3937, 3941, 3942, 3943,
+            3944, 3946, 3947, 3949, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3971,
+            3973, 3976, 3981, 3984, 3991, 3994, 3996, 3997
+    };
+
+    /**
+     * format Germany call Number
+     *
+     * Prefix   Service type
+     *  01  Non-geographic area codes
+     *  02  Geographic area codes around Dusseldorf
+     *  03  Geographic area codes around Berlin, except 031 and 032
+     *  04  Geographic area codes around Hamburg
+     *  05  Geographic area codes around Hannover
+     *  06  Geographic area codes around Frankfurt am Main
+     *  07  Geographic area codes around Stuttgart, except 0700
+     *  08  Geographic area codes around Munich, except 0800
+     *  09  Geographic area codes around Nuremberg, except 0900
+     *  11  Network services
+     *
+     * Reference: "http://en.wikipedia.org/wiki/%2B49"
+     *
+     * WARNING: Geographic area codes have a length of two to five digits (not including the 0 trunk code).
+     * Two Digits:      Berlin (030), Hamburg (040), Frankfurt (069) and Munich (089).
+     * Three Digits:    as 0XX1 or in Germany_THREE_PART_REGION_CODES, and is not previous case.
+     * Four Digits:     it is not previous case, if don't start with 03, and , or in Germany_FOUR_PART_REGION_CODES, is four digits.
+     * Five Digits:     start with 03, and is not previous case, is five digits.
+     *
+     * +49 NN-NNN-NNNNN
+     * +49 NNN-NNN-NNNNN
+     * +49 NNNN-NNN-NNNN
+     * +49 3NNNN-NNN-NNN
+     * +49 1NN-NNNNNN-NN
+     *
+     * 0NN-NNN-NNNNN
+     * 0NNN-NNN-NNNNN
+     * 0NNNN-NNN-NNNN
+     * 03NNNN-NNN-NNN
+     * 01NN-NNNNNN-NN
+     *
+     * NNN-NNNNN
+     * NNN-NNNN
+     * NNN-NNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatGermanyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for +49 1X
+            if (c1 == '1') {
+                //+49 1XXNNN -> +49 1XX-NNN or 01XXNNN -> 01XX-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //mobile phone 015X, 016X, 017X
+                if (c2 == '5' || c2 == '6' || c2 == '7') {
+                    //+49 1XX-NNNNNNNN->+49 1XX-NNNNNN-NN or 01XX-NNNNNNNN - > 01XX-NNNNNN-NN
+                    if (length > index + 10) {
+                        dashPositions[numDashes++] = index + 9;
+                    }
+                }
+            } else //Berlin (030), Hamburg (040), Frankfurt (069) and Munich (089).
+                if ((c1 == '3' && c2 == '0') || (c1 == '4' && c2 == '0')
+                    || (c1 == '6' && c2 == '9') || (c1 == '8' && c2 == '9')) {
+                //+49 NNNNN -> +49 NN-NNN or 0NNNNN -> 0NN-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+49 NN-NNNNNN -> +49 NN-NNN-NNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (length > index + 3) {
+                char c3 = sb.charAt(index + 2);
+                char c4 = sb.charAt(index + 3);
+                int key3 = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+                int key4 = key3 * 10 + (c4 - '0');
+                //0XX1 or in Germany_THREE_PART_REGION_CODES is 0NNN region code.
+                if (c3 == '1' || (Arrays.binarySearch(Germany_THREE_PART_REGION_CODES, key3) >= 0 && (key3 != 212 || key3 == 212 && c4 != '9'))) {
+                    //+49 NNNNNN -> +49 NNN-NNN
+                    if (length > index + 4) {
+                        dashPositions[numDashes++] = index + 3;
+                    }
+                    //+49 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                    if (length > index + 7) {
+                        dashPositions[numDashes++] = index + 6;
+                    }
+                } else //if don't start with 03, and is not previous case or in Germany_FOUR_PART_REGION_CODES, is four digits.
+                    if (c1 != '3' || c1 == '3' && Arrays.binarySearch(Germany_FOUR_PART_REGION_CODES, key4) >= 0) {
+                        //+49 NNNNNNN -> +49 NNNN-NNN
+                        if (length > index + 5) {
+                            dashPositions[numDashes++] = index + 4;
+                        }
+                        //+49 NNNN-NNNNNN -> +49 NNNN-NNN-NNN
+                        if (length > index + 8) {
+                            dashPositions[numDashes++] = index + 7;
+                        }
+                } else {
+                    //start with 03, and is not previous case, is five digits.
+                    //+49 NNNNNNNN -> +49 NNNNN-NNN
+                    if (length > index + 6) {
+                        dashPositions[numDashes++] = index + 5;
+                    }
+                    //+49 NNNNN-NNNNNN -> +49 NNNNN-NNN-NNN
+                    if (length > index + 9) {
+                        dashPositions[numDashes++] = index + 8;
+                    }
+                }
+            }
+        } else if (length >= phoneNumPosition + 6 && length <= phoneNumPosition + 8) {
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Italy Mobile Phone Number Prefixs
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Italy"
+     *
+     */
+    private static final int[] ITALY_MOBILE_PREFIXS = {
+        328, 329, 330, 333, 334, 335, 336, 337, 338,
+        339, 347, 348, 349, 360, 368, 380, 388, 389
+    };
+
+    /**
+     * format Italy Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Italy"
+     *
+     * Land line numbers (area code+exchange+number) are generally 9 or 10 digits long,
+     * although they can be as little as 6 or as many as 11 digits.
+     * Mobile numbers are always 10 digits long, with the only exception of very old TIM numbers,
+     * which are 9 digits long (though those are now extremely rare).
+     * Mobile phone number in Italy: without a zero, started with a 3.
+     *
+     * +39 3NN-NNN-NNNN
+     * +39 N-NNNNNNNN
+     * +39 NN-NNNNNNNN
+     * +39 NNN-NNNNNNN
+     *
+     * 3NN-NNN-NNNN
+     * 0N-NNNNNNNN
+     * 0NN-NNNNNNNN
+     * 0NNN-NNNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatItalyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            //mobile phone number
+            if (Arrays.binarySearch(ITALY_MOBILE_PREFIXS, key) >= 0) {
+                //+39 3NNNNN -> +39 3NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+39 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if (c1 == '2' || c1 == '6') {
+                //for Milan(02)
+                //    Rome (including State of Vatican City) and Aprilia 06
+                dashPositions[numDashes++] = index + 1;
+            } else if (c2 == '0' || c2 == '1' || c2 == '5' || c2 == '9') {
+                //10,11,15,19
+                //30,31,35,39
+                //40,41,45,49
+                //50,51,55,59
+                //70,71,75,79
+                //80,81,85,89
+                //90,91,95,99
+                //+39 NNNNN - > +39 NN-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+            } else {
+                //+39 NNNNNN-> + 39 NNN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+            }
+        } else {
+            char c1 = sb.charAt(phoneNumPosition);
+            char c2 = sb.charAt(phoneNumPosition + 1);
+            char c3 = sb.charAt(phoneNumPosition + 2);
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            if (Arrays.binarySearch(ITALY_MOBILE_PREFIXS, key) >= 0) {
+                //+39 3NNNNN -> +39 3NN-NNN
+                if (length > phoneNumPosition + 5) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                }
+                //+39 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                if (length > phoneNumPosition + 7) {
+                    dashPositions[numDashes++] = phoneNumPosition + 6;
+                }
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format France Call Number
+     *
+     * refernce "http://en.wikipedia.org/wiki/Telephone_numbers_in_France"
+     *
+     * All geographic numbers had to be dialed in the ten-digit format, even for local calls.
+     * The international access code also changed from 19 to 00.
+     * Following liberalisation in 1998, subscribers could access different carriers by
+     * replacing the '0' (omitted from numbers when called from outside France) with another digit.
+     * For example Cegetel required subscribers to dial '7', e.g: Paris 71 xx xx xx xx, instead of 01 xx xx xx xx.
+     * Similarly, the international access code using Cegetel would be '70', instead of '00'.
+     * 00 (France Telecom)
+     * 40 (TELE 2)
+     * 50 (OMNICOM)
+     * 70 (LE 7 CEGETEL)
+     * 90 (9 TELECOM)
+     *
+     * +33 N-NN-NN-NN-NN
+     *
+     * TN-NN-NN-NN-NN, T = 0,4,5,7,9
+     *
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatFranceNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[4];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        int c = sb.charAt(phoneNumPosition);
+        if (phoneNumPosition > 0 || c == '0' || c == '4' || c == '5' || c == '7' || c == '9') {
+            int index = phoneNumPosition;
+            if (phoneNumPosition == 0 && (c == '0' || c == '4' || c == '5' || c == '7' || c == '9') || phoneNumPosition > 0 && c == '0') {
+                index ++;
+            }
+            //+33 NNNN-> +33 N-NNN
+            dashPositions[numDashes++] = index + 1;
+            //+33 N-NNNN-> +33 N-NN-NN
+            if (length > index + 4) {
+                dashPositions[numDashes++] = index + 3;
+            }
+            //+33 N-NN-NNNN -> +33 N-NN-NN-NN
+            if (length > index + 6) {
+                dashPositions[numDashes++] = index + 5;
+            }
+            //+33 N-NN-NN-NNNN -> +33 N-NN-NN-NN-NN
+            if (length > index + 8) {
+                dashPositions[numDashes++] = index + 7;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format United Kingdom call number
+     *
+     * All mobile telephone numbers have 10 national (significant) numbers after the "0" trunk code.
+     * In the United Kingdom, area codes are two, three, four, or, rarely, five digits long (after the initial zero).
+     * Regions with shorter area codes, typically large cities, permit the allocation of more telephone numbers
+     * as the local number portion has more digits. Local customer numbers are four to eight figures long.
+     * The total number of digits is ten, but in a very few areas the total may be nine digits (after the initial zero).
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_the_United_Kingdom"
+     *            "http://en.wikipedia.org/wiki/List_of_United_Kingdom_dialling_codes"
+     *            "http://www.ofcom.org.uk/static/archive/oftel/publications/numbering/2003/num_guide.htm"
+     *
+     * +44 2N-NNNN-NNNN
+     * +44 1NN-NNN-NNNN
+     * +44 1NNN-NNNNN(N)
+     * +44 1NNNN-NNNNN(N)
+     * +44 3NN-NNN-NNNN
+     * +44 5N-NNNN-NNNN
+     * +44 7NNN-NNNNNN
+     * +44 8NN-NNN-NNNN
+     * +44 9NN-NNN-NNNN
+     *
+     * 02N-NNNN-NNNN
+     * 01NN-NNN-NNNN
+     * 01NNN-NNNNN(N)
+     * 01NNNN-NNNNN(N)
+     * 03NN-NNN-NNNN
+     * 05N-NNNN-NNNN
+     * 07NNN-NNNNNN
+     * 08NN-NNN-NNNN
+     * 09NN-NNN-NNNN
+     *
+     * NNNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatEnglandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //for mobile phone
+            if (c1 == '7') {
+                //+44 7NNNNNNNNN -> +44 7NNN-NNNNNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else if (c1 == '2') {
+                //+44 2NNN - > +44 2N-NN
+                dashPositions[numDashes++] = index + 2;
+                //+44 2N-NNNNNNNN -> +44 2N-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if (c1 == '1') { //for region code.
+                char c4 = sb.charAt(index + 2);
+                int key = (c1 - '0') * 1000 + (c2 - '0') * 100 + (c3 - '0') * 10 + c4;
+                if (c2 == '1' || c3 == '1') {
+                    //+44 1NN-NN -> +44 1NN-NN
+                    if (length > index + 4) {
+                        dashPositions[numDashes++] = index + 3;
+                    }
+                    //+44 1NN-NNNNN -> 1NN-NNN-NN
+                    if (length > index + 7) {
+                        dashPositions[numDashes++] = index + 6;
+                    }
+                } else if (key != 1387 && key != 1539 && key != 1697 && key != 1768 && key != 1946) {
+                    // don't started with 01387, 01539, 01697, 01524, 01768, 01946
+                    //+44 1NNNNN -> +44 1NNN-NN
+                    if (length > index + 5) {
+                        dashPositions[numDashes++] = index + 4;
+                    }
+                } else {
+                    //+44 1NNNNNN -> +44 1NNNN-NN
+                    if (length > index + 6) {
+                        dashPositions[numDashes++] = index + 5;
+                    }
+                }
+            } else if (c1 == '3' || c1 == '8' || c1 == '9') {
+                //+44 NNNNN-> +44 NNN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+44 NNN-NNNNN -> NNN-NNN-NN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //other as 0NN-NNNN-NNNN
+                //+44 NNNN - > +44 NN-NN
+                dashPositions[numDashes++] = index + 2;
+                //+44 NN-NNNNNNNN -> +44 NN-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            }
+        } else {
+            if (length > phoneNumPosition + 4 && length < phoneNumPosition + 8) { //NNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length >= phoneNumPosition + 8) { //NNNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Turkey Phone Number.
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Turkey"
+     *
+     * +90 NNN-NNN-NNNN
+     * 0NNN-NNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatTurkeyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //+90 NNNNN -> +90 NNN-NN
+            if (length > index + 4) {
+                dashPositions[numDashes++] = index + 3;
+            }
+            //+90 NNN-NNNNN - > +90 NNN-NNN-NN
+            if (length > index + 7) {
+                dashPositions[numDashes++] = index + 6;
+            }
+        } else {
+            //NNNNNNN -> NNN-NNNN
+            if (length > phoneNumPosition + 4) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Dump log information.
+     * @param info Log information.
+     * @hide
+     */
+    public static void log(String info) {
+        if (DEBUG) Rlog.d(TAG, info);
+        }
+}
diff --git a/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java b/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
new file mode 100755
index 0000000..62b6e2b
--- /dev/null
+++ b/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
@@ -0,0 +1,135 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+package com.mediatek.telephony;
+
+import android.text.Editable;
+import android.text.Selection;
+import android.text.TextWatcher;
+
+
+/**
+ * Watches a TextView and if a phone number is entered will format it. The formatting
+ * is based on the current system default sim iso. when this object is created and future
+ * sim changes may not take effect on this instance.
+ * @hide
+ */
+public class PhoneNumberFormattingTextWatcherEx implements TextWatcher {
+
+    static private int sFormatType;
+    //static private Locale sCachedLocale;
+    private String sCachedSimIso;
+    private boolean mFormatting;
+    private boolean mDeletingHyphen;
+    private int mHyphenStart;
+    private boolean mDeletingBackward;
+
+
+    public PhoneNumberFormattingTextWatcherEx() {
+        /*
+        if (sCachedLocale == null || sCachedLocale != Locale.getDefault()) {
+            sCachedLocale = Locale.getDefault();
+            sFormatType = PhoneNumberFormatUtilEx.getFormatTypeForLocale(sCachedLocale);
+        }
+        */
+        if (sCachedSimIso == null) {
+            sCachedSimIso = PhoneNumberFormatUtilEx.getDefaultSimCountryIso();
+            sFormatType = PhoneNumberFormatUtilEx.getFormatTypeFromCountryCode(sCachedSimIso);
+        }
+    }
+
+    /**
+     * Format the input string after the text is changed.
+     * @param text The text editor to be formatted.
+     * @hide
+     */
+    public synchronized void afterTextChanged(Editable text) {
+        // Make sure to ignore calls to afterTextChanged caused by the work done below
+        if (!mFormatting) {
+            mFormatting = true;
+
+            // If deleting the hyphen, also delete the char before or after that
+            if (mDeletingHyphen && mHyphenStart > 0) {
+                if (mDeletingBackward) {
+                    if (mHyphenStart - 1 < text.length()) {
+                        text.delete(mHyphenStart - 1, mHyphenStart);
+                    }
+                } else if (mHyphenStart < text.length()) {
+                    text.delete(mHyphenStart, mHyphenStart + 1);
+                }
+            }
+
+            PhoneNumberFormatUtilEx.formatNumber(text, sFormatType);
+            mFormatting = false;
+        }
+    }
+
+    /**
+     * Check if the user is deleting a hyphen.
+     * @param s The string to be checked.
+     * @param start start value of selection
+     * @param count The count of character to be deleted
+     * @param after Check if for deleting
+     * @hide
+     */
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+        // Check if the user is deleting a hyphen
+        if (!mFormatting) {
+            // Make sure user is deleting one char, without a selection
+            final int selStart = Selection.getSelectionStart(s);
+            final int selEnd = Selection.getSelectionEnd(s);
+            if (s.length() > 1 // Can delete another character
+                    && count == 1 // Deleting only one character
+                    && after == 0 // Deleting
+                    && s.charAt(start) == '-' // a hyphen
+                    && selStart == selEnd) { // no selection
+                mDeletingHyphen = true;
+                mHyphenStart = start;
+                // Check if the user is deleting forward or backward
+                if (selStart == start + 1) {
+                    mDeletingBackward = true;
+                } else {
+                    mDeletingBackward = false;
+                }
+            } else {
+                mDeletingHyphen = false;
+            }
+        }
+    }
+
+    /**
+     * Not used.
+     * @hide
+     */
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+        // Does nothing
+    }
+}
+
diff --git a/src/java/com/mediatek/telephony/TelephonyManagerEx.java b/src/java/com/mediatek/telephony/TelephonyManagerEx.java
new file mode 100644
index 0000000..0375ade
--- /dev/null
+++ b/src/java/com/mediatek/telephony/TelephonyManagerEx.java
@@ -0,0 +1,1368 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import com.android.internal.telephony.IPhoneSubInfo;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.ITelephonyRegistry;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Message;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import java.util.List;
+
+import android.telephony.SubscriptionManager;
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
+
+/**
+ * Provides access to information about the telephony services on
+ * the device, especially for multiple SIM cards device.
+ *
+ * Applications can use the methods in this class to
+ * determine telephony services and states, as well as to access some
+ * types of subscriber information. Applications can also register
+ * a listener to receive notification of telephony state changes.
+ *
+ * Note that access to some telephony information is
+ * permission-protected. Your application cannot access the protected
+ * information unless it has the appropriate permissions declared in
+ * its manifest file. Where permissions apply, they are noted in the
+ * the methods through which you access the protected information.
+ */
+public class TelephonyManagerEx {
+    private static final String TAG = "TelephonyManagerEx";
+
+    private Context mContext = null;
+    private ITelephonyRegistry mRegistry;
+
+
+    /* Add for  Phone2 */
+    private static int defaultSimId = PhoneConstants.SIM_ID_1;
+
+   /**
+    * The property record the card's ICC ID.
+    * @hide
+    */
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+
+    /**
+     * Construction function for TelephonyManager
+     * @param context a context
+     */
+    public TelephonyManagerEx(Context context) {
+
+        Rlog.d(TAG, "getSubscriberInfo");
+        mContext = context;
+        mRegistry = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService(
+                    "telephony.registry"));
+
+    }
+
+    /*  Construction function for TelephonyManager */
+    private TelephonyManagerEx() {
+
+        mRegistry = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService(
+                   "telephony.registry"));
+    }
+
+    private  static TelephonyManagerEx sInstance = new TelephonyManagerEx();
+
+    /** @hide
+     *  @return return the static instance of TelephonyManagerEx
+     */
+    public static TelephonyManagerEx getDefault() {
+        return sInstance;
+    }
+
+    /**
+     * @param simId Indicates which SIM(slot) to query
+     * @return The software version number for the device
+     * @hide
+     */
+    public String getDeviceSoftwareVersion(int simId) {
+        Rlog.d(TAG, "getDeviceSoftwareVersion simId=" + simId);
+        try {
+            return TelephonyManager.getDefault().getDeviceSoftwareVersion(simId);
+        } catch (NullPointerException ex) {
+            Rlog.e(TAG, "getDeviceSoftwareVersion error, return null. (" + ex.toString() + ")");
+            return null;
+        }
+    }
+
+    //
+    //
+    // Device Info
+    //
+    //
+
+    /**
+     * Returns the unique device identifier e.g. IMEI for GSM phones. MEID or ESN for CDMA phones.
+     * For GSM phone with multiple SIM support , there is IMEI for each SIM.
+     * Required Permission:
+     *  android.Manifest.permission READ_PHONE_STATE READ_PHONE_STATE
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Unique device ID. For GSM phones,a string of IMEI
+     * returns null if the device ID is not available.
+     */
+    public String getDeviceId(int simId) {
+        Rlog.d(TAG, "getDeviceId simId=" + simId);
+        try {
+            return TelephonyManager.getDefault().getDeviceId(simId);
+        } catch (NullPointerException ex) {
+            Rlog.e(TAG, "getDeviceId error, return null. (" + ex.toString() + ")");
+            return null;
+        }
+    }
+
+    /**
+     * Returns the current cell location of the device.
+     * <p>
+     * Required Permission:
+     *  android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION or
+     *  android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_FINE_LOCATION.
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return current cell location of the device. A CellLocation object
+     * returns null if the current location is not available.
+     *
+     */
+    public CellLocation getCellLocation(int simId) {
+        Rlog.e(TAG, "Deprecated! getCellLocation with simId " + simId);
+
+
+        try {
+            return TelephonyManager.getDefault().getCellLocation();
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Returns the neighboring cell information of the device. The getAllCellInfo is preferred
+     * and use this only if getAllCellInfo return nulls or an empty list.
+     *<p>
+     * In the future this call will be deprecated.
+     *<p>
+     * @return List of NeighboringCellInfo or null if info unavailable.
+     *
+     * Required Permission:
+     *   "android.Manifest.permission#ACCESS_COARSE_UPDATES"
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return list of NeighboringCellInfo, java.util.List<android.telephony.NeighboringCellInfo>, or null if info is unavailable
+     *
+     */
+    public List<NeighboringCellInfo> getNeighboringCellInfo(int simId) {
+        Rlog.e(TAG, "Deprecated! getNeighboringCellInfo with simId " + simId);
+
+        try {
+            return TelephonyManager.getDefault().getNeighboringCellInfo();
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Returns a constant indicating the device phone type.  This
+     * indicates the type of radio used to transmit voice calls.
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return  a constant indicating the device phone type
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     */
+    public int getPhoneType(int simId) {
+        int subIds[] = SubscriptionManager.getSubId(simId);
+        Rlog.e(TAG, "Deprecated! getPhoneType with simId " + simId + ", subId " + subIds[0]);
+        return TelephonyManager.getDefault().getCurrentPhoneType(subIds[0]);
+    }
+
+    //
+    // Current Network
+    //
+
+    /**
+     * Returns the alphabetic name of current registered operator.
+     * Please call TelephonyManager.getNetworkOperatorName(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return alphabetic name of the current registered operator, e.g. "Vodafone"
+     */
+    public String getNetworkOperatorName(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkOperatorName with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkOperatorName(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Returns the numeric name (MCC+MNC) of the current registered operator.
+     * Please call TelephonyManager.getNetworkOperator(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return numeric name (MCC+MNC) of current registered operator, e.g. "46000".
+     */
+    public String getNetworkOperator(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkOperator with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkOperatorForSubscription(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Indicates whether the device is considered roaming on the current  network, for GSM purposes.
+     * Please call TelephonyManager.isNetworkRoaming(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network.
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return Returns True if the device is considered roaming on the current network; otherwise false.
+     *
+     */
+    public boolean isNetworkRoaming(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! isNetworkRoaming with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().isNetworkRoaming(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return false;
+        }
+    }
+
+    /**
+     * Returns the ISO country code of the current registered operator's MCC(Mobile Country Code).
+     * Please call TelephonyManager.getNetworkCountryIso(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return ISO country code equivilent of the current registered
+     * operator's MCC (Mobile Country Code), e.g. "en","fr"
+     */
+    public String getNetworkCountryIso(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkCountryIso with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkCountryIsoForSubscription(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently used on the device for data transmission.
+     * Please  call TelephonyManager.getNetworkType(int subId) instead
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return constant indicating the radio technology (network type)
+     * currently used on the device. Constant may be one of the following items.
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_GPRS
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EDGE
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_UMTS
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_CDMA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_0
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_A
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_B
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_1xRTT
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_IDEN
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_LTE
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EHRPD
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP
+     */
+    public int getNetworkType(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "Deprecated! getNetworkType with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getNetworkType(subId);
+    }
+
+
+    //
+    //
+    // SIM Card
+    //
+    //
+
+    /**
+     * Gets true if a ICC card is present
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Returns True if a ICC card is present.
+     */
+    public boolean hasIccCard(int simId) {
+        Rlog.d(TAG, "hasIccCard simId=" + simId);
+        int slot = simId;
+        return TelephonyManager.getDefault().hasIccCard(slot);
+    }
+
+    private int getSubIdBySlot(int slot) {
+        int [] subId = SubscriptionManager.getSubId(slot);
+        Rlog.d(TAG, "getSubIdBySlot, simId " + slot +
+                "subId " + ((subId != null) ? subId[0] : "invalid!"));
+        return (subId != null) ? subId[0] : SubscriptionManager.getDefaultSubId();
+    }
+
+    /**
+     * Get Icc Card Type
+     * @param subId which subId to query
+     * @return "SIM" for SIM card or "USIM" for USIM card.
+     * @hide
+     * @internal
+     */
+    public String getIccCardType(int subId) {
+        String type = null;
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                type = telephony.getIccCardType(subId);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "getIccCardType sub " + subId + " ,icc type " + ((type != null) ? type : "null"));
+        return type;
+    }
+
+    /**
+     * Request to get UICC card type.
+     *
+     * @param slotId indicated sim id
+     *
+     * @return index for UICC card type
+     * @hide
+    */
+   public int getSvlteCardType(int slotId) {
+       int type = 0;
+       try {
+           ITelephonyEx telephony = getITelephonyEx();
+           if (telephony != null && CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+               type = telephony.getSvlteCardType(slotId);
+           }
+       } catch (RemoteException ex) {
+           ex.printStackTrace();
+       } catch (NullPointerException ex) {
+           // This could happen before phone restarts due to crashing
+           ex.printStackTrace();
+       }
+       Rlog.d(TAG, "getSvlteCardType(): slotId " + slotId + " ,icc type " + type);
+       return type;
+   }
+
+    /**
+     * Query is indicated app type is support of indicated Uicc Card.
+     * @param slotId which slotId to query
+     * @return "true" for supported case or "boolean" for non-supported case.
+     * @hide
+     */
+    public boolean isAppTypeSupported(int slotId, int appType) {
+        boolean isSupported = false;
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                isSupported = telephony.isAppTypeSupported(slotId, appType);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "isAppTypeSupported slotId: " + slotId + ", appType: " + appType +
+                ", isSupported: " + isSupported);
+        return isSupported;
+    }
+
+    /**
+     * Get Icc Card is a test card or not.
+     * @param simId Indicate which sim(slot) to query
+     * @return ture if the ICC card is a test card.
+     * @hide
+     */
+    public boolean isTestIccCard(int simId) {
+        boolean result = false;
+        Rlog.d(TAG, "isTestIccCard simId=" + simId);
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                result = telephony.isTestIccCard(simId);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "isTestIccCard sim " + simId + " ,result " + result);
+        return result;
+    }
+
+    /**
+     * Gets a constant indicating the state of the device SIM card.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Constant indicating the state of the device SIM card.
+     * Constant may be one of the following items.
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_UNKNOWN
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_ABSENT
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_PIN_REQUIRED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_PUK_REQUIRED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_NETWORK_LOCKED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_READY
+     *
+     */
+    public int getSimState(int simId) {
+        Rlog.d(TAG, "getSimState simId=" + simId);
+        return TelephonyManager.getDefault().getSimState(simId);
+    }
+
+    /**
+     * Gets the MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.
+     * <p>
+     * Availability: The result of calling getSimState() must be android.telephony.TelephonyManager.SIM_STATE_READY.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.
+     *
+     */
+    public String getSimOperator(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimOperator with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSimOperator(subId);
+    }
+
+    /**
+     * Gets the Service Provider Name (SPN).
+     * <p>
+     * Availability: The result of calling getSimState() must be android.telephony.TelephonyManager.SIM_STATE_READY.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Service Provider Name (SPN)
+     *
+     */
+    public String getSimOperatorName(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimOperatorName with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSimOperatorNameForSubscription(subId);
+    }
+
+    /**
+     * Gets the ISO country code equivalent for the SIM provider's country code.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Gets the ISO country code equivalent for the SIM provider's country code.
+     *
+     */
+    public String getSimCountryIso(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimCountryIso with simId " + simId + " ,subId " + subId);
+
+        return TelephonyManager.getDefault().getSimCountryIso(subId);
+    }
+
+
+    /**
+     * Returns the serial number for the given subscription, if applicable. Return null if it is
+     * unavailable.
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       serial number of the SIM, if applicable. Null is returned if it is unavailable.
+     *
+     */
+    public String getSimSerialNumber(int simId) {
+        if (simId < 0 || simId >= TelephonyManager.getDefault().getSimCount()) {
+            Rlog.e(TAG, "getSimSerialNumber with invalid simId " + simId);
+            return null;
+        }
+
+        String iccId = SystemProperties.get(PROPERTY_ICCID_SIM[simId], "");
+
+        if (iccId != null && (iccId.equals("N/A") || iccId.equals(""))) {
+            iccId = null;
+        }
+
+        return iccId;
+    }
+
+    //
+    //
+    // Subscriber Info
+    //
+    //
+
+    /**
+     * Gets the unique subscriber ID, for example, the IMSI for a GSM phone.
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       unique subscriber ID, for example, the IMSI for a GSM phone. Null is returned if it is unavailable.
+     *
+     */
+    public String getSubscriberId(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSubscriberId with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSubscriberId(subId);
+    }
+
+    /**
+     * Gets the phone number string for line 1, for example, the MSISDN for a GSM phone
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to quer
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Phone number string for line 1, for example, the MSISDN for a GSM phone. Returns null if it is unavailable.
+     *
+     */
+
+    public String getLine1Number(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getLine1Number with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getLine1NumberForSubscriber(subId);
+    }
+
+
+    /**
+     * Gets the voice mail number.
+     * <p>
+     * Required Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * <p>
+     * @param simId  Indicates which SIM (slot) to query
+     * <p>
+     * @return       Voice mail number. Null is returned if it is unavailable.
+     *
+     */
+    public String getVoiceMailNumber(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getVoiceMailNumber with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getVoiceMailNumber(subId);
+    }
+
+    /**
+     * Retrieves the alphabetic identifier associated with the voice mail number.
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Alphabetic identifier associated with the voice mail number
+     *
+     */
+    public String getVoiceMailAlphaTag(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getVoiceMailAlphaTag with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getVoiceMailAlphaTag(subId);
+    }
+
+      /**
+     * Gets the current call state according to the specific SIM ID.
+     * The call state can be one of the following states:
+     * 1) android.telephony.TelephonyManager.CALL_STATE_IDLE;
+     * 2) android.telephony.TelephonyManager.CALL_STATE_RINGING;
+     * 3) android.telephony.TelephonyManager.CALL_STATE_OFFHOOK
+     * @param  simId SIM ID for getting call state.
+     *         Value of simId:
+     *         0 for SIM1;
+     *         1 for SIM2
+     * @return Constant indicating the call state (cellular) on the device.
+     * @internal
+     */
+    public int getCallState(int simId) {
+        Rlog.d(TAG, "getCallState simId=" + simId);
+        return TelephonyManager.getDefault().getCallState(getSubIdBySlot(simId));
+    }
+
+    /**
+     * Returns a constant indicating the type of activity on a data connection
+     * (cellular).
+     *
+     * The data activity can be one of the following:
+     * 1) DATA_ACTIVITY_NONE;
+     * 2) DATA_ACTIVITY_IN;
+     * 3) DATA_ACTIVITY_OUT;
+     * 4) DATA_ACTIVITY_INOUT;
+     * 5) DATA_ACTIVITY_DORMANT
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Constant indicating the type of activity on specific SIM's data connection
+     * (cellular).
+     * @internal
+     */
+    public int getDataActivity(int simId) {
+        Rlog.d(TAG, "getDataActivity simId=" + simId);
+        // MTK TODO
+        return TelephonyManager.getDefault().getDataActivity(/* getSubIdBySlot(simId) */);
+    }
+
+    /**
+     * Returns a constant indicating the specific SIM's data connection state
+     * (cellular).
+     *
+     * The data connection state can be one of the following states:
+     * 1) DATA_DISCONNECTED;
+     * 2) DATA_CONNECTING;
+     * 3) DATA_CONNECTED;
+     * 4) DATA_SUSPENDED
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Constant indicating specific SIM's data connection state
+     * (cellular).
+     * @internal
+     */
+    public int getDataState(int simId) {
+        Rlog.d(TAG, "getDataState simId=" + simId);
+        // MTK TODO
+        return TelephonyManager.getDefault().getDataState(/* getSubIdBySlot(simId) */);
+    }
+
+
+    //
+    //
+    // PhoneStateListener
+    //
+    //
+
+
+    /**
+     *
+     * Registers a listener object to receive notification of changes
+     * in specified telephony states.
+     *
+     * To register a listener, pass a PhoneStateListener
+     * and specify at least one telephony state of interest in
+     * the events argument.
+     *
+     * At registration, and when a specified telephony state
+     * changes, the telephony manager invokes the appropriate
+     * callback method on the listener object and passes the
+     * current (udpated) values.
+     *
+     * To unregister a listener, pass the listener object and set the
+     * events argument to PhoneStateListener LISTEN_NONE LISTEN_NONE.
+     *
+     * @param listener  the android.telephony.PhoneStateListener object
+     *                  to register or unregister
+     * @param events  the telephony state(s) of interest to the listener,
+     *               as a bitwise-OR combination of PhoneStateListener
+     *               LISTEN_ flags.
+     * @param simId  Indicates which SIM to regisrer or unregister.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     */
+    public void listen(PhoneStateListener listener, int events, int simId) {
+        Rlog.d(TAG, "deprecated api, listen simId=" + simId + ",events=" + events);
+        String pkgForDebug = mContext != null ? mContext.getPackageName() : "<unknown>";
+        TelephonyManager.getDefault().listen(listener, events);
+    }
+
+
+    private ITelephony getITelephony() {
+        return ITelephony.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
+    }
+
+    private ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    /* Get current active phone type by system property, GsmPhone or CdmaPhone */
+    private int getPhoneTypeFromProperty() {
+        int type =
+            SystemProperties.getInt(TelephonyProperties.CURRENT_ACTIVE_PHONE,
+                    getPhoneTypeFromNetworkType());
+        return type;
+    }
+
+    /* Get phone type by network type, GsmPhone or CdmaPhone */
+    private int getPhoneTypeFromNetworkType() {
+    	int phoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultSubId());    	
+        String mode = TelephonyManager.getTelephonyProperty(
+                phoneId, "ro.telephony.default_network", null);
+        if (mode != null) {
+            return TelephonyManager.getDefault().getPhoneType(Integer.parseInt(mode));
+        }
+        return TelephonyManager.PHONE_TYPE_NONE;
+    }
+
+
+    /**
+     * Get service center address
+     *
+     * @param subId subscripiton identity
+     *
+     * @return Current service center address
+     * @hide
+     * @internal
+     */
+    public String getScAddress(int subId) {
+        Bundle result = getScAddressWithErroCode(subId);
+        if (result != null) {
+            return (String) result.getCharSequence(GET_SC_ADDRESS_KEY_ADDRESS);
+        }
+        return null;
+    }
+
+    /**
+     * Get SC address bundle key: result.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String GET_SC_ADDRESS_KEY_RESULT = "errorCode";
+
+    /**
+     * Get SC address bundle key: scAddress.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String GET_SC_ADDRESS_KEY_ADDRESS = "scAddress";
+
+    /**
+     * Error Code: success.
+     * Now, it is only used by {@link #getScAddressWithErroCode(subId)}.
+     *
+     * @internal
+     * @hide
+     */
+    public static final byte ERROR_CODE_NO_ERROR = 0x00;
+
+    /**
+     * Error Code: generic error.
+     * Now, it is only used by {@link #getScAddressWithErroCode(subId)}.
+     *
+     * @internal
+     * @hide
+     */
+    public static final byte ERROR_CODE_GENERIC_ERROR = 0x01;
+
+    /**
+     * Get service center address with error code.
+     *
+     * @param subId subscripiton identity
+     *
+     * @return Current service center address and error code by Bundle
+     * The error code will be
+     *     {@link #ERROR_CODE_NO_ERROR}
+     *     {@link #ERROR_CODE_GENERIC_ERROR}
+     *
+     * @internal
+     * @hide
+     */
+    public Bundle getScAddressWithErroCode(int subId) {
+        try {
+            return getITelephonyEx().getScAddressUsingSubId(subId);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return null;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Set service center address
+     *
+     * @param subId subscripiton identity
+     * @param address Address to be set
+     *
+     * @return True for success, false for failure
+     * @hide
+     * @internal
+     */
+    public boolean setScAddress(int subId, String address) {
+        try {
+            return getITelephonyEx().setScAddressUsingSubId(subId, address);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return false;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return false;
+        }
+    }
+
+    private IPhoneSubInfo getSubscriberInfo() {
+        // get it each time because that process crashes a lot
+        return IPhoneSubInfo.Stub.asInterface(ServiceManager.getService("iphonesubinfo"));
+    }
+
+
+    /**
+     * Returns the IMS private user identity (IMPI) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return the IMPI, or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimImpi(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimImpiForSubscriber(subId);
+            return getSubscriberInfo().getIsimImpi();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS home network domain name that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return the IMS domain name, or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimDomain(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimDomainForSubscriber(subId);
+            return getSubscriberInfo().getIsimDomain();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS public user identities (IMPU) that were loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return an array of IMPU strings, with one IMPU per string, or null if
+     *      not present or not loaded
+     * @hide
+     */
+    public String[] getIsimImpu(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimImpuForSubscriber(subId);
+            return getSubscriberInfo().getIsimImpu();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS Service Table (IST) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return IMS Service Table or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimIst(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimIstForSubscriber(subId);
+            return getSubscriberInfo().getIsimIst();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS Proxy Call Session Control Function(PCSCF) that were loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return an array of PCSCF strings with one PCSCF per string, or null if
+     *         not present or not loaded
+     * @hide
+     */
+    public String[] getIsimPcscf(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimPcscfForSubscriber(subId);
+            return getSubscriberInfo().getIsimPcscf();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the ISIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimGbabp() {
+        return getIsimGbabp(SubscriptionManager.getDefaultSubId());
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimGbabp(int subId) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getIsimGbabpForSubscriber(subId);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the ISIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setIsimGbabp(String gbabp, Message onComplete) {
+        setIsimGbabp(SubscriptionManager.getDefaultSubId(), gbabp, onComplete);
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the ISIM.
+     * @param subId subscription ID to be queried
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setIsimGbabp(int subId, String gbabp, Message onComplete) {
+        // MTK TODO
+        /*
+        try {
+            getSubscriberInfo().setIsimGbabpForSubscriber(subId, gbabp, onComplete);
+        } catch (RemoteException ex) {
+            return;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return;
+        }
+        */
+    }
+
+    /**
+     * Returns the USIM Service Table (UST) that was loaded from the USIM.
+     * @param service service index on UST
+     * @return the indicated service is supported or not
+     * @hide
+     */
+    public boolean getUsimService(int service) {
+        return getUsimService(SubscriptionManager.getDefaultSubId(), service);
+    }
+
+    /**
+     * Returns the USIM Service Table (UST) that was loaded from the USIM.
+     * @param subId subscription ID to be queried
+     * @param service service index on UST
+     * @return the indicated service is supported or not
+     * @hide
+     */
+    public boolean getUsimService(int subId, int service) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getUsimServiceForSubscriber(subId, service);
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return false;
+        }
+        */
+        return false;
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getUsimGbabp() {
+        return getUsimGbabp(SubscriptionManager.getDefaultSubId());
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @param subId subscription ID to be queried
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getUsimGbabp(int subId) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getUsimGbabpForSubscriber(subId);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setUsimGbabp(String gbabp, Message onComplete) {
+        setUsimGbabp(SubscriptionManager.getDefaultSubId(), gbabp, onComplete);
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param subId subscription ID to be queried
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setUsimGbabp(int subId, String gbabp, Message onComplete) {
+        // MTK TODO
+        /*
+        try {
+            getSubscriberInfo().setUsimGbabpForSubscriber(subId, gbabp, onComplete);
+        } catch (RemoteException ex) {
+            return;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return;
+        }
+        */
+    }
+
+    /**
+     * Get subscriber Id of LTE phone.
+     * @param subId the subId of CDMAPhone
+     * @return The subscriber Id of LTE phone.
+     *
+     * @hide
+     */
+    public String getSubscriberIdForLteDcPhone(int subId) {
+        try {
+            return getITelephonyEx().getSubscriberIdForLteDcPhone(subId);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return null;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return null;
+        }
+    }
+
+    /// M: [C2K][SVLTE] Define SVLTE RAT mode. @{
+    /**
+     * For C2K SVLTE RAT controll, LTE preferred mode.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_4G = 0;
+
+    /**
+     * For C2K SVLTE RAT controll, EVDO preferred mode, will disable LTE.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_3G = 1;
+
+    /**
+     * For C2K SVLTE RAT controll, LTE Data only mode, will disable CDMA and only allow LTE PS.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_4G_DATA_ONLY = 2;
+    /// @}
+
+    /**
+     * It used to get whether the device is in dual standby dual connection.
+     * For example, call application will be able to support dual connection
+     * if the device mode is in DSDA.
+     *
+     * @return true if the device is in DSDA mode, false for others
+     * @hide
+     */
+    public boolean isInDsdaMode() {
+        if (SystemProperties.get("ro.mtk_switch_antenna", "0").equals("1")) {
+            return false;
+        }
+        String mSimConfig =
+                SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);
+        String svlteMode =
+                SystemProperties.get(TelephonyProperties.PROPERTY_RADIO_SVLTE_MODE);
+
+        if (mSimConfig.equals("dsda")) {
+            if (!CdmaFeatureOptionUtils.isCdmaLteDcSupport() ||
+                    (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && svlteMode.equals("svlte"))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @return true if a ICC card is present for a subscription
+     *
+     */
+    /** {@hide} */
+    public boolean isAllowAirplaneModeChange() {
+        try {
+            return getITelephonyEx().isAllowAirplaneModeChange();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Get whether allow the airplane mode change.
+     *
+     * @return true if allow the airplane mode change.
+     * @hide
+     */
+    public boolean isAirplanemodeAvailableNow() {
+        try {
+            return getITelephonyEx().isAirplanemodeAvailableNow();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Get cdma rat mode key for the different load.
+     *
+     * @param subId The subId to get cdma rat mode.
+     * @return the rat mode key of the specific subId.
+     * @hide
+     */
+    public String getCdmaRatModeKey(int subId) {
+        // MTK TODO
+        /*
+        if (("OP09").equals(SystemProperties.get("ro.operator.optr", "OM"))) {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE;
+        } else {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE + subId;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Return the sim card if in home network.
+     *
+     * @param subId subscription ID to be queried.
+     * @return true if in home network.
+     * @hide
+     */
+    public boolean isInHomeNetwork(int subId) {
+        try {
+            return getITelephonyEx().isInHomeNetwork(subId);
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+}
-- 
1.9.1

